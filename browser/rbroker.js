/*!
 * `rbroker` JavaScript Client Library v7.4.0
 * http://deployr.revolutionanalytics.com/documents/dev/rbroker-jsdoc
 *
 * Copyright (C) 2010-2015 by Revolution Analytics Inc.
 * Released under the Apache License 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Includes:
 *   - superagent: https://github.com/visionmedia/superagent
 *   - ws: https://github.com/einaros/ws
 *   - D.js: http://malko.github.io/D.js
 *   - yui-lang.js: https://github.com/yui/yui3 (DeployR port)
 *
 * superagent
 *
 * Copyright (c) 2014-2015 TJ Holowaychuk <tj@vision-media.ca>
 * Open Source Initiative OSI - The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the,
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ws
 *
 * Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>
 * Open Source Initiative OSI - The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files 
 * (the "Software"), to deal in the Software without restriction, 
 * including without limitation the rights to use, copy, modify, merge
 * publish, distribute, sublicense, and/or sell copies of the Software, 
 * and to permit persons to whom the Software is furnished to do so, 
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * D
 *
 * Copyright (C) 2013 Jonathan Gotti <jgotti at jgotti dot net>
 * Open Source Initiative OSI - The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the,
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * selfish
 *
 * Copyright 2011 Irakli Gozalishvili. All rights reserved
 * Open Source Initiative OSI - The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the,
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * yui-lang
 *
 * The lang component is a DeployR port of yui-lang.js by Yahoo!
 *
 * Software License Agreement (BSD License)
 * Copyright (c) 2013, Yahoo! Inc. All rights reserved.
 *
 * Redistribution and use of this software in source and binary forms, 
 * with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer. Redistributions
 * in binary form must reproduce the above copyright notice, this list of
 * conditions and  the following disclaimer in the documentation and/or 
 * other materials provided with the distribution.
 * 
 * Neither the name of Yahoo! Inc. nor the names of YUI's contributors 
 * may be used to endorse or promote products derived from this software 
 * without specific prior written permission of Yahoo! Inc.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT, 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Date: 2015-07-13
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.rbroker = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */

var DiscreteTask         = require('./lib/task/discreate-task'),
    PooledTask           = require('./lib/task/pooled-task'),
    BackgroundTask       = require('./lib/task/background-task'),
    DiscreteTaskBroker   = require('./lib/engine/discrete-task-broker'),
    PooledTaskBroker     = require('./lib/engine/pooled-task-broker'),
    BackgroundTaskBroker = require('./lib/engine/background-task-broker');

// -- expose `deployr` into the global namespace for browser convenience --
if (typeof window !== 'undefined' && !window.deployr) {
    window.deployr = require('deployr');
}

/**
 * The `rbroker` global namespace object. This is the public interface for the
 * DeployR `RBroker`. It is used as a factory to simplify the creation of new
 * instances of:
 *
 * - DiscreteTaskBroker
 * - PooledTaskBroker
 * - BackgroundTaskBroker
 * - DiscreteTask
 * - PooledTask
 * - BackgroundTask
 *
 * @module rbroker
 * @for rbroker
 */
module.exports = {

    /**
     * Create an instance of an `DiscreteTaskBroker` to manage the execution of
     * a `DiscreteTask`.
     *
     * @method discreteTaskBroker
     * @static
     * @param {Object} [options] Configuration options.
     * @return {RBroker} A new instance of a `DiscreteTaskBroker`.
     * @api public
     */
    discreteTaskBroker: function(config) {
        return DiscreteTaskBroker.new(config);
    },

    /**
     * Create an instance of an `PooledTaskBroker` to manage the execution of
     * a `PooledTask`.
     *
     * @method pooledTaskBroker
     * @static
     * @param {Object} [options] Configuration options.
     * @return {RBroker} A new instance of a `PooledTaskBroker`.
     * @api public
     */
    pooledTaskBroker: function(config) {
        return PooledTaskBroker.new(config);
    },

    /**
     * Create an instance of an `BackgroundTaskBroker` to manage the execution of
     * a `BackgroundTask`.
     *
     * @method backgroundTaskBroker
     * @static
     * @param {Object} [options] Configuration options.
     * @return {RBroker} A new instance of a `BackgroundTaskBroker`.
     * @api public
     */
    backgroundTaskBroker: function(config) {
        return BackgroundTaskBroker.new(config);
    },

    /**
     * Create an instance of a `DiscreteTask` for an analytics Web service based
     * on either:
     *
     *  1. Repository-managed R script
     *
     *    ```
     *    var rtask = rbroker.discreteTask({
     *       filename: 'regression',
     *       directory: 'demo',
     *       author: 'george',
     *       version: version
     *       // Additional Discrete Task Options...
     *    });
     *    ```
     *
     * 2. URL-addressable R script
     *
     *    ```
     *    var rtask = rbroker.discreteTask( {
     *         externalsource: regressionURL
     *         // Additional Discrete Task Options...
     *    });
     *    ```
     *
     * @method discreteTask
     * @static
     * @param {Object} [options] Configuration options.
     * @return {RTask} A new instance of a `DiscreteTask`.
     * @api public
     */
    discreteTask: function(config) {
        return DiscreteTask.new(config);
    },

    /**
     * Create an instance of a `PooledTask` for an analytics Web service based
     * on either:
     *
     *  1. Repository-managed R script
     *
     *    ```
     *    var rtask = rbroker.pooledTask({
     *       filename: 'regression',
     *       directory: 'demo',
     *       author: 'george',
     *       version: version
     *       // Additional Pooled Task Options...
     *    });
     *    ```
     *
     * 2. Arbitrary block of R code
     *
     *    ```
     *    var rtask = rbroker.pooledTask({
     *         code: codeBlock
     *         // Additional Pooled Task Options...
     *    });
     *    ```
     *
     * 3. URL-addressable R script
     *
     *    ```
     *    var rtask = rbroker.pooledTask( {
     *         externalsource: regressionURL
     *         // Additional Pooled Task Options...
     *    });
     *    ```
     *
     * @method pooledTask
     * @static
     * @param {Object} [options] Configuration options.
     * @return {RTask} A new instance of a `PooledTask`.
     * @api public
     */
    pooledTask: function(config) {
        return PooledTask.new(config);
    },

    /**
     *  Create an instance of a `BackgroundTask` for an analytics Web service
     * based on either:
     *
     *  1. Repository-managed R script
     *
     *    ```
     *    var rTask = rbroker.backgroundTask({
     *       name: 'Sample Task',
     *       descr: 'Sample description',
     *       rscriptname: 'regression',
     *       rscriptdirectory: 'demo',
     *       rscriptauthor: 'george',
     *       rscriptversion: version
     *       // Additional Background Task Options...
     *    });
     *    ```
     *
     * 2. Arbitrary block of R code
     *
     *    ```
     *    var rtask = rbroker.backgroundTask({
     *         name: 'Sample Task',
     *       descr: 'Sample description',
     *         code: codeBlock
     *         // Additional Background Task Options...
     *    });
     *    ```
     *
     * 3. URL-addressable R script
     *
     *    ```
     *    var rtask = rbroker.backgroundTask( {
     *         name: 'Sample Task',
     *       descr: 'Sample description',
     *         externalsource: regressionURL
     *         // Additional Background Task Options...
     *    });
     *    ```
     *
     * @method backgroundTask
     * @static
     * @param {Object} [options] Configuration options.
     * @return {RTask} A new instance of an `BackgroundTask`.
     * @api public
     */
    backgroundTask: function(config) {
        return BackgroundTask.new(config);
    }
};

},{"./lib/engine/background-task-broker":2,"./lib/engine/discrete-task-broker":3,"./lib/engine/pooled-task-broker":4,"./lib/task/background-task":8,"./lib/task/discreate-task":9,"./lib/task/pooled-task":10,"deployr":21}],2:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var merge                = require('merge'),    
    RBrokerEngine        = require('./rbroker-engine'),
    BackgroundTaskWorker = require('../worker/background-task-worker');

/**
 * The Background Task Runtime acquires DeployR grid resources per `RTask` 
 * based on the server-side management of asynchronous grid resources. 
 *
 * @module brackground-broker
 * @for rbroker
 */
module.exports = RBrokerEngine.extend({  
  /**
   * The Background Task Runtime acquires DeployR grid resources per `RTask` 
   * based on the server-side management of asynchronous grid resources. 
   *
   * @class 
   * @constructor
   * @param {Object} [options] Configuration options.    
   */
  initialize: function (config) {
    /*
     * This limit is set simply to ensure the BackgroundTaskBroker does not 
     * swamp the server which too many concurrent HTTP requests when submitting 
     * RTask. The real queueing of RTask is handled by the server, this broker 
     * simply pushed the RTask into the server-managed queue.
     */
    var PARALLEL_TASK_LIMIT = 10;

    RBrokerEngine.initialize.call(this, merge(config, {
      maxConcurrentTaskLimit: PARALLEL_TASK_LIMIT
    }));    

    // Initialize the resourceTokenPool with Integer based resourceTokens.
    for(var i = 0; i < this.parallelTaskLimit; i++) {
      this.resourceTokenPool.offer(i);
    }
  
    this.ruser = this.validateEndpoint().io('/r/user/login')
      .data(config.credentials)
      .ctx(this)      
      .end(function(res) { this.emit('ready'); });
  }, 

  /**
   * Not supported. Support for `refresh` is only available on the 
   * `PooledTaskBroker` runtime.
   *
   * @method refresh
   * @override
   * @api public   
   */
  refresh: function (config) {
    throw new Error('BackgroundTaskBroker refresh not supported.');
  },

  /**
   * Release all client-side and server-side resources maintained by or on 
   * behalf of an instance of `RBroker`.
   *
   * @method shutdown
   * @override
   * @return {Promise} A promise wrapping the resolution of either "resolve" or 
   * "reject" callback.
   * @api public
   */ 
  shutdown: function () {
    this.flush();

    return this.ruser.release();    
  },  

  /**
   * @override
   * @api private
   */
  createWorker: function (task) {
    return BackgroundTaskWorker.new(task, this.ruser);
  }
});

},{"../worker/background-task-worker":13,"./rbroker-engine":5,"merge":41}],3:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */
var D                  = require('d.js'),
    RBrokerEngine      = require('./rbroker-engine'),
    DiscreteTaskWorker = require('../worker/discrete-task-worker');

/**
 * The Discrete Task Runtime acquires DeployR grid resources per `RTask` 
 * on-demand.
 *
 * @module discrete-broker
 * @for rbroker
 */
module.exports = RBrokerEngine.extend({
  /**
   * The Discrete Task Runtime acquires DeployR grid resources per `RTask` 
   * on-demand.
   *
   * @class 
   * @constructor
   * @param {Object} [options] Configuration options.    
   */   
   initialize: function (config) {
      RBrokerEngine.initialize.call(this, config);

      // Initialize the resourceTokenPool with Integer based resourceTokens.
      for (var i = 0; i < this.parallelTaskLimit; i++) {
         this.resourceTokenPool.offer(i);
      }

      if (config.credentials) {
         this.ruser = this.validateEndpoint().io('/r/user/login')         
            .data(config.credentials)
            .ctx(this)            
            .end(function(res) { this.emit('ready'); });
      } else {
         this.validateEndpoint(function() {
            this.ruser = null;  
            this.emit('ready');
         });
      }
   },

  /**
   * Not supported. Support for `refresh` is only available on the 
   * `PooledTaskBroker` runtime.
   *
   * @method refresh
   * @override
   * @api public   
   */
   refresh: function (config) {
      throw new Error('DiscreteTaskBroker refresh not supported.');
   },

   /**
    * @Override
    */
   createWorker: function (task) {
      return DiscreteTaskWorker.new(task, this.ruser);
   },

  /**
   * Release all client-side and server-side resources maintained by or on 
   * behalf of an instance of `RBroker`.
   *
   * @method shutdown
   * @override
   * @return {Promise} A promise wrapping the resolution of either "resolve" or 
   * "reject" callback.
   * @api public
   */ 
   shutdown: function () {
      this.flush();

      return this.ruser ? this.ruser.release() : D.promisify(true);
   }   
});
},{"../worker/discrete-task-worker":14,"./rbroker-engine":5,"d.js":19}],4:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var deployr = require('deployr');

var D                = require('d.js'),
    merge            = require('merge'),
    RBrokerEngine    = require('./rbroker-engine'),
    PooledTaskWorker = require('../worker/pooled-task-worker');    

/**
 * The Pooled Task Runtime acquires a dedicated pool of DeployR grid resources 
 * at startup.
 *
 * @module pooled-task-broker
 * @for rbroker
 */
module.exports = RBrokerEngine.extend({  
  /**
   * The Pooled Task Runtime acquires a dedicated pool of DeployR grid resources 
   * at startup.
   *
   * @class 
   * @constructor
   * @param {Object} [options] Configuration options.    
  */
  initialize: function (config) {
    RBrokerEngine.initialize.call(this, config);  

    if (!config.credentials) {
      throw new Error('Broker failed to initialize, user credentials required.');
    }

    var self     = this,
        poolSize = this.parallelTaskLimit,
        pool     = merge({ poolsize: poolSize }, config.pool || {});

    /*
     * Prevents authenticated HTTP session from timing out due to inactivity to 
     * ensure pool of RProject remain live and available to PooledTaskBroker.
     */
    this.httpKeepAlive = {
      id: null,
      PING_INTERVAL: 60000,

      start: function(ruser) {
        this.stop();
        this.id = setInterval(function() { 
          deployr.io('/r/user/about').share(ruser.getCookies()).end();
        }, this.PING_INTERVAL);
      },

      stop: function() {
        clearInterval(this.id);
      }
    };    

    /*
     * Initialize the resourceTokenPool with RProject.
     */
    function load(res) {
      var projects = res.get('projects');
      
      if (projects.length > 0) {
        // inform caller of any `Grid Notification` errors usch as:
        // 'Concurrent authenticated project limit (10) reached for user XYZ.'
        // These 'errors' are more like warnings than runtime throwable errors.
        var warn = res.get('error');        
        if (warn) { self.emit('warning', warn); }

        projects.forEach(function(project) {
          self.resourceTokenPool.offer(project.project);
        });

        self.parallelTaskLimit = self.resourceTokenPool.size();
        self.httpKeepAlive.start(self.ruser);                      
        self.emit('ready');
      } else { // No projects were created (projects.length == 0)
        self.emit('error', res.get('error'));
      }
    }
   
    //
    // Validate DeployR server `endpoint` and authenticate.
    //
    this.ruser = this.validateEndpoint().io('/r/user/login')
      .data(config.credentials)
      .ctx(this)
      .end(function() {
        // 
        // Build the project pool.
        //        
        if (config.releaseGridResources) {
          this.ruser.io('/r/user/release')
             .end()
             .io('/r/project/pool')
             .data(pool)
             .end(load);
        } else {
          this.ruser.io('/r/project/pool').data(pool).end(load);             
        }  
      });
  }, 

  /**
   * Refresh the configuration for `PooledTaskRBroker`.
   *
   * A refresh causes all workspace objects and directory files in the 
   * underlying R sessions within the pool to be cleared before new workspace 
   * objects and/or directory files are loaded per the new config options.
   *
   * Only an idle RBroker instance can be refreshed.
   *
   * @method refresh
   * @param {Object} Startup options for a `PooledTaskRBroker`.
   * @override
   * @return {Promise} A promise wrapping the resolution of either "resolve" or 
   * "reject" callback.
   * @api public   
   */
  refresh: function (config) {
    var calls = [], 
        data  = {},
        ruser = this.ruser;

    if(!this.isIdle()) {
      //var defer = when.defer();
      //defer.reject(new Error('RBroker is not idle,  refresh not permitted.'));
      //return defer.promise;
      return D.rejected(new Error('RBroker is not idle, refresh not permitted.'));
    }

    // assert only the proper parameters are on the call 
    config = config || {};
    data = {
      code: '# Refresh project on PooledTaskBroker.',
      preloadfilename: config.preloadfilename,
      preloaddirectory: config.preloaddirectory,
      preloadfileauthor: config.preloadfileauthor,
      preloadfileversion: config.preloadfileversion
    };    

    // exe will fulfill only once all the inputs have fulfilled     
    this.resourceTokenPool.q.forEach(function(project) {
      calls.push(
        deployr.io('/r/project/recycle')
        .share(ruser.getCookies())
        .delay()
        .data( { project: project })
        .end()
        .io('/r/project/execute/code')
        .share(ruser.getCookies())
        .delay()
        .data(merge(data, { project: project }))
        .end() );
    });

    // execute a series of sequentially chained tasks in sequence batches 
    // without overlap. Works in conjunction with .delay() + .end() or if no
    // .end() is used
    return deployr.pipeline(calls);      
  },

  /**
   * Release all client-side and server-side resources maintained by or on 
   * behalf of an instance of `RBroker`.
   *
   * @method shutdown
   * @override
   * @return {Promise} A promise wrapping the resolution of either "resolve" or 
   * "reject" callback.
   * @api public
   */   
  shutdown: function () {
    var projects = this.resourceTokenPool.q.slice();

    this.resourceTokenPool.q = [];
    this.httpKeepAlive.stop();
    this.flush();      

    return this.ruser.release(projects);
  },

  /**
   * @override
   * @api private
   */
  createWorker: function (task) {
    return PooledTaskWorker.new(task, this.ruser);
  }  
});

},{"../worker/pooled-task-worker":15,"./rbroker-engine":5,"d.js":19,"deployr":21,"merge":41}],5:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */
var deployr             = require('deployr'),
    merge               = require('merge'),
    Base                = require('selfish').Base,
    EventEmitter        = require('deployr/lib/emitter'),
    RTaskToken          = require('../rtask-token'),
    RTaskQueue          = require('../util/rtask-queue'),
    MAX_TASK_QUEUE_SIZE = 999;

/**
 * Represents a high-level programming model for building DeployR-enabled 
 * client applications. By using RBroker an application developer can focus 
 * entirely on integrating R Analytics, while offloading the complexity of 
 * managing client-side API task queues and server-side R session lifecycles.
 *
 * The basic programming model for working with RBroker is as follows:
 *
 * 1. Decide if the R Analytics tasks for your application should execute as:
 *    - Discrete tasks: authentication optional, grid resources allocated at 
 *      runtime, results returned immediately, no persistence. Good for 
 *      prototyping and public facing production deployments.
 *    - Pooled tasks: authentication required, grid resources pre-allocated, 
 *      results returned immediately, optional persistence to repository. Good 
 *      for enterprise production deployments, consistent runtime, 
 *      high-throughput environments.
 *    - Background tasks: authentication required, grid resources allocated at 
 *      runtime, results persisted for later retrieval. Good for periodic, 
 *      scheduled or batch processing.
 * 2. Use the factories defined in rbroker to create an appropriate instance of 
 *    `RBroke`r.
 * 3. Define the R Analytics tasks for your application as one or more `RTask`.
 * 4. Submit your `RTask` to `RBroker` for execution.
 * 5. Integrate the results of your `RTask` found within `.complete()`
 *
 * @module rbroker-engine
 * @for rbroker
 */
module.exports = Base.extend(EventEmitter, {

   /**
    * Represents a high-level programming model for building DeployR-enabled
    * client applications.
    *
    * @class 
    * @constructor
    * @param {Object} [options] Configuration options.    
    */
   initialize: function (config) {
      EventEmitter.initialize.call(this);

      var self               = this;
      this.config            = config;
      this.scope             = this.config.ctx || this; // EventEmitter context
      this.engineStarted     = false;
      this.parallelTaskLimit = this.config.maxConcurrentTaskLimit || 1;
      this.pendingLow        = RTaskQueue.new(MAX_TASK_QUEUE_SIZE);
      this.pendingHigh       = RTaskQueue.new(MAX_TASK_QUEUE_SIZE);
      this.resourceTokenPool = RTaskQueue.new(MAX_TASK_QUEUE_SIZE);

      //
      // Configure `deployr` client with supplied runtime settings and catch 
      // all `io` internal errors.
      //      
      deployr.configure( { 
        host: config.host, 
        cors: config.cors,
        logging: config.logging,
        allowSelfSignedSSLCert: config.allowSelfSignedSSLCert,
        events: {
          error: function(api, res) {
            this.emit('error', res);
          }.bind(this)
        }
      });
      
      /**
       * Correlate the running task counter and other runtime statistics.
       *
       * @private
       */
      this.runtime = {
         runningTasks: 0,

         totals: { success: 0, failure: 0 },

         stats: function(res) {
            return {
               maxConcurrency: self.maxConcurrency(),
               totalTasksRun: this.totals.success + this.totals.failure,
               totalTasksRunToSuccess: this.totals.success,
               totalTasksRunToFailure: this.totals.failure,
               totalTimeTasksOnCode: res.result.timeOnCode,
               totalTimeTasksOnServer: res.result.timeOnServer,
               totalTimeTasksOnCall: res.result.timeOnCall,
               task: res.task
            };
         },

         calibrate: function(direction) {
            this.runningTasks = this.runningTasks + direction;

            if (this.runningTasks < 0) {
               this.runningTasks = 0;
            }

            return this.runningTasks;
         }
      };

      // -- emitted by subclasses indicating workers can begin work --
      this.on('ready', function() {
         this.engineStarted = true;

         // Flush the queues to force work.
         for (var i = 0; i < this.parallelTaskLimit; i++) {
            if (!this.isIdle()) {
               this.run();
            } else {
               break;
            }
         }
      });      
   },
   
   /**
    * Test the `/r/server/info` endpoint, expect HTTP 200 othwrise
    *
    * @param {Function} The optional callback
    * @api public    
    */
   validateEndpoint: function(cb) {
      return deployr.io('/r/server/info')
             .ctx(this)
             .timeout(1000 * 10) 
             .end(cb);
   },

   owner: function() {
     return this.ruser;
   },

   /**
    * Launch an `RTaskAppSimulator` simulation. The `RTask` defined by your 
    * simulation will be automatically executed by the current instance of 
    * `RBroker`.
    *
    * Make sure to register your `.complete()`, `.error()`, `.idle()`, and
    * `.progress()` listeners before starting your simulation in order to 
    * receive asynchronous callbacks in your application when `RTask` complete 
    * and/or to receive runtime summary statistics from `RBroker` as the 
    * simulation proceeds.
    *
    * @method simulateApp
    * @param {Object} The Application Simulator that implements the
    * `simulateApp(RBroker)` method.
    * @api public
    */
   simulateApp: function(appSimulator) {
      if (appSimulator) {
         if (typeof appSimulator.simulateApp === 'function') {
            appSimulator.simulateApp(this);
         } else {
            throw new Error('ReferenceError: "simulateApp" is not defined');
         }
      }
   },

   /**
    * Submit an `RTask` for execution under the control of `RBroker`. If 
    * priority is indicated, priority tasks are automatically moved to the front
    * of the queue, ahead of all standard tasks that are already pending 
    * execution by the broker.
    *
    * @method submit   
    * @param {RTask} The `RTask` associated with this submission.
    * @param {Boolean} (optional) Mark this task as having priority.
    * @return {RTaskToken} The handle to an `RTask` live on an `RBroker`.
    * @api public
    */
   submit: function(task, priority) {
      // `worker` is a defred object. It is either currently working or queued 
      // up with an appointment to work in the future once `run()` is called   
      var worker    = this.createWorker(task),
          taskToken = RTaskToken.new(worker);

      if (priority) {
         this.pendingHigh.offer(worker);
      } else {
         this.pendingLow.offer(worker);
      }

      // start the task work      
      this.run();

      return taskToken;
   },

   /**
    * Returns the task execution concurrency levels enforced for this instance 
    * of `RBroker`.
    *
    * @method maxConcurrency
    * @return {Number} The task execution concurrency levels.
    * @api public
    */
   maxConcurrency: function() {
      return this.parallelTaskLimit;
   },

   /**
    * Flushes all pending `RTask` from queues maintained by `RBroker`. Flushing 
    * `RTask` queues ensures that queued tasks will not be executed by 
    * `RBroker`.
    *
    * @method flush
    * @return {Object} Object literal containing `RBroker` status indicating 
    * the number of currently queued and executing `RTask`.
    * @api public
    */
   flush: function() {
      this.pendingHigh.clear();
      this.pendingLow.clear();

      return this.status();
   },
   
   /**
    * Indicates if current `RBroker` instance is still connected to the DeployR 
    * server. A connection may be lost for a number of reasons, for example, due 
    * to a droppeed network connection between client and server or if the 
    * DeployR server itself goes down.
    *
    * @method isConnected
    * @return {Promise} A promise with a `Boolean` value connection status.    
    * @api public
    */
   isConnected: function() {
      var test = this.ruser ? this.ruser.io('/r/user/about') :
                   deployr.io('/r/server/info')

      //
      // (authenticated | anonymous) checks
      // authenticated  - Test connection to authenticated HTTP session
      // anonymous - Test the that the server is up.
      // 
      return test
                .global(false) // supress global error events for this `io`
                .promise()
                .success(function() {
                  return true; 
                })
                .error(function() {                
                  return false;
                });
   },

   /**
    * Returns status indicating current `RTask` activity on `RBroker`.
    *
    *
    * @method status
    * @return {Object} Object literal containing `RBroker` status indicating the 
    * number of currently queued and executing `RTask`.
    * @api public
    */
   status: function() {
      // Pending tasks include all tasks on high and low priority queues.
      var pending  = this.pendingHigh.size() + this.pendingLow.size(),
         executing = this.parallelTaskLimit - this.runtime.runningTasks,
         idle      = this.isIdle();

      return {
         pending: pending,
         executing: executing,
         idle: idle,
         toString: function() {
            return '\nRBrokerStatus: [ pending = "' + pending + '" ] ' +
               '[ executing = "' + executing + '" ] ' +
               '[ idle = "' + idle + '" ]\n';
         }
      };
   },

   /**
    * Used to determine if an `RBroker` instance is idle which can be 
    * particularly useful ahead of calls to `shutdown()`. Another options is to
    * bind a listener to the `.isIdle()` method.
    * 
    * @method isIdle
    * @return {Boolean} If the `RBroker` instance is idle.
    * @api public
    */
   isIdle: function() {
      return (this.runtime.runningTasks === 0 &&
         this.pendingLow.isEmpty() && this.pendingHigh.isEmpty());
   },

   /**
    * An initialization lifecycle listener fired during construction. 
    *
    * @method error
    * @param {Function} The callback function.    
    * @return {RBroker} The refrence to `this` `RBroker` used for chaining.
    * @api public
    */
   ready: function(fn) {
      this.on('ready', fn);

      return this;
   },      

   /**
    * A failure listener for all tasks submitted on behalf of `this` `RBroker`.
    *
    * @method error
    * @param {Function} The callback function.    
    * @return {RBroker} The refrence to `this` `RBroker` used for chaining.
    * @api public
    */
   error: function(fn) {
      this.on('error', fn);

      return this;
   },

   /**
    * A notification listener indicating warnings about dubious runtime behavior
    * submitted on behalf of `this` `RBroker`.
    *
    * @method warning
    * @param {Function} The callback function.    
    * @return {RBroker} The refrence to `this` `RBroker` used for chaining.
    * @api public
    */
   warning: function(fn) {
      this.on('warning', fn);

      return this;
   },   

   /**
    * A completion listener for all tasks submitted on behalf of `this` 
    * `RBroker`.
    *
    * @method complete
    * @param {Function} The callback function.    
    * @return {RBroker} The refrence to `this` `RBroker` used for chaining.
    * @api public
    */
   complete: function(fn) {
      this.on('complete', fn);

      return this;
   },

   /**
    * A notification listener indicating that `this` `Rbroker` is still active 
    * and there are currently no `RTasks` running or in the wait queue.
    *
    * @method idle
    * @param {Function} The callback function.    
    * @return {RBroker} The refrence to `this` `RBroker` used for chaining.
    * @api public
    */
   idle: function(fn) {
      this.on('idle', fn);

      return this;
   },

   /**
    * A notification listener for `RBroker` runtime statistics of a `RTask`.
    *
    * @method progress
    * @param {Function} The callback function.
    * @return {RBroker} The refrence to `this` `RBroker` used for chaining.
    * @api public
    */
   progress: function(fn) {
      this.on('progress', fn);

      return this;
   },

   /**
    * A notification listener for `RBroker` runtime statistics of a `RTask`.
    *
    * @method progress
    * @param {Function} The callback function.
    * @return {RBroker} The refrence to `this` `RBroker` used for chaining.
    * @api public
    */
   start: function(fn) {
      this.on('start', fn);

      return this;
   },   

   /**
    * Do the task work.
    *
    * @api private
    */
   run: function() {
      var self = this, nextWorker, resourceToken;

      if (this.engineStarted &&
         !this.resourceTokenPool.isEmpty() &&
         (!this.pendingLow.isEmpty() || !this.pendingHigh.isEmpty())) {

         nextWorker = this.pendingHigh.take() || this.pendingLow.take();

         this.runtime.calibrate(+1);

         this.emit('start', nextWorker.task);
         
         nextWorker.work(this.resourceTokenPool.take()) // start working.... 
             .then(function(res) {
                 self.runtime.totals.success++;
                 self.emit('progress', self.runtime.stats(res));
                 self.emit('complete', res.task, res.result);

                 // -- individual RTask notifications --                 
                 this.resolve(res);
             }.bind(nextWorker), function(err) {
                 var res = {
                     task: this.task,
                     result: { // task error result
                         id: null,
                         type: this.task.type,
                         success: false,
                         timeOnCode: 0,
                         timeOnServer: 0,
                         timeOnCall: 0,
                         failure: err
                     }
                 };

                 self.runtime.totals.failure++;
                 self.emit('progress', self.runtime.stats(res));                  
                 self.emit('error', merge(err, { task: this.task }));
                 self.emit('complete', res.task, res.result);
                 
                 // -- individual RTask notifications --
                 this.reject(merge(err, { task: this.task }));
             }.bind(nextWorker))
             .ensure(function(v) { // finally
                 self.runtime.calibrate(-1);
                 self.resourceTokenPool.offer(this.resourceToken);
                 self.run();

                 // -- notify all tasks submitted have came to completion --           
                 if (self.isIdle()) { self.emit('idle'); }
             }.bind(nextWorker));
      }
   }
});
},{"../rtask-token":6,"../util/rtask-queue":12,"deployr":21,"deployr/lib/emitter":23,"merge":41,"selfish":42}],6:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2015 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */
var Base = require('selfish').Base;

/**
 * Represents a handle to an `RTask` live on an `RBroker`.
 *
 * @module rtask-token
 * @for rbroker
 */
module.exports = Base.extend({

    /**
     * Represents a handle to an `RTask` live on an `RBroker`.
     *
     * @class 
     * @constructor
     * @param {RTask} The task worker.
     */
    initialize: function initialize(worker) {
        this.worker    = worker;
        this.cancelled = false;
    },

    /**    
     * Terminates `this` running task.
     *
     * @method cancel
     * @param {Boolean} Permission to interrupt task if it is running.
     * @return {RTaskToken} for chaining.
     * @api public
     */
    cancel: function(interrupt) {
        // RTask completed (resolved|rejected), can not be cancelled.
        this.cancelled = this.worker.terminate(interrupt);
        return this.cancelled;
    },

    /**    
     * Returns the `RTask` associated with this `RTaskToken`.
     *
     * @method getTask
     * @return {RTaskToken} for chaining.
     * @api public
     */
    getTask: function() {
        return this.worker.task;
    },

    /**    
     * Returns `true` if this task completed. Completion may be due to normal 
     * termination, an exception, or cancellation -- in all of these cases, 
     * this method will return `true`.
     *
     * @deprecated  
     * @method isDone
     * @return {Boolean} If `this` task is completed.
     * @api public
     */
    isDone: function() {
        return !this.isPending();
    },

    /**    
     * Returns `false` if this task completed. Completion may be due to normal 
     * termination, an exception, or cancellation -- in all of these cases, 
     * this method will return `true`.
     *
     * @method isPending
     * @return {Boolean} `true` if this task has not yet been completed.
     * @api public
     */
    isPending: function() {
        return this.worker.isPending();
    },

    /**    
     * Returns `true` if this task was cancelled before it completed normally.
     *
     * @method isCancelled
     * @return {Boolean} `true` if this task was cancelled before it completed.
     * @api public
     */
    isCancelled: function() {
        return this.cancelled;
    },

    /**
     * The `.promise()` method returns a dynamically generated Promise that is 
     * resolved once this task has completed.
     *   
     * @method promise
     * @return {Promise} A promise wrapping the resolution of either "resolve" 
     * or "reject" callback.
     * @api public
     */
    promise: function() {
        return this.worker.defer.promise;
    }
});
},{"selfish":42}],7:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var Base     = require('selfish').Base,
    Enum     = require('enum'),
    taskEnum = new Enum(['DISCRETE', 'POOLED', 'BACKGROUND'], 'RTaskType');

/**
 * Defines the currently supported set of `RTask`.
 *
 * @module rtask-type
 * @for rbroker
 */
module.exports = Base.extend({
    /**
     * Discrete task.
     */
    DISCRETE: taskEnum.DISCRETE,

    /**
     * Pooled task.
     */
    POOLED: taskEnum.POOLED,

    /**
     * Background task.
     */
    BACKGROUND: taskEnum.BACKGROUND
});
},{"enum":39,"selfish":42}],8:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */

var Base      = require('selfish').Base,
    RTaskType = require('../rtask-type'),
    RTask     = require('./rtask');

module.exports = Base.extend(RTask, {

    initialize: function(props) {
        RTask.initialize.call(this, props, RTaskType.BACKGROUND);
    },

    toString: function() {
        return 'BackgroundTask: ' + RTask.toString.call(this);
    }
});
},{"../rtask-type":7,"./rtask":11,"selfish":42}],9:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */

var Base      = require('selfish').Base,
    RTaskType = require('../rtask-type'),
    RTask     = require('./rtask');

module.exports = Base.extend(RTask, {

    initialize: function(props) {
        RTask.initialize.call(this, props, RTaskType.DISCRETE);
    },

    toString: function() {
        return 'DiscreteTask: ' + RTask.toString.call(this);
    }
});

},{"../rtask-type":7,"./rtask":11,"selfish":42}],10:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */

var Base      = require('selfish').Base,
    RTaskType = require('../rtask-type'),
    RTask     = require('./rtask');

module.exports = Base.extend(RTask, {

    initialize: function(props) {
        RTask.initialize.call(this, props, RTaskType.POOLED);
    },        

    toString: function() {
        return 'PooledTask: ' + RTask.toString.call(this);
    }
});
},{"../rtask-type":7,"./rtask":11,"selfish":42}],11:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */

var Base = require('selfish').Base;

/**
 * Represents any R Analytics task for execution on an `RBroker`.
 *
 * @module rtask
 * @for rbroker
 */
module.exports = Base.extend({

    /**
     * Represents any R Analytics task for execution on an `RBroker`.
     *
     * @class
     * @constructs
     * @param {Object} props - The task properties object hash.
     */
    initialize: function initialize(props, type) {
        var self = this;

        props = props || {};

        this.type = type;
        this.propKeys = Object.keys(props);
        this.token = null;

        for (var i in props) {
            (function(i) {
                Object.defineProperty(self, i, {
                    get: function() {
                        return props[i];
                    },
                    set: function(value) {
                        props[i] = value;
                    }
                })
            })(i);
        }
    },

    /**
     * A copy of the `RTask` properties as a flat object.
     *
     * @returns {Object} A copy of the `RTask` properties.
     */
    serialize: function() {
        var clone = {};
        for (var keys = this.propKeys, l = keys.length; l; --l) {
            clone[keys[l - 1]] = this[keys[l - 1]];
        }

        return clone;
    },

    toString: function() {
        var out = '',
            keys = this.propKeys;

        for (var o in keys) {
            out += ' [ ' + keys[o] + ' = "' + this[keys[o]] + '" ]';
        }

        if (this.token) {
            out += ' [ token = "' + this.token + '" ]';
        }

        return out;
    }
});

},{"selfish":42}],12:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */
 
var Base = require('selfish').Base;

var RTaskQueue = Base.extend({
   initialize: function (capacity) {
      this.capacity = capacity;
      this.q        = [];
   }, 

   /**
    * Inserts the specified element at the tail of this queue if it is possible 
    * to do so immediately without exceeding the queue's capacity, returning 
    * ```true``` upon success and ```false``` if this queue is full.
    */
   offer: function (rtask) {
      var accepting = this.size() < this.capacity;

      if (accepting) {        
        this.q.push(rtask);      
      }

      return accepting; // True if added False otherwise
   },

   /**
    * Retrieves and removes the head of this queue.
    */
   take: function () {
    return this.q.shift();
   },

   /**
    * Retrieves, but does not remove, the head of this queue, or returns `
    * ``null`` if this queue is empty.
    */
   peek: function () {
    return this.q[0];
   },

   /**
    * Returns the number of elements in this queue.
    */
   size: function () {
      return this.q.length;
   },

   /**
    * Returns ```true``` if this collection contains no elements.
    * This implementation returns size() === 0.
    */
   isEmpty: function () {
      return this.size() === 0;
   },

   clear: function () {
      this.q.length = 0;
   },

   iter: function (fn) {
      this.q.forEach(fn);
   }
});

module.exports = RTaskQueue;
},{"selfish":42}],13:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */

var Base          = require('selfish').Base,
    deployr       = require('deployr'),
    D             = require('d.js'),    
    RTaskType     = require('../rtask-type'),
    RBrokerWorker = require('./rbroker-worker');

module.exports = RBrokerWorker.extend({

    initialize: function (task, ruser) {
        RBrokerWorker.initialize.call(this, task);
        this.ruser = ruser;
        this.job   = null;
    },

    work: function(resourceToken) {
        var self      = this,                        
            startTime = new Date().getTime(),
            data      = this.task.serialize(),
            rinputs   = data.rinputs || [],
            routputs  = data.routputs || [];

        delete data.rinputs;
        delete data.routputs;

        this.resourceToken = resourceToken;        

        return deployr.io('/r/job/submit')
            .share(this.ruser.getCookies())
            .data(data)
            .global(false) // supress global error events for this `io`
            .rinputs(rinputs)
            .routputs(routputs)
            .promise()
            .then(function(res) {
                var about = res.get('job');

                self.job = about.job; // job-id     

                // resolve the promise which kicks-off the callback
                return {
                    task: self.task,
                    result: {
                        id: about.job,
                        type: RTaskType.BACKGROUND,
                        timeOnCode: 0,
                        timeOnServer: 0,
                        timeOnCall: (new Date().getTime() - startTime),
                        success: true,
                        failure: null
                    }
                };
            });
    },

    terminate: function(interrupt) {
        if (interrupt && this.job) {
          this.ruser.io('/r/job/cancel')
            .data({ job: this.job })
            .end();

            return true;
        } else {
            //
            // RTask still pending confirmation from RBroker if there is no
            // `resourceToken` hence can not be interrupted [or] the task is
            // being worked on and a forced `interrupt` was not given
            //
            return false;
        }
    }
});

},{"../rtask-type":7,"./rbroker-worker":16,"d.js":19,"deployr":21,"selfish":42}],14:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */

var Base          = require('selfish').Base,
    deployr       = require('deployr'),
    D             = require('d.js'),    
    RTaskType     = require('../rtask-type'),
    RBrokerWorker = require('./rbroker-worker');

module.exports = RBrokerWorker.extend({

    initialize: function(task, ruser) {
        RBrokerWorker.initialize.call(this, task);
        this.ruser = ruser;
        this.io    = null; // `io` request for 'termination' if called
    },

    work: function(resourceToken) {
        var task      = this.task,
            startTime = new Date().getTime(),
            data      = this.task.serialize(),
            rinputs   = data.rinputs || [],
            routputs  = data.routputs || [];

        delete data.rinputs;
        delete data.routputs;

        this.resourceToken = resourceToken;

        // save `io` request for 'termination' purposes
        this.io = deployr.io('/r/repository/script/execute')
            // make parallel http req. using the same session
            .share(this.ruser ? this.ruser.getCookies() : null)
            .data(data)
            .rinputs(rinputs)
            .routputs(routputs)            
            .global(false); // supress global error events for this `io`

        // send the script execution request and return a promise
        return this.io.promise()
            .then(function(res) {
                res = res.deployr.response;

                var timeOnServer     = res.execution.timeTotal,
                    id               = res.project.project,
                    generatedConsole = res.execution.console,
                    generatedPlots   = res.execution.results,
                    generatedFiles   = res.execution.artifacts,
                    generatedObjects = res.workspace.objects,
                    storedFiles      = res.repository.files;

                // resolve the promise which kicks-off the callback values
                return {
                    task: task,
                    result: {
                        id: id,
                        type: RTaskType.DISCRETE,
                        success: true,
                        timeOnCode: res.execution.timeCode,
                        timeOnServer: timeOnServer,
                        timeOnCall: (new Date().getTime() - startTime),
                        failure: null,
                        interrupted: false,
                        generatedConsole: generatedConsole,
                        generatedPlots: generatedPlots,
                        generatedFiles: generatedFiles,
                        generatedObjects: generatedObjects,
                        storedFiles: storedFiles
                    }
                };
            });
    },

    terminate: function(interrupt) {
        //
        // @NOTE:
        // There is no way to obtain DeployR reference, such as a projectId, for
        // an stateless execution in-progress, so aborting the current RTask 
        // operation is not possible. At best we can do here is free-up the 
        // client connection and abort.
        //        
        if (interrupt && this.io && this.isPending()) {
            this.io.abort();
            this.io.destroy();
            this.io = null;

            return true;
        } else {
            //
            // RTask still pending confirmation from RBroker if there is no
            // `resourceToken` hence can not be interrupted [or] the task is
            // being worked on and a forced `interrupt` was not given
            //
            return false;
        }
    }
});

},{"../rtask-type":7,"./rbroker-worker":16,"d.js":19,"deployr":21,"selfish":42}],15:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var Base          = require('selfish').Base,
    D             = require('d.js'),
    merge         = require('merge'),
    deployr       = require('deployr'),
    RTaskType     = require('../rtask-type'),
    RBrokerWorker = require('./rbroker-worker');

module.exports = RBrokerWorker.extend({

    initialize: function (task, ruser) {
        RBrokerWorker.initialize.call(this, task);
        this.ruser = ruser;
    },

    work: function(resourceToken) {
        var task = this.task, 
            data = merge({
                project: resourceToken,
                phantom: true
            }, this.task.serialize()),
            api       = '/r/project/execute/' + (data.code ? 'code' : 'script'),
            rinputs   = data.rinputs || [],
            routputs  = data.routputs || [],
            startTime = new Date().getTime();

        delete data.rinputs;
        delete data.routputs;

        this.resourceToken = resourceToken;

        return deployr.io(api)
            .share(this.ruser.getCookies())
            .data(data)
            .rinputs(rinputs)
            .routputs(routputs)
            .global(false) // supress global error events for this `io`            
            .promise()
            .then(function(res) {
                res = res.deployr.response;

                var generatedConsole = res.execution.console,
                    generatedPlots   = res.execution.results,
                    generatedFiles   = res.execution.artifacts,
                    generatedObjects = res.workspace.objects,
                    storedFiles      = res.repository.files;
              
                // resolve the promise which kicks-off the callback
                return {
                    task: task,
                    result: {
                        id: res.project.project,
                        type: RTaskType.POOLED,
                        success: true,
                        timeOnCode: res.execution.timeCode,
                        timeOnServer: res.execution.timeTotal,
                        timeOnCall: (new Date().getTime() - startTime),
                        failure: null,
                        interrupted: false,
                        generatedConsole: generatedConsole,
                        generatedPlots: generatedPlots,
                        generatedFiles: generatedFiles,
                        generatedObjects: generatedObjects,
                        storedFiles: storedFiles
                    }
                };
            })
    },

    terminate: function(interrupt) {
        // work has started and a forced interrupt given
        if (interrupt && this.resourceToken && this.isPending()) {
            this.ruser.io('/r/project/execute/interrupt')
                .data({ project: this.resourceToken })
                .end();  
            return true;          
        } else {
            //
            // RTask still pending confirmation from RBroker if there is no
            // `resourceToken` hence can not be interrupted [or] the task is
            // being worked on and a forced `interrupt` was not given
            //
            return false;
        }
    }

});

},{"../rtask-type":7,"./rbroker-worker":16,"d.js":19,"deployr":21,"merge":41,"selfish":42}],16:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var Base = require('selfish').Base,
    D    = require('d.js');

module.exports = Base.extend({
    initialize: function initialize(task) {
        this.task  = task;
        this.defer = D();
    },

    work: function(resourceToken) { /* override */ },

    terminate: function(interrupt) { /* override */ },

    isPending: function() {
        return this.defer.promise.isPending();
    },

    resolve: function(result) {
        this.defer.resolve(result);
    },

    reject: function(err) {
        this.defer.reject(err);
    }
});

},{"d.js":19,"selfish":42}],17:[function(require,module,exports){

},{}],18:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],19:[function(require,module,exports){
(function (process){
/**
* attempt of a simple defer/promise library for mobile development
* @author Jonathan Gotti < jgotti at jgotti dot net>
* @since 2012-10
* @version 0.6.0
* @changelog
*           - 2013-12-07 - last promise 1.1 specs test passings (thx to wizardwerdna)
 *                       - reduce promises footprint by unscoping methods that could be
*           - 2013-10-23 - make it workig across node-webkit contexts
*           - 2013-07-03 - bug correction in promixify method (thx to adrien gibrat )
*           - 2013-06-22 - bug correction in nodeCapsule method
*           - 2013-06-17 - remove unnecessary Array.indexOf method dependency
*           - 2013-04-18 - add try/catch block around nodeCapsuled methods
*           - 2013-04-13 - check promises/A+ conformity
*                        - make some minication optimisations
*           - 2013-03-26 - add resolved, fulfilled and rejected methods
*           - 2013-03-21 - browser/node compatible
*                        - new method nodeCapsule
*                        - simpler promixify with full api support
*           - 2013-01-25 - add rethrow method
*                        - nextTick optimisation -> add support for process.nextTick + MessageChannel where available
*           - 2012-12-28 - add apply method to promise
*           - 2012-12-20 - add alwaysAsync parameters and property for default setting
*/
(function(undef){
	"use strict";

	var nextTick
		, isFunc = function(f){ return ( typeof f === 'function' ); }
		, isArray = function(a){ return Array.isArray ? Array.isArray(a) : (a instanceof Array); }
		, isObjOrFunc = function(o){ return !!(o && (typeof o).match(/function|object/)); }
		, isNotVal = function(v){ return (v === false || v === undef || v === null); }
		, slice = function(a, offset){ return [].slice.call(a, offset); }
		, undefStr = 'undefined'
		, tErr = typeof TypeError === undefStr ? Error : TypeError
	;
	if ( (typeof process !== undefStr) && process.nextTick ) {
		nextTick = process.nextTick;
	} else if ( typeof MessageChannel !== undefStr ) {
		var ntickChannel = new MessageChannel(), queue = [];
		ntickChannel.port1.onmessage = function(){ queue.length && (queue.shift())(); };
		nextTick = function(cb){
			queue.push(cb);
			ntickChannel.port2.postMessage(0);
		};
	} else {
		nextTick = function(cb){ setTimeout(cb, 0); };
	}
	function rethrow(e){ nextTick(function(){ throw e;}); }

	/**
	 * @typedef deferred
	 * @property {promise} promise
	 * @method resolve
	 * @method fulfill
	 * @method reject
	 */

	/**
	 * @typedef {function} fulfilled
	 * @param {*} value promise resolved value
	 * @returns {*} next promise resolution value
	 */

	/**
	 * @typedef {function} failed
	 * @param {*} reason promise rejection reason
	 * @returns {*} next promise resolution value or rethrow the reason
	 */

	//-- defining unenclosed promise methods --//
	/**
	 * same as then without failed callback
	 * @param {fulfilled} fulfilled callback
	 * @returns {promise} a new promise
	 */
	function promise_success(fulfilled){ return this.then(fulfilled, undef); }

	/**
	 * same as then with only a failed callback
	 * @param {failed} failed callback
	 * @returns {promise} a new promise
	 */
	function promise_error(failed){ return this.then(undef, failed); }


	/**
	 * same as then but fulfilled callback will receive multiple parameters when promise is fulfilled with an Array
	 * @param {fulfilled} fulfilled callback
	 * @param {failed} failed callback
	 * @returns {promise} a new promise
	 */
	function promise_apply(fulfilled, failed){
		return this.then(
			function(a){
				return isFunc(fulfilled) ? fulfilled.apply(null, isArray(a) ? a : [a]) : (defer.onlyFuncs ? a : fulfilled);
			}
			, failed || undef
		);
	}

	/**
	 * cleanup method which will be always executed regardless fulfillment or rejection
	 * @param {function} cb a callback called regardless of the fulfillment or rejection of the promise which will be called
	 *                      when the promise is not pending anymore
	 * @returns {promise} the same promise untouched
	 */
	function promise_ensure(cb){
		function _cb(){ cb(); }
		this.then(_cb, _cb);
		return this;
	}

	/**
	 * take a single callback which wait for an error as first parameter. other resolution values are passed as with the apply/spread method
	 * @param {function} cb a callback called regardless of the fulfillment or rejection of the promise which will be called
	 *                      when the promise is not pending anymore with error as first parameter if any as in node style
	 *                      callback. Rest of parameters will be applied as with the apply method.
	 * @returns {promise} a new promise
	 */
	function promise_nodify(cb){
		return this.then(
			function(a){
				return isFunc(cb) ? cb.apply(null, isArray(a) ? a.splice(0,0,undefined) && a : [undefined,a]) : (defer.onlyFuncs ? a : cb);
			}
			, function(e){
				return cb(e);
			}
		);
	}

	/**
	 *
	 * @param {function} [failed] without parameter will only rethrow promise rejection reason outside of the promise library on next tick
	 *                            if passed a failed method then will call failed on rejection and throw the error again if failed didn't
	 * @returns {promise} a new promise
	 */
	function promise_rethrow(failed){
		return this.then(
			undef
			, failed ? function(e){ failed(e); throw e; } : rethrow
		);
	}

	/**
	* @param {boolean} [alwaysAsync] if set force the async resolution for this promise independantly of the D.alwaysAsync option
	* @returns {deferred} defered object with property 'promise' and methods reject,fulfill,resolve (fulfill being an alias for resolve)
	*/
	var defer = function (alwaysAsync){
		var alwaysAsyncFn = (undef !== alwaysAsync ? alwaysAsync : defer.alwaysAsync) ? nextTick : function(fn){fn();}
			, status = 0 // -1 failed | 1 fulfilled
			, pendings = []
			, value
			/**
			 * @typedef promise
			 */
			, _promise  = {
				/**
				 * @param {fulfilled|function} fulfilled callback
				 * @param {failed|function} failed callback
				 * @returns {promise} a new promise
				 */
				then: function(fulfilled, failed){
					var d = defer();
					pendings.push([
						function(value){
							try{
								if( isNotVal(fulfilled)){
									d.resolve(value);
								} else {
									d.resolve(isFunc(fulfilled) ? fulfilled(value) : (defer.onlyFuncs ? value : fulfilled));
								}
							}catch(e){
								d.reject(e);
							}
						}
						, function(err){
							if ( isNotVal(failed) || ((!isFunc(failed)) && defer.onlyFuncs) ) {
								d.reject(err);
							}
							if ( failed ) {
								try{ d.resolve(isFunc(failed) ? failed(err) : failed); }catch(e){ d.reject(e);}
							}
						}
					]);
					status !== 0 && alwaysAsyncFn(execCallbacks);
					return d.promise;
				}

				, success: promise_success

				, error: promise_error
				, otherwise: promise_error

				, apply: promise_apply
				, spread: promise_apply

				, ensure: promise_ensure

				, nodify: promise_nodify

				, rethrow: promise_rethrow

				, isPending: function(){ return !!(status === 0); }

				, getStatus: function(){ return status; }
			}
		;
		_promise.toSource = _promise.toString = _promise.valueOf = function(){return value === undef ? this : value; };


		function execCallbacks(){
			if ( status === 0 ) {
				return;
			}
			var cbs = pendings, i = 0, l = cbs.length, cbIndex = ~status ? 0 : 1, cb;
			pendings = [];
			for( ; i < l; i++ ){
				(cb = cbs[i][cbIndex]) && cb(value);
			}
		}

		/**
		 * fulfill deferred with given value
		 * @param {*} val
		 * @returns {deferred} this for method chaining
		 */
		function _resolve(val){
			var done = false;
			function once(f){
				return function(x){
					if (done) {
						return undefined;
					} else {
						done = true;
						return f(x);
					}
				};
			}
			if ( status ) {
				return this;
			}
			try {
				var then = isObjOrFunc(val) && val.then;
				if ( isFunc(then) ) { // managing a promise
					if( val === _promise ){
						throw new tErr("Promise can't resolve itself");
					}
					then.call(val, once(_resolve), once(_reject));
					return this;
				}
			} catch (e) {
				once(_reject)(e);
				return this;
			}
			alwaysAsyncFn(function(){
				value = val;
				status = 1;
				execCallbacks();
			});
			return this;
		}

		/**
		 * reject deferred with given reason
		 * @param {*} Err
		 * @returns {deferred} this for method chaining
		 */
		function _reject(Err){
			status || alwaysAsyncFn(function(){
				try{ throw(Err); }catch(e){ value = e; }
				status = -1;
				execCallbacks();
			});
			return this;
		}
		return /**@type deferred */ {
			promise:_promise
			,resolve:_resolve
			,fulfill:_resolve // alias
			,reject:_reject
		};
	};

	defer.deferred = defer.defer = defer;
	defer.nextTick = nextTick;
	defer.alwaysAsync = true; // setting this will change default behaviour. use it only if necessary as asynchronicity will force some delay between your promise resolutions and is not always what you want.
	/**
	* setting onlyFuncs to false will break promises/A+ conformity by allowing you to pass non undefined/null values instead of callbacks
	* instead of just ignoring any non function parameters to then,success,error... it will accept non null|undefined values.
	* this will allow you shortcuts like promise.then('val','handled error'')
	* to be equivalent of promise.then(function(){ return 'val';},function(){ return 'handled error'})
	*/
	defer.onlyFuncs = true;

	/**
	 * return a fulfilled promise of given value (always async resolution)
	 * @param {*} value
	 * @returns {promise}
	 */
	defer.resolved = defer.fulfilled = function(value){ return defer(true).resolve(value).promise; };

	/**
	 * return a rejected promise with given reason of rejection (always async rejection)
	 * @param {*} reason
	 * @returns {promise}
	 */
	defer.rejected = function(reason){ return defer(true).reject(reason).promise; };

	/**
	 * return a promise with no resolution value which will be resolved in time ms (using setTimeout)
	 * @param {int} [time] in ms default to 0
	 * @returns {promise}
	 */
	defer.wait = function(time){
		var d = defer();
		setTimeout(d.resolve, time || 0);
		return d.promise;
	};

	/**
	 * return a promise for the return value of function call which will be fulfilled in delay ms or rejected if given fn throw an error
	 * @param {function} fn
	 * @param {int} [delay] in ms default to 0
	 * @returns {promise}
	 */
	defer.delay = function(fn, delay){
		var d = defer();
		setTimeout(function(){ try{ d.resolve(fn.apply(null)); }catch(e){ d.reject(e); } }, delay || 0);
		return d.promise;
	};

	/**
	 * if given value is not a promise return a fulfilled promise resolved to given value
	 * @param {*} promise a value or a promise
	 * @returns {promise}
	 */
	defer.promisify = function(promise){
		if ( promise && isFunc(promise.then) ) { return promise;}
		return defer.resolved(promise);
	};

	function multiPromiseResolver(callerArguments, returnPromises){
		var promises = slice(callerArguments);
		if ( promises.length === 1 && isArray(promises[0]) ) {
			if(! promises[0].length ){
				return defer.fulfilled([]);
			}
			promises = promises[0];
		}
		var args = []
			, d = defer()
			, c = promises.length
		;
		if ( !c ) {
			d.resolve(args);
		} else {
			var resolver = function(i){
				promises[i] = defer.promisify(promises[i]);
				promises[i].then(
					function(v){
						if (! (i in args) ) { //@todo check this is still required as promises can't be resolve more than once
							args[i] = returnPromises ? promises[i] : v;
							(--c) || d.resolve(args);
						}
					}
					, function(e){
						if(! (i in args) ){
							if( ! returnPromises ){
								d.reject(e);
							} else {
								args[i] = promises[i];
								(--c) || d.resolve(args);
							}
						}
					}
				);
			};
			for( var i = 0, l = c; i < l; i++ ){
				resolver(i);
			}
		}
		return d.promise;
	}

	/**
	 * return a promise for all given promises / values.
	 * the returned promises will be fulfilled with a list of resolved value.
	 * if any given promise is rejected then on the first rejection the returned promised will be rejected with the same reason
	 * @param {array|...*} [promise] can be a single array of promise/values as first parameter or a list of direct parameters promise/value
	 * @returns {promise} of a list of given promise resolution value
	 */
	defer.all = function(){ return multiPromiseResolver(arguments,false); };

	/**
	 * return an always fulfilled promise of array<promise> list of promises/values regardless they resolve fulfilled or rejected
	 * @param {array|...*} [promise] can be a single array of promise/values as first parameter or a list of direct parameters promise/value
	 *                     (non promise values will be promisified)
	 * @returns {promise} of the list of given promises
	 */
	defer.resolveAll = function(){ return multiPromiseResolver(arguments,true); };

	/**
	 * transform a typical nodejs async method awaiting a callback as last parameter, receiving error as first parameter to a function that
	 * will return a promise instead. the returned promise will resolve with normal callback value minus the first error parameter on
	 * fulfill and will be rejected with that error as reason in case of error.
	 * @param {object} [subject] optional subject of the method to encapsulate
	 * @param {function} fn the function to encapsulate if the normal callback should receive more than a single parameter (minus the error)
	 *                      the promise will resolve with the list or parameters as fulfillment value. If only one parameter is sent to the
	 *                      callback then it will be used as the resolution value.
	 * @returns {Function}
	 */
	defer.nodeCapsule = function(subject, fn){
		if ( !fn ) {
			fn = subject;
			subject = void(0);
		}
		return function(){
			var d = defer(), args = slice(arguments);
			args.push(function(err, res){
				err ? d.reject(err) : d.resolve(arguments.length > 2 ? slice(arguments, 1) : res);
			});
			try{
				fn.apply(subject, args);
			}catch(e){
				d.reject(e);
			}
			return d.promise;
		};
	};

	typeof window !== undefStr && (window.D = defer);
	typeof module !== undefStr && module.exports && (module.exports = defer);

})();

}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9kLmpzL2xpYi9ELmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIGF0dGVtcHQgb2YgYSBzaW1wbGUgZGVmZXIvcHJvbWlzZSBsaWJyYXJ5IGZvciBtb2JpbGUgZGV2ZWxvcG1lbnRcbiogQGF1dGhvciBKb25hdGhhbiBHb3R0aSA8IGpnb3R0aSBhdCBqZ290dGkgZG90IG5ldD5cbiogQHNpbmNlIDIwMTItMTBcbiogQHZlcnNpb24gMC42LjBcbiogQGNoYW5nZWxvZ1xuKiAgICAgICAgICAgLSAyMDEzLTEyLTA3IC0gbGFzdCBwcm9taXNlIDEuMSBzcGVjcyB0ZXN0IHBhc3NpbmdzICh0aHggdG8gd2l6YXJkd2VyZG5hKVxuICogICAgICAgICAgICAgICAgICAgICAgIC0gcmVkdWNlIHByb21pc2VzIGZvb3RwcmludCBieSB1bnNjb3BpbmcgbWV0aG9kcyB0aGF0IGNvdWxkIGJlXG4qICAgICAgICAgICAtIDIwMTMtMTAtMjMgLSBtYWtlIGl0IHdvcmtpZyBhY3Jvc3Mgbm9kZS13ZWJraXQgY29udGV4dHNcbiogICAgICAgICAgIC0gMjAxMy0wNy0wMyAtIGJ1ZyBjb3JyZWN0aW9uIGluIHByb21peGlmeSBtZXRob2QgKHRoeCB0byBhZHJpZW4gZ2licmF0IClcbiogICAgICAgICAgIC0gMjAxMy0wNi0yMiAtIGJ1ZyBjb3JyZWN0aW9uIGluIG5vZGVDYXBzdWxlIG1ldGhvZFxuKiAgICAgICAgICAgLSAyMDEzLTA2LTE3IC0gcmVtb3ZlIHVubmVjZXNzYXJ5IEFycmF5LmluZGV4T2YgbWV0aG9kIGRlcGVuZGVuY3lcbiogICAgICAgICAgIC0gMjAxMy0wNC0xOCAtIGFkZCB0cnkvY2F0Y2ggYmxvY2sgYXJvdW5kIG5vZGVDYXBzdWxlZCBtZXRob2RzXG4qICAgICAgICAgICAtIDIwMTMtMDQtMTMgLSBjaGVjayBwcm9taXNlcy9BKyBjb25mb3JtaXR5XG4qICAgICAgICAgICAgICAgICAgICAgICAgLSBtYWtlIHNvbWUgbWluaWNhdGlvbiBvcHRpbWlzYXRpb25zXG4qICAgICAgICAgICAtIDIwMTMtMDMtMjYgLSBhZGQgcmVzb2x2ZWQsIGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgbWV0aG9kc1xuKiAgICAgICAgICAgLSAyMDEzLTAzLTIxIC0gYnJvd3Nlci9ub2RlIGNvbXBhdGlibGVcbiogICAgICAgICAgICAgICAgICAgICAgICAtIG5ldyBtZXRob2Qgbm9kZUNhcHN1bGVcbiogICAgICAgICAgICAgICAgICAgICAgICAtIHNpbXBsZXIgcHJvbWl4aWZ5IHdpdGggZnVsbCBhcGkgc3VwcG9ydFxuKiAgICAgICAgICAgLSAyMDEzLTAxLTI1IC0gYWRkIHJldGhyb3cgbWV0aG9kXG4qICAgICAgICAgICAgICAgICAgICAgICAgLSBuZXh0VGljayBvcHRpbWlzYXRpb24gLT4gYWRkIHN1cHBvcnQgZm9yIHByb2Nlc3MubmV4dFRpY2sgKyBNZXNzYWdlQ2hhbm5lbCB3aGVyZSBhdmFpbGFibGVcbiogICAgICAgICAgIC0gMjAxMi0xMi0yOCAtIGFkZCBhcHBseSBtZXRob2QgdG8gcHJvbWlzZVxuKiAgICAgICAgICAgLSAyMDEyLTEyLTIwIC0gYWRkIGFsd2F5c0FzeW5jIHBhcmFtZXRlcnMgYW5kIHByb3BlcnR5IGZvciBkZWZhdWx0IHNldHRpbmdcbiovXG4oZnVuY3Rpb24odW5kZWYpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgbmV4dFRpY2tcblx0XHQsIGlzRnVuYyA9IGZ1bmN0aW9uKGYpeyByZXR1cm4gKCB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJyApOyB9XG5cdFx0LCBpc0FycmF5ID0gZnVuY3Rpb24oYSl7IHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShhKSA6IChhIGluc3RhbmNlb2YgQXJyYXkpOyB9XG5cdFx0LCBpc09iak9yRnVuYyA9IGZ1bmN0aW9uKG8peyByZXR1cm4gISEobyAmJiAodHlwZW9mIG8pLm1hdGNoKC9mdW5jdGlvbnxvYmplY3QvKSk7IH1cblx0XHQsIGlzTm90VmFsID0gZnVuY3Rpb24odil7IHJldHVybiAodiA9PT0gZmFsc2UgfHwgdiA9PT0gdW5kZWYgfHwgdiA9PT0gbnVsbCk7IH1cblx0XHQsIHNsaWNlID0gZnVuY3Rpb24oYSwgb2Zmc2V0KXsgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYSwgb2Zmc2V0KTsgfVxuXHRcdCwgdW5kZWZTdHIgPSAndW5kZWZpbmVkJ1xuXHRcdCwgdEVyciA9IHR5cGVvZiBUeXBlRXJyb3IgPT09IHVuZGVmU3RyID8gRXJyb3IgOiBUeXBlRXJyb3Jcblx0O1xuXHRpZiAoICh0eXBlb2YgcHJvY2VzcyAhPT0gdW5kZWZTdHIpICYmIHByb2Nlc3MubmV4dFRpY2sgKSB7XG5cdFx0bmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09IHVuZGVmU3RyICkge1xuXHRcdHZhciBudGlja0NoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSwgcXVldWUgPSBbXTtcblx0XHRudGlja0NoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oKXsgcXVldWUubGVuZ3RoICYmIChxdWV1ZS5zaGlmdCgpKSgpOyB9O1xuXHRcdG5leHRUaWNrID0gZnVuY3Rpb24oY2Ipe1xuXHRcdFx0cXVldWUucHVzaChjYik7XG5cdFx0XHRudGlja0NoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRuZXh0VGljayA9IGZ1bmN0aW9uKGNiKXsgc2V0VGltZW91dChjYiwgMCk7IH07XG5cdH1cblx0ZnVuY3Rpb24gcmV0aHJvdyhlKXsgbmV4dFRpY2soZnVuY3Rpb24oKXsgdGhyb3cgZTt9KTsgfVxuXG5cdC8qKlxuXHQgKiBAdHlwZWRlZiBkZWZlcnJlZFxuXHQgKiBAcHJvcGVydHkge3Byb21pc2V9IHByb21pc2Vcblx0ICogQG1ldGhvZCByZXNvbHZlXG5cdCAqIEBtZXRob2QgZnVsZmlsbFxuXHQgKiBAbWV0aG9kIHJlamVjdFxuXHQgKi9cblxuXHQvKipcblx0ICogQHR5cGVkZWYge2Z1bmN0aW9ufSBmdWxmaWxsZWRcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBwcm9taXNlIHJlc29sdmVkIHZhbHVlXG5cdCAqIEByZXR1cm5zIHsqfSBuZXh0IHByb21pc2UgcmVzb2x1dGlvbiB2YWx1ZVxuXHQgKi9cblxuXHQvKipcblx0ICogQHR5cGVkZWYge2Z1bmN0aW9ufSBmYWlsZWRcblx0ICogQHBhcmFtIHsqfSByZWFzb24gcHJvbWlzZSByZWplY3Rpb24gcmVhc29uXG5cdCAqIEByZXR1cm5zIHsqfSBuZXh0IHByb21pc2UgcmVzb2x1dGlvbiB2YWx1ZSBvciByZXRocm93IHRoZSByZWFzb25cblx0ICovXG5cblx0Ly8tLSBkZWZpbmluZyB1bmVuY2xvc2VkIHByb21pc2UgbWV0aG9kcyAtLS8vXG5cdC8qKlxuXHQgKiBzYW1lIGFzIHRoZW4gd2l0aG91dCBmYWlsZWQgY2FsbGJhY2tcblx0ICogQHBhcmFtIHtmdWxmaWxsZWR9IGZ1bGZpbGxlZCBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gYSBuZXcgcHJvbWlzZVxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvbWlzZV9zdWNjZXNzKGZ1bGZpbGxlZCl7IHJldHVybiB0aGlzLnRoZW4oZnVsZmlsbGVkLCB1bmRlZik7IH1cblxuXHQvKipcblx0ICogc2FtZSBhcyB0aGVuIHdpdGggb25seSBhIGZhaWxlZCBjYWxsYmFja1xuXHQgKiBAcGFyYW0ge2ZhaWxlZH0gZmFpbGVkIGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfSBhIG5ldyBwcm9taXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9taXNlX2Vycm9yKGZhaWxlZCl7IHJldHVybiB0aGlzLnRoZW4odW5kZWYsIGZhaWxlZCk7IH1cblxuXG5cdC8qKlxuXHQgKiBzYW1lIGFzIHRoZW4gYnV0IGZ1bGZpbGxlZCBjYWxsYmFjayB3aWxsIHJlY2VpdmUgbXVsdGlwbGUgcGFyYW1ldGVycyB3aGVuIHByb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYW4gQXJyYXlcblx0ICogQHBhcmFtIHtmdWxmaWxsZWR9IGZ1bGZpbGxlZCBjYWxsYmFja1xuXHQgKiBAcGFyYW0ge2ZhaWxlZH0gZmFpbGVkIGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfSBhIG5ldyBwcm9taXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9taXNlX2FwcGx5KGZ1bGZpbGxlZCwgZmFpbGVkKXtcblx0XHRyZXR1cm4gdGhpcy50aGVuKFxuXHRcdFx0ZnVuY3Rpb24oYSl7XG5cdFx0XHRcdHJldHVybiBpc0Z1bmMoZnVsZmlsbGVkKSA/IGZ1bGZpbGxlZC5hcHBseShudWxsLCBpc0FycmF5KGEpID8gYSA6IFthXSkgOiAoZGVmZXIub25seUZ1bmNzID8gYSA6IGZ1bGZpbGxlZCk7XG5cdFx0XHR9XG5cdFx0XHQsIGZhaWxlZCB8fCB1bmRlZlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogY2xlYW51cCBtZXRob2Qgd2hpY2ggd2lsbCBiZSBhbHdheXMgZXhlY3V0ZWQgcmVnYXJkbGVzcyBmdWxmaWxsbWVudCBvciByZWplY3Rpb25cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgYSBjYWxsYmFjayBjYWxsZWQgcmVnYXJkbGVzcyBvZiB0aGUgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIG9mIHRoZSBwcm9taXNlIHdoaWNoIHdpbGwgYmUgY2FsbGVkXG5cdCAqICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHByb21pc2UgaXMgbm90IHBlbmRpbmcgYW55bW9yZVxuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gdGhlIHNhbWUgcHJvbWlzZSB1bnRvdWNoZWRcblx0ICovXG5cdGZ1bmN0aW9uIHByb21pc2VfZW5zdXJlKGNiKXtcblx0XHRmdW5jdGlvbiBfY2IoKXsgY2IoKTsgfVxuXHRcdHRoaXMudGhlbihfY2IsIF9jYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogdGFrZSBhIHNpbmdsZSBjYWxsYmFjayB3aGljaCB3YWl0IGZvciBhbiBlcnJvciBhcyBmaXJzdCBwYXJhbWV0ZXIuIG90aGVyIHJlc29sdXRpb24gdmFsdWVzIGFyZSBwYXNzZWQgYXMgd2l0aCB0aGUgYXBwbHkvc3ByZWFkIG1ldGhvZFxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBhIGNhbGxiYWNrIGNhbGxlZCByZWdhcmRsZXNzIG9mIHRoZSBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gb2YgdGhlIHByb21pc2Ugd2hpY2ggd2lsbCBiZSBjYWxsZWRcblx0ICogICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgcHJvbWlzZSBpcyBub3QgcGVuZGluZyBhbnltb3JlIHdpdGggZXJyb3IgYXMgZmlyc3QgcGFyYW1ldGVyIGlmIGFueSBhcyBpbiBub2RlIHN0eWxlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLiBSZXN0IG9mIHBhcmFtZXRlcnMgd2lsbCBiZSBhcHBsaWVkIGFzIHdpdGggdGhlIGFwcGx5IG1ldGhvZC5cblx0ICogQHJldHVybnMge3Byb21pc2V9IGEgbmV3IHByb21pc2Vcblx0ICovXG5cdGZ1bmN0aW9uIHByb21pc2Vfbm9kaWZ5KGNiKXtcblx0XHRyZXR1cm4gdGhpcy50aGVuKFxuXHRcdFx0ZnVuY3Rpb24oYSl7XG5cdFx0XHRcdHJldHVybiBpc0Z1bmMoY2IpID8gY2IuYXBwbHkobnVsbCwgaXNBcnJheShhKSA/IGEuc3BsaWNlKDAsMCx1bmRlZmluZWQpICYmIGEgOiBbdW5kZWZpbmVkLGFdKSA6IChkZWZlci5vbmx5RnVuY3MgPyBhIDogY2IpO1xuXHRcdFx0fVxuXHRcdFx0LCBmdW5jdGlvbihlKXtcblx0XHRcdFx0cmV0dXJuIGNiKGUpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZhaWxlZF0gd2l0aG91dCBwYXJhbWV0ZXIgd2lsbCBvbmx5IHJldGhyb3cgcHJvbWlzZSByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgb2YgdGhlIHByb21pc2UgbGlicmFyeSBvbiBuZXh0IHRpY2tcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcGFzc2VkIGEgZmFpbGVkIG1ldGhvZCB0aGVuIHdpbGwgY2FsbCBmYWlsZWQgb24gcmVqZWN0aW9uIGFuZCB0aHJvdyB0aGUgZXJyb3IgYWdhaW4gaWYgZmFpbGVkIGRpZG4ndFxuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gYSBuZXcgcHJvbWlzZVxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvbWlzZV9yZXRocm93KGZhaWxlZCl7XG5cdFx0cmV0dXJuIHRoaXMudGhlbihcblx0XHRcdHVuZGVmXG5cdFx0XHQsIGZhaWxlZCA/IGZ1bmN0aW9uKGUpeyBmYWlsZWQoZSk7IHRocm93IGU7IH0gOiByZXRocm93XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQqIEBwYXJhbSB7Ym9vbGVhbn0gW2Fsd2F5c0FzeW5jXSBpZiBzZXQgZm9yY2UgdGhlIGFzeW5jIHJlc29sdXRpb24gZm9yIHRoaXMgcHJvbWlzZSBpbmRlcGVuZGFudGx5IG9mIHRoZSBELmFsd2F5c0FzeW5jIG9wdGlvblxuXHQqIEByZXR1cm5zIHtkZWZlcnJlZH0gZGVmZXJlZCBvYmplY3Qgd2l0aCBwcm9wZXJ0eSAncHJvbWlzZScgYW5kIG1ldGhvZHMgcmVqZWN0LGZ1bGZpbGwscmVzb2x2ZSAoZnVsZmlsbCBiZWluZyBhbiBhbGlhcyBmb3IgcmVzb2x2ZSlcblx0Ki9cblx0dmFyIGRlZmVyID0gZnVuY3Rpb24gKGFsd2F5c0FzeW5jKXtcblx0XHR2YXIgYWx3YXlzQXN5bmNGbiA9ICh1bmRlZiAhPT0gYWx3YXlzQXN5bmMgPyBhbHdheXNBc3luYyA6IGRlZmVyLmFsd2F5c0FzeW5jKSA/IG5leHRUaWNrIDogZnVuY3Rpb24oZm4pe2ZuKCk7fVxuXHRcdFx0LCBzdGF0dXMgPSAwIC8vIC0xIGZhaWxlZCB8IDEgZnVsZmlsbGVkXG5cdFx0XHQsIHBlbmRpbmdzID0gW11cblx0XHRcdCwgdmFsdWVcblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGVkZWYgcHJvbWlzZVxuXHRcdFx0ICovXG5cdFx0XHQsIF9wcm9taXNlICA9IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEBwYXJhbSB7ZnVsZmlsbGVkfGZ1bmN0aW9ufSBmdWxmaWxsZWQgY2FsbGJhY2tcblx0XHRcdFx0ICogQHBhcmFtIHtmYWlsZWR8ZnVuY3Rpb259IGZhaWxlZCBjYWxsYmFja1xuXHRcdFx0XHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gYSBuZXcgcHJvbWlzZVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oZnVsZmlsbGVkLCBmYWlsZWQpe1xuXHRcdFx0XHRcdHZhciBkID0gZGVmZXIoKTtcblx0XHRcdFx0XHRwZW5kaW5ncy5wdXNoKFtcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0XHRcdGlmKCBpc05vdFZhbChmdWxmaWxsZWQpKXtcblx0XHRcdFx0XHRcdFx0XHRcdGQucmVzb2x2ZSh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGQucmVzb2x2ZShpc0Z1bmMoZnVsZmlsbGVkKSA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiAoZGVmZXIub25seUZ1bmNzID8gdmFsdWUgOiBmdWxmaWxsZWQpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHRcdFx0XHRkLnJlamVjdChlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0LCBmdW5jdGlvbihlcnIpe1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzTm90VmFsKGZhaWxlZCkgfHwgKCghaXNGdW5jKGZhaWxlZCkpICYmIGRlZmVyLm9ubHlGdW5jcykgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZC5yZWplY3QoZXJyKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIGZhaWxlZCApIHtcblx0XHRcdFx0XHRcdFx0XHR0cnl7IGQucmVzb2x2ZShpc0Z1bmMoZmFpbGVkKSA/IGZhaWxlZChlcnIpIDogZmFpbGVkKTsgfWNhdGNoKGUpeyBkLnJlamVjdChlKTt9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHRzdGF0dXMgIT09IDAgJiYgYWx3YXlzQXN5bmNGbihleGVjQ2FsbGJhY2tzKTtcblx0XHRcdFx0XHRyZXR1cm4gZC5wcm9taXNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LCBzdWNjZXNzOiBwcm9taXNlX3N1Y2Nlc3NcblxuXHRcdFx0XHQsIGVycm9yOiBwcm9taXNlX2Vycm9yXG5cdFx0XHRcdCwgb3RoZXJ3aXNlOiBwcm9taXNlX2Vycm9yXG5cblx0XHRcdFx0LCBhcHBseTogcHJvbWlzZV9hcHBseVxuXHRcdFx0XHQsIHNwcmVhZDogcHJvbWlzZV9hcHBseVxuXG5cdFx0XHRcdCwgZW5zdXJlOiBwcm9taXNlX2Vuc3VyZVxuXG5cdFx0XHRcdCwgbm9kaWZ5OiBwcm9taXNlX25vZGlmeVxuXG5cdFx0XHRcdCwgcmV0aHJvdzogcHJvbWlzZV9yZXRocm93XG5cblx0XHRcdFx0LCBpc1BlbmRpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAhIShzdGF0dXMgPT09IDApOyB9XG5cblx0XHRcdFx0LCBnZXRTdGF0dXM6IGZ1bmN0aW9uKCl7IHJldHVybiBzdGF0dXM7IH1cblx0XHRcdH1cblx0XHQ7XG5cdFx0X3Byb21pc2UudG9Tb3VyY2UgPSBfcHJvbWlzZS50b1N0cmluZyA9IF9wcm9taXNlLnZhbHVlT2YgPSBmdW5jdGlvbigpe3JldHVybiB2YWx1ZSA9PT0gdW5kZWYgPyB0aGlzIDogdmFsdWU7IH07XG5cblxuXHRcdGZ1bmN0aW9uIGV4ZWNDYWxsYmFja3MoKXtcblx0XHRcdGlmICggc3RhdHVzID09PSAwICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2JzID0gcGVuZGluZ3MsIGkgPSAwLCBsID0gY2JzLmxlbmd0aCwgY2JJbmRleCA9IH5zdGF0dXMgPyAwIDogMSwgY2I7XG5cdFx0XHRwZW5kaW5ncyA9IFtdO1xuXHRcdFx0Zm9yKCA7IGkgPCBsOyBpKysgKXtcblx0XHRcdFx0KGNiID0gY2JzW2ldW2NiSW5kZXhdKSAmJiBjYih2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogZnVsZmlsbCBkZWZlcnJlZCB3aXRoIGdpdmVuIHZhbHVlXG5cdFx0ICogQHBhcmFtIHsqfSB2YWxcblx0XHQgKiBAcmV0dXJucyB7ZGVmZXJyZWR9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIF9yZXNvbHZlKHZhbCl7XG5cdFx0XHR2YXIgZG9uZSA9IGZhbHNlO1xuXHRcdFx0ZnVuY3Rpb24gb25jZShmKXtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHgpe1xuXHRcdFx0XHRcdGlmIChkb25lKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBmKHgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggc3RhdHVzICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB0aGVuID0gaXNPYmpPckZ1bmModmFsKSAmJiB2YWwudGhlbjtcblx0XHRcdFx0aWYgKCBpc0Z1bmModGhlbikgKSB7IC8vIG1hbmFnaW5nIGEgcHJvbWlzZVxuXHRcdFx0XHRcdGlmKCB2YWwgPT09IF9wcm9taXNlICl7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgdEVycihcIlByb21pc2UgY2FuJ3QgcmVzb2x2ZSBpdHNlbGZcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoZW4uY2FsbCh2YWwsIG9uY2UoX3Jlc29sdmUpLCBvbmNlKF9yZWplY3QpKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRvbmNlKF9yZWplY3QpKGUpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGFsd2F5c0FzeW5jRm4oZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFsdWUgPSB2YWw7XG5cdFx0XHRcdHN0YXR1cyA9IDE7XG5cdFx0XHRcdGV4ZWNDYWxsYmFja3MoKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogcmVqZWN0IGRlZmVycmVkIHdpdGggZ2l2ZW4gcmVhc29uXG5cdFx0ICogQHBhcmFtIHsqfSBFcnJcblx0XHQgKiBAcmV0dXJucyB7ZGVmZXJyZWR9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIF9yZWplY3QoRXJyKXtcblx0XHRcdHN0YXR1cyB8fCBhbHdheXNBc3luY0ZuKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHRyeXsgdGhyb3coRXJyKTsgfWNhdGNoKGUpeyB2YWx1ZSA9IGU7IH1cblx0XHRcdFx0c3RhdHVzID0gLTE7XG5cdFx0XHRcdGV4ZWNDYWxsYmFja3MoKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiAvKipAdHlwZSBkZWZlcnJlZCAqLyB7XG5cdFx0XHRwcm9taXNlOl9wcm9taXNlXG5cdFx0XHQscmVzb2x2ZTpfcmVzb2x2ZVxuXHRcdFx0LGZ1bGZpbGw6X3Jlc29sdmUgLy8gYWxpYXNcblx0XHRcdCxyZWplY3Q6X3JlamVjdFxuXHRcdH07XG5cdH07XG5cblx0ZGVmZXIuZGVmZXJyZWQgPSBkZWZlci5kZWZlciA9IGRlZmVyO1xuXHRkZWZlci5uZXh0VGljayA9IG5leHRUaWNrO1xuXHRkZWZlci5hbHdheXNBc3luYyA9IHRydWU7IC8vIHNldHRpbmcgdGhpcyB3aWxsIGNoYW5nZSBkZWZhdWx0IGJlaGF2aW91ci4gdXNlIGl0IG9ubHkgaWYgbmVjZXNzYXJ5IGFzIGFzeW5jaHJvbmljaXR5IHdpbGwgZm9yY2Ugc29tZSBkZWxheSBiZXR3ZWVuIHlvdXIgcHJvbWlzZSByZXNvbHV0aW9ucyBhbmQgaXMgbm90IGFsd2F5cyB3aGF0IHlvdSB3YW50LlxuXHQvKipcblx0KiBzZXR0aW5nIG9ubHlGdW5jcyB0byBmYWxzZSB3aWxsIGJyZWFrIHByb21pc2VzL0ErIGNvbmZvcm1pdHkgYnkgYWxsb3dpbmcgeW91IHRvIHBhc3Mgbm9uIHVuZGVmaW5lZC9udWxsIHZhbHVlcyBpbnN0ZWFkIG9mIGNhbGxiYWNrc1xuXHQqIGluc3RlYWQgb2YganVzdCBpZ25vcmluZyBhbnkgbm9uIGZ1bmN0aW9uIHBhcmFtZXRlcnMgdG8gdGhlbixzdWNjZXNzLGVycm9yLi4uIGl0IHdpbGwgYWNjZXB0IG5vbiBudWxsfHVuZGVmaW5lZCB2YWx1ZXMuXG5cdCogdGhpcyB3aWxsIGFsbG93IHlvdSBzaG9ydGN1dHMgbGlrZSBwcm9taXNlLnRoZW4oJ3ZhbCcsJ2hhbmRsZWQgZXJyb3InJylcblx0KiB0byBiZSBlcXVpdmFsZW50IG9mIHByb21pc2UudGhlbihmdW5jdGlvbigpeyByZXR1cm4gJ3ZhbCc7fSxmdW5jdGlvbigpeyByZXR1cm4gJ2hhbmRsZWQgZXJyb3InfSlcblx0Ki9cblx0ZGVmZXIub25seUZ1bmNzID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcmV0dXJuIGEgZnVsZmlsbGVkIHByb21pc2Ugb2YgZ2l2ZW4gdmFsdWUgKGFsd2F5cyBhc3luYyByZXNvbHV0aW9uKVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfVxuXHQgKi9cblx0ZGVmZXIucmVzb2x2ZWQgPSBkZWZlci5mdWxmaWxsZWQgPSBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiBkZWZlcih0cnVlKS5yZXNvbHZlKHZhbHVlKS5wcm9taXNlOyB9O1xuXG5cdC8qKlxuXHQgKiByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIHdpdGggZ2l2ZW4gcmVhc29uIG9mIHJlamVjdGlvbiAoYWx3YXlzIGFzeW5jIHJlamVjdGlvbilcblx0ICogQHBhcmFtIHsqfSByZWFzb25cblx0ICogQHJldHVybnMge3Byb21pc2V9XG5cdCAqL1xuXHRkZWZlci5yZWplY3RlZCA9IGZ1bmN0aW9uKHJlYXNvbil7IHJldHVybiBkZWZlcih0cnVlKS5yZWplY3QocmVhc29uKS5wcm9taXNlOyB9O1xuXG5cdC8qKlxuXHQgKiByZXR1cm4gYSBwcm9taXNlIHdpdGggbm8gcmVzb2x1dGlvbiB2YWx1ZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGluIHRpbWUgbXMgKHVzaW5nIHNldFRpbWVvdXQpXG5cdCAqIEBwYXJhbSB7aW50fSBbdGltZV0gaW4gbXMgZGVmYXVsdCB0byAwXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfVxuXHQgKi9cblx0ZGVmZXIud2FpdCA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHZhciBkID0gZGVmZXIoKTtcblx0XHRzZXRUaW1lb3V0KGQucmVzb2x2ZSwgdGltZSB8fCAwKTtcblx0XHRyZXR1cm4gZC5wcm9taXNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiByZXR1cm4gYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIGZ1bmN0aW9uIGNhbGwgd2hpY2ggd2lsbCBiZSBmdWxmaWxsZWQgaW4gZGVsYXkgbXMgb3IgcmVqZWN0ZWQgaWYgZ2l2ZW4gZm4gdGhyb3cgYW4gZXJyb3Jcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cblx0ICogQHBhcmFtIHtpbnR9IFtkZWxheV0gaW4gbXMgZGVmYXVsdCB0byAwXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfVxuXHQgKi9cblx0ZGVmZXIuZGVsYXkgPSBmdW5jdGlvbihmbiwgZGVsYXkpe1xuXHRcdHZhciBkID0gZGVmZXIoKTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHRyeXsgZC5yZXNvbHZlKGZuLmFwcGx5KG51bGwpKTsgfWNhdGNoKGUpeyBkLnJlamVjdChlKTsgfSB9LCBkZWxheSB8fCAwKTtcblx0XHRyZXR1cm4gZC5wcm9taXNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBpZiBnaXZlbiB2YWx1ZSBpcyBub3QgYSBwcm9taXNlIHJldHVybiBhIGZ1bGZpbGxlZCBwcm9taXNlIHJlc29sdmVkIHRvIGdpdmVuIHZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0gcHJvbWlzZSBhIHZhbHVlIG9yIGEgcHJvbWlzZVxuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX1cblx0ICovXG5cdGRlZmVyLnByb21pc2lmeSA9IGZ1bmN0aW9uKHByb21pc2Upe1xuXHRcdGlmICggcHJvbWlzZSAmJiBpc0Z1bmMocHJvbWlzZS50aGVuKSApIHsgcmV0dXJuIHByb21pc2U7fVxuXHRcdHJldHVybiBkZWZlci5yZXNvbHZlZChwcm9taXNlKTtcblx0fTtcblxuXHRmdW5jdGlvbiBtdWx0aVByb21pc2VSZXNvbHZlcihjYWxsZXJBcmd1bWVudHMsIHJldHVyblByb21pc2VzKXtcblx0XHR2YXIgcHJvbWlzZXMgPSBzbGljZShjYWxsZXJBcmd1bWVudHMpO1xuXHRcdGlmICggcHJvbWlzZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkocHJvbWlzZXNbMF0pICkge1xuXHRcdFx0aWYoISBwcm9taXNlc1swXS5sZW5ndGggKXtcblx0XHRcdFx0cmV0dXJuIGRlZmVyLmZ1bGZpbGxlZChbXSk7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlcyA9IHByb21pc2VzWzBdO1xuXHRcdH1cblx0XHR2YXIgYXJncyA9IFtdXG5cdFx0XHQsIGQgPSBkZWZlcigpXG5cdFx0XHQsIGMgPSBwcm9taXNlcy5sZW5ndGhcblx0XHQ7XG5cdFx0aWYgKCAhYyApIHtcblx0XHRcdGQucmVzb2x2ZShhcmdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHJlc29sdmVyID0gZnVuY3Rpb24oaSl7XG5cdFx0XHRcdHByb21pc2VzW2ldID0gZGVmZXIucHJvbWlzaWZ5KHByb21pc2VzW2ldKTtcblx0XHRcdFx0cHJvbWlzZXNbaV0udGhlbihcblx0XHRcdFx0XHRmdW5jdGlvbih2KXtcblx0XHRcdFx0XHRcdGlmICghIChpIGluIGFyZ3MpICkgeyAvL0B0b2RvIGNoZWNrIHRoaXMgaXMgc3RpbGwgcmVxdWlyZWQgYXMgcHJvbWlzZXMgY2FuJ3QgYmUgcmVzb2x2ZSBtb3JlIHRoYW4gb25jZVxuXHRcdFx0XHRcdFx0XHRhcmdzW2ldID0gcmV0dXJuUHJvbWlzZXMgPyBwcm9taXNlc1tpXSA6IHY7XG5cdFx0XHRcdFx0XHRcdCgtLWMpIHx8IGQucmVzb2x2ZShhcmdzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0LCBmdW5jdGlvbihlKXtcblx0XHRcdFx0XHRcdGlmKCEgKGkgaW4gYXJncykgKXtcblx0XHRcdFx0XHRcdFx0aWYoICEgcmV0dXJuUHJvbWlzZXMgKXtcblx0XHRcdFx0XHRcdFx0XHRkLnJlamVjdChlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRhcmdzW2ldID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdFx0XHRcdFx0KC0tYykgfHwgZC5yZXNvbHZlKGFyZ3MpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fTtcblx0XHRcdGZvciggdmFyIGkgPSAwLCBsID0gYzsgaSA8IGw7IGkrKyApe1xuXHRcdFx0XHRyZXNvbHZlcihpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGQucHJvbWlzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiByZXR1cm4gYSBwcm9taXNlIGZvciBhbGwgZ2l2ZW4gcHJvbWlzZXMgLyB2YWx1ZXMuXG5cdCAqIHRoZSByZXR1cm5lZCBwcm9taXNlcyB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIGEgbGlzdCBvZiByZXNvbHZlZCB2YWx1ZS5cblx0ICogaWYgYW55IGdpdmVuIHByb21pc2UgaXMgcmVqZWN0ZWQgdGhlbiBvbiB0aGUgZmlyc3QgcmVqZWN0aW9uIHRoZSByZXR1cm5lZCBwcm9taXNlZCB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWUgcmVhc29uXG5cdCAqIEBwYXJhbSB7YXJyYXl8Li4uKn0gW3Byb21pc2VdIGNhbiBiZSBhIHNpbmdsZSBhcnJheSBvZiBwcm9taXNlL3ZhbHVlcyBhcyBmaXJzdCBwYXJhbWV0ZXIgb3IgYSBsaXN0IG9mIGRpcmVjdCBwYXJhbWV0ZXJzIHByb21pc2UvdmFsdWVcblx0ICogQHJldHVybnMge3Byb21pc2V9IG9mIGEgbGlzdCBvZiBnaXZlbiBwcm9taXNlIHJlc29sdXRpb24gdmFsdWVcblx0ICovXG5cdGRlZmVyLmFsbCA9IGZ1bmN0aW9uKCl7IHJldHVybiBtdWx0aVByb21pc2VSZXNvbHZlcihhcmd1bWVudHMsZmFsc2UpOyB9O1xuXG5cdC8qKlxuXHQgKiByZXR1cm4gYW4gYWx3YXlzIGZ1bGZpbGxlZCBwcm9taXNlIG9mIGFycmF5PHByb21pc2U+IGxpc3Qgb2YgcHJvbWlzZXMvdmFsdWVzIHJlZ2FyZGxlc3MgdGhleSByZXNvbHZlIGZ1bGZpbGxlZCBvciByZWplY3RlZFxuXHQgKiBAcGFyYW0ge2FycmF5fC4uLip9IFtwcm9taXNlXSBjYW4gYmUgYSBzaW5nbGUgYXJyYXkgb2YgcHJvbWlzZS92YWx1ZXMgYXMgZmlyc3QgcGFyYW1ldGVyIG9yIGEgbGlzdCBvZiBkaXJlY3QgcGFyYW1ldGVycyBwcm9taXNlL3ZhbHVlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgKG5vbiBwcm9taXNlIHZhbHVlcyB3aWxsIGJlIHByb21pc2lmaWVkKVxuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gb2YgdGhlIGxpc3Qgb2YgZ2l2ZW4gcHJvbWlzZXNcblx0ICovXG5cdGRlZmVyLnJlc29sdmVBbGwgPSBmdW5jdGlvbigpeyByZXR1cm4gbXVsdGlQcm9taXNlUmVzb2x2ZXIoYXJndW1lbnRzLHRydWUpOyB9O1xuXG5cdC8qKlxuXHQgKiB0cmFuc2Zvcm0gYSB0eXBpY2FsIG5vZGVqcyBhc3luYyBtZXRob2QgYXdhaXRpbmcgYSBjYWxsYmFjayBhcyBsYXN0IHBhcmFtZXRlciwgcmVjZWl2aW5nIGVycm9yIGFzIGZpcnN0IHBhcmFtZXRlciB0byBhIGZ1bmN0aW9uIHRoYXRcblx0ICogd2lsbCByZXR1cm4gYSBwcm9taXNlIGluc3RlYWQuIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIG5vcm1hbCBjYWxsYmFjayB2YWx1ZSBtaW51cyB0aGUgZmlyc3QgZXJyb3IgcGFyYW1ldGVyIG9uXG5cdCAqIGZ1bGZpbGwgYW5kIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGF0IGVycm9yIGFzIHJlYXNvbiBpbiBjYXNlIG9mIGVycm9yLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3N1YmplY3RdIG9wdGlvbmFsIHN1YmplY3Qgb2YgdGhlIG1ldGhvZCB0byBlbmNhcHN1bGF0ZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiB0aGUgZnVuY3Rpb24gdG8gZW5jYXBzdWxhdGUgaWYgdGhlIG5vcm1hbCBjYWxsYmFjayBzaG91bGQgcmVjZWl2ZSBtb3JlIHRoYW4gYSBzaW5nbGUgcGFyYW1ldGVyIChtaW51cyB0aGUgZXJyb3IpXG5cdCAqICAgICAgICAgICAgICAgICAgICAgIHRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBsaXN0IG9yIHBhcmFtZXRlcnMgYXMgZnVsZmlsbG1lbnQgdmFsdWUuIElmIG9ubHkgb25lIHBhcmFtZXRlciBpcyBzZW50IHRvIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayB0aGVuIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgcmVzb2x1dGlvbiB2YWx1ZS5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxuXHQgKi9cblx0ZGVmZXIubm9kZUNhcHN1bGUgPSBmdW5jdGlvbihzdWJqZWN0LCBmbil7XG5cdFx0aWYgKCAhZm4gKSB7XG5cdFx0XHRmbiA9IHN1YmplY3Q7XG5cdFx0XHRzdWJqZWN0ID0gdm9pZCgwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgZCA9IGRlZmVyKCksIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uKGVyciwgcmVzKXtcblx0XHRcdFx0ZXJyID8gZC5yZWplY3QoZXJyKSA6IGQucmVzb2x2ZShhcmd1bWVudHMubGVuZ3RoID4gMiA/IHNsaWNlKGFyZ3VtZW50cywgMSkgOiByZXMpO1xuXHRcdFx0fSk7XG5cdFx0XHR0cnl7XG5cdFx0XHRcdGZuLmFwcGx5KHN1YmplY3QsIGFyZ3MpO1xuXHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRkLnJlamVjdChlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkLnByb21pc2U7XG5cdFx0fTtcblx0fTtcblxuXHR0eXBlb2Ygd2luZG93ICE9PSB1bmRlZlN0ciAmJiAod2luZG93LkQgPSBkZWZlcik7XG5cdHR5cGVvZiBtb2R1bGUgIT09IHVuZGVmU3RyICYmIG1vZHVsZS5leHBvcnRzICYmIChtb2R1bGUuZXhwb3J0cyA9IGRlZmVyKTtcblxufSkoKTtcbiJdfQ==
},{"_process":18}],20:[function(require,module,exports){
module.exports={
    "/r/user/login": {
        "method": "POST",
        "format": "json"
    },

    "/r/user/logout": {
        "method": "POST",
        "format": "json"
    },

    "/r/user/about": {
        "method": "POST",
        "format": "json"
    },

    "/r/user/autosave": {
        "method": "POST",
        "format": "json"
    },

    "/r/user/release": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/create": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/pool": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/recycle": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/list": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/ping": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/about": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/about/update": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/save": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/saveas": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/close": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/grant": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/import": {
        "method": "POST",
        "format": "json",
        "upload": true
    },

    "/r/project/export": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/delete": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/execute/code": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/execute/script": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/execute/interrupt": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/execute/console": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/execute/history": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/execute/flush": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/execute/result/list": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/execute/result/download": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/execute/result/delete": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/workspace/list": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/workspace/get": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/workspace/upload": {
        "method": "POST",
        "format": "json",
        "upload": true
    },

    "/r/project/workspace/transfer": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/workspace/push": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/workspace/save": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/workspace/store": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/workspace/load": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/workspace/delete": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/directory/list": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/directory/upload": {
        "method": "POST",
        "format": "json",
        "upload": true
    },

    "/r/project/directory/transfer": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/directory/write": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/directory/update": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/directory/store": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/directory/load": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/directory/download": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/directory/delete": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/package/list": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/package/attach": {
        "method": "POST",
        "format": "json"
    },

    "/r/project/package/detach": {
        "method": "POST",
        "format": "json"
    },

    "/r/job/list": {
        "method": "POST",
        "format": "json"
    },

    "/r/job/submit": {
        "method": "POST",
        "format": "json"
    },

    "/r/job/schedule": {
        "method": "POST",
        "format": "json"
    },

    "/r/job/query": {
        "method": "POST",
        "format": "json"
    },

    "/r/job/cancel": {
        "method": "POST",
        "format": "json"
    },

    "/r/job/delete": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/directory/list": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/directory/create": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/directory/rename": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/directory/copy": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/directory/move": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/directory/update": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/script/list": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/script/execute": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/script/render": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/script/interrupt": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/shell/execute": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/directory/archive": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/directory/upload": {
        "method": "POST",
        "format": "json",
        "upload": true
    },

    "/r/repository/directory/download": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/directory/delete": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/list": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/fetch": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/fetch": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/upload": {
        "method": "POST",
        "format": "json",
        "upload": true
    },

    "/r/repository/file/transfer": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/write": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/update": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/diff": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/revert": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/grant": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/download": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/delete": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/copy": {
        "method": "POST",
        "format": "json"
    },

    "/r/repository/file/move": {
        "method": "POST",
        "format": "json"
    },

    "/r/server/info": {
        "method": "GET",
        "format": "json"
    }
}

},{}],21:[function(require,module,exports){
(function (process){
/*!
 * Copyright (C) 2010-2015 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var win         = (typeof window !== 'undefined'),   
    request     = require('superagent'),
    D           = require('d.js'),
    fs          = require('fs'),
    apis        = require('./apis.json'), 
    EventStream = require('./lib/es'),
    utils       = require('./lib/utils'),
    Lang        = require('./lib/lang'),   
    Logger      = require('./lib/logger'),   
    Queue       = require('./lib/queue'),
    Emitter     = require('./lib/emitter'),
    encoder     = require('./lib/encoder'),
    Base        = require('./lib/selfish').Base,
    RInput      = require('./lib/rinput'),    
    RInputs     = require('./lib/rinputs'),
    merge       = utils.merge;

/*
 * Turn global logging off by default
 */
Logger.setLevel(Logger.OFF);

/*
 * Global options that persist through all DeployR requests.
 */
var globalOptions = { 
  cors: false,
  logging: false,
  sticky: false,
  cookies: null,
  host: '',
  allowSelfSignedSSLCert: false,
  maxRequests: null, // no socket pooling in http.Agent
  events:{},
  set: function(prop, value) { 
    if (prop !== 'set') { 
      if (prop === 'host' && value) {         
         // Be more forgiving on the entered DeployR 'endpoint':
         //   - http(s)://dhost:port
         //   - http(s)://dhost:port/deployr
         //   - dhost:port
         //   - dhost:port/deployr         
         value = value.replace(/\/*$|\/*deployr\/*$/, '');
         value = (new RegExp('^(http|https)://', 'i')).test(value) ? value : 
            'http://' + value;
      }

      this[prop] = value; 
    } 
  }
};

/*
 * The top-level DeployR API response entities.
 */
var TOPLEVEL_ENTITIES = [
  'user', 
  'project', 
  'workspace', 
  'execution', 
  'directory', 
  'repository', 
  'packages' 
];

/*
 * Notify global IO error events accessible by all subscribers across requests.
 */
function raiseGlobalErrors(api, res) {
  var code    = res.deployr ? res.deployr.response.errorCode : res.status,
      context = this;

  // -- global events if provided --
  if (globalOptions.events) {
    if (!res.deployr) {
      res = res.text;
    }

    context = globalOptions.events.ctx || context;

    // -- general global failure --
    if (globalOptions.events.error) {
      globalOptions.events.error.apply(context, [api, res]);
    }

    // -- HTTP or DeployR global errors --    
    if (globalOptions.events[code]) {
      globalOptions.events[code].apply(context, [api, res]);
    }
  }
}

/**
 * The `DeployR` request class is a utility that brokers HTTP requests through a 
 * simplified fluid interface to DeployR.
 *
 * @module deployr
 * @for deployr
 */
var DeployR = Base.extend(Emitter, RInputs, {

  /**
   * The `DeployR` Request class is a utility that brokers HTTP requests through 
   * a simplified fluid interface to DeployR.
   * 
   * @class 
   * @constructor
   * @param {String} api The DeployR API
   * @param {Object} link The object literal containing the previous request.
   * @api private
   */
  initialize: function initialize(api, link) {
     Emitter.initialize.call(this, {});
  
     var opts = globalOptions;

     if (!apis[api]) { throw new Error('Invalid API "' + api + '"'); }
    
     this.api        = merge({ 'call': api }, apis[api]);    
     this.link       = link || {};
     this.q          = this.link.queue || new Queue();
     this.deferred   = this.link.deferred || D();
     this.cookies    = this.link.cookies;
     this.logger     = Logger.get(api, Logger.OFF); // transaction-level logging
     this.params     = {};
     this.inputs     = []; // rinputs list 
     this.outputs    = []; // routput object list
     this.rstream    = false;
     this.delayed    = false;
     this.globalEvts = true; // suppress|raise global events fot this `io`     
     this.file       = null; 
     this.filter     = null; 

     // preset deployr's assigned response format for `this` api
     this.data({ format: this.api.format });

     // wrap superagent for the heavy lifting     
     this.req = 
        request[this.api.method.toLowerCase()](opts.host + '/deployr' + api);
     this.req.timeout(20 * 60 * 1000); // default timeout --> 20 minutes

     // All CORS deployr calls require sticky sessions
     if (win && globalOptions.cors) { this.req.withCredentials(); }

     // Node.js - access an SSL endpoint with self signed certs for testing|dev
     if (!win && globalOptions.allowSelfSignedSSLCert) {
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';        
     }
  },

  /**
   * Binds the scope context for the configured `.end()` and `.error()` event    
   * handler callbacks on this request.
   *
   * @method ctx
   * @param {Object} context The `this` object for the configured `.end()` and
   * `.error()` event handlers on this request.
   * @api public   
   */ 
  ctx: function (context) {
    this.scope = context || this;

    return this;
  },

  /**
   * Suppress or raise global events for this `io` request.
   *
   * @method global
   * @param {Boolean} raise `true` to raise global events, `false` to supress 
   * event firing globally.
   * @return {DeployR} for chaining.
   * @api public
   */  
  global: function(raise) {
    this.globalEvts = Lang.isBoolean(raise) ? raise : this.globalEvts;

    return this;
  },  

  /**
   * Retrieve details about user.
   *   
   * @method about
   * @return {Object} details about user otherwies `null`.
   * @api public   
   */
  about: function() {
    var response = this.req.res;

    return this.api['call'] === '/r/user/login' && response ? 
           response.body.get('user') : null;
  },  

  /**
   * Shares the cookies from a diffrent `.io()` agent to preserve session state
   * across `this` request and all requests chained to it.
   *
   * @method share
   * @return {DeployR} for chaining.
   * @api public   
   */  
  share: function (cookies) {
    if (globalOptions.sticky) {
      if (globalOptions.cookies) {
        this.cookies = globalOptions.cookies.slice(0); 
      } else {
        if (cookies) { 
          this.cookies = cookies.slice(0); 
          globalOptions.set('cookies', this.cookies);
        }
      }
    } else {
      this.cookies = (cookies ? cookies.slice(0) : this.cookies);
    }

    return this;
  },

  /**
   * Returns the HTTP cookie previously sent by the server with Set-Cookie.
   * This value can be passed to `.share(ruser.getCookies())` of a diffrent
   * `.io()` agent to preserve session state across requests.
   *
   * @method getCookies
   * @return {Array} The HTTP cookie previously sent by the server with 
   * Set-Cookie.
   * @api public   
   */  
  getCookies: function () {
    return this.cookies;
  }, 

  delay: function (ms) {
    // TODO: support delayed requests based on ms for now this is just a pause.
    this.delayed = !isNaN(parseFloat(ms)) && isFinite(ms) ? ms : true;

    return this;
  },   

  /**
   * Unwind the queue chain clearing requests that might have delays attached.
   *
   * @method drain
   * @return {Promise} A promise wrapping the resolution of either "resolve" or
   * "reject" callback.
   * @api public   
   */
  drain: function () {
    this.delayed = false;
    this.q.flush(); 

    return this.deferred.promise;
  },   

  /**
   * The `.promise()` method returns a dynamically generated Promise that is 
   * resolved once all DeployR `.io()` requests have ended.
   *   
   * @method promise
   * @return {Promise} A promise wrapping the resolution of either "resolve" or
   * "reject" callback.
   * @api public
   */     
  promise: function () {
    this.end();

    return this.deferred.promise;
  },

  /**
   * Abort the DeployR request.
   *
   * @method abort  
   * @return {DeployR} for chaining.
   * @api public
   */  
  abort: function () {
    this.req.abort();
    this.emit('abort');
    this.deferred.reject(this._handleError({ 
        status: 'abort',
        text: 'DeployR request aborted.'
    }));

    return this;
  },

 /**
  * Set timeout to `ms`.
  *
  * @method timeout  
  * @param {Number} ms
  * @return {DeployR} for chaining
  * @api public
  */  
  timeout: function (ms) {
    this.req.timeout(ms);

    return this;
  },

 /**
  * Turn logging on for the specific transaction.
  *
  * @method log
  * @return {DeployR} for chaining
  * @api public
  */ 
  log: function (level) {
    this.logger.setLevel(level || Logger.DEBUG);

    return this;
  },

  /**
   * Filters successful responses to contain only a top-level DeployR API 
   * response entities:
   * - 'user'
   * - 'project'
   * - 'workspace' 
   * - 'execution' 
   * - 'directory' 
   * - 'repository'
   * - 'packages' 
   *   
   * @method entity
   * @return {DeployR} for chaining
   * @api public
   */
  entity: function (entity) {
    this.filter = utils.inArray(TOPLEVEL_ENTITIES, entity);

    return this;
  },

  /**
   * Defines the request data being sent to a DeployR API. 
   *
   * @method data
   * @param {Object} data The object literal configuration hash. 
   * @return {DeployR} for chaining
   * @api public
   */
  data: function (data) {
    data = data || {};    

    // remove any inlined rinput(s) and attach them to the rinput(s) property
    if (data.rinput || data.rinputs) {
      this.rinput(data.rinput);
      this.rinputs(data.rinputs);
    } 

    // remove any `reserved` values that could have been passed by mistake
    var BLACKLIST = ['rinput', 'rinputs', '__cookies__'];
    BLACKLIST.forEach(function(param) { delete data[param]; });  

    this.params = merge(this.params, data);

    return this;
  },

  /**
   * Attaches a file to be uploaded. 
   *
   * @method attach
   * @param {File|Blob|path} file The file to be attached for an upload. For 
   * Browser environments the HTML5 File|Blob is used. For the Node.js 
   * environment, a file path is accepted.
   * @param {String} filename (optional) the name of the file to be uploaded. 
   * This name does not have to match the actual source filename.
   * @return {DeployR} for chaining
   * @api public
   */
  attach: function (file, filename) {
    if (this.api.upload) {
      this.file = file;

      // optional filename here for convenience
      if (filename) { this.data( { filename: filename } ); }
    }

    return this;
  },

  /**
   * Supported only in Node.js, this method works in conjunction with the 
   * attach method to indicate that the file should be read in as a readable 
   * stream during a file upload.
   *
   * @method stream
   * @param {Object} options (optional) the Readable Stream options hash.
   *  ```
   *    { flags: 'r',
   *      encoding: null,
   *      fd: null,
   *      mode: 0666,
   *      autoClose: true
   *    }
   * ```
   * @return {DeployR} for chaining
   * @api public
   */
  stream: function () {
    this.rstream = (!win && this.api.upload); //nodejs only

    return this;
  },
  
  /**
   * Acts as a finally statement allowing you to execute "cleanup" type tasks 
   * in a request chain. It arranges for cleanup to be called, with no 
   * arguments, when the DeployR request chain is either completely fulfilled 
   * or rejected.
   *
   * @method ensure
   * @param {Function}  the callback function.
   * @return {DeployR} for chaining
   * @api public
   */  
  ensure: function (fn) {
    this.deferred.promise.ensure(fn);

    return this.deferred.promise;
  },
      
  /**
   * The general failure callback. If called, all DeployR errors for this 
   * transaction will be returned here when raised.
   *
   * @method error
   * @param {Function}  the callback function.
   * @return {DeployR} for chaining
   * @api public
   */
  error: function (fn) {
    this.on('error', fn);

    return this;
  },

  /**
   * Stream the DeployR response into the pipe. It is important to note that if 
   * the `.pipe()` method is never called the request will not be sent.
   *
   * The `.pipe()` method should be be used as an alternative to `.end()` and 
   * never along side of it. `.pipe()` and `.end()` are an either-or.
   *
   * @method pipe
   * @param {Stream} stream A destination Stream.
   * @return {Stream} The passed in destination stream to be used for additional 
   * piping.
   * @api public
   */
  pipe: function (dest) {
    var q   = this.q,
        api = this.api;        

    q.add(function(responseChain, error, prevArgs) {    
      // brake the call chain on error      
      if (error) {        
        this.deferred.reject(error);      
        q.flush(responseChain, error, prevArgs); // drain the queue
        this._clear();
        return;
      }
      
      this._prepRequest(responseChain, prevArgs);

      Logger.info('pipe()', api, this.req);
      this.logger.info('pipe()', api, this.req);   

      var stream = this.req.pipe(dest);
      q.yield(true);
      stream.on('error', function () { });    
      stream.on('end', function() { });     
      stream.on('data', function() { });      
    }, this);
  
    if (q.size() <= 1) { q.flush(); }

    return dest;
  },

  /**
   * Indicates that the request is ready to be sent to DeployR. It is important 
   * to note that if the `.end()` method is never called the request will not be
   * sent.
   *
   * @method end
   * @param {Function}  the callback function.
   * @return {DeployR} for chaining.
   * @api public
   */ 
  end: function (fn) {
    var self   = this,
        q      = this.q,
        api    = this.api,
        args   = null,
        entity = this.filter;

    q.add(function(responseChain, error, prevArgs) {
      // break the call chain on error      
      if (error) {        
        this.deferred.reject(error);        
        q.flush(responseChain, error, prevArgs); // drain the queue
        this._clear();
        return;
      }
      
      this._prepRequest(responseChain, prevArgs);

      Logger.info('io()', api, this.req);
      this.logger.info('io()', api, this.req);    

      this.req.end(function(res) {
        self.share(self.cookies || res.headers['set-cookie']);         

        // -- log cookies across requests --
        if (self.cookies) {
          Logger.info('cookies', api, self.cookies); 
          self.logger.info('cookies', api, self.cookies); 
        }

        error = self._handleError(res);
        var dres = (res.body && res.body.deployr ? res.body : res);             
      
        self.inputs = [];
        self.outputs = [];

        if (!error) {
           // -- Log global + transaction log --
           Logger.info('end()', api, dres, res);
           self.logger.info('end()', api, dres, res);

           // -- walk response for top-level entity response assignment --        
           if (entity) { dres = dres.deployr.response[entity] || dres; }

           dres.get = function(key) { 
              return utils.get(dres.deployr.response, key); 
           };

           dres.workspace = function(name) { 
              return utils.workspace(dres.deployr.response, name); 
           };

           // -- callback --
           if (fn) { args = fn.apply(self.scope, [dres, responseChain]);}

           // -- notify that the queue has been drained... --
           if (q.size() === 0) { 
             self._clear();
             self.deferred.resolve(responseChain || dres);
           }          

           // -- include cookies in next request in the queue --
           args = merge(args, { __cookies__: self.cookies });          
        }        

        q.yield(false);
        q.flush(dres, error, args); // pass result|error|args to next 
      });

      q.yield(true);
    }, this, this.delayed);
  
    if (!this.delayed && q.size() <= 1) { q.flush(); }

    return this;
  }, 

  /** 
   * Add an additional IO request to the exsisting sequential request chain.
   *
   * @method io
   * @param {String} api One of the supported DeployR APIs.
   * @return {DeployR} for chaining.
   * @api public
   */   
  io: function (api) {    
    return DeployR.new(api, { 
      cookies: this.cookies, 
      queue: this.q, 
      deferred: this.deferred
    });
  },

  /** 
   * Convenience function for adding an additional script execution to the 
   * exsisting sequential request chain.
   *
   * @method script
   * @param {Arguments} Arguments to define the fully qualified script for 
   * execution.
   * @return {DeployR} for chaining.   
   * @api public
   */
  script: function() {
     var args = utils.signature(arguments),
         opts = args.opts,
         api  = args.api,
         link = { 
          cookies: this.cookies, 
          queue: this.q, 
          deferred: this.deferred
        };  

    // convenience - if the project is a boolen `true` rather than a pid, first
    // create a new project and then prepare the project api call to execute
    if (args.create) {
      return DeployR.new('/r/project/create', link)
               .end(function(res) {
                  return { project: res.get('project').project };
                })
               .io(api)
               .data(opts);
    } else {
      return DeployR.new(api, link).data(opts);
    }    
  },

  /** 
   * Convenience function for adding an additional repository-managed shell 
   * script execution to the exsisting sequential request chain.
   *
   * This call executes repository-managed shell scripts .sh, .csh, .bash, .bat 
   * on the DeployR server. Due to the special security concerns associated with 
   * excuting shell scripts on the DeployR server, only shell scripts owned by 
   * _ADMINISTRATOR_ users can be executed on this API call. Any attempt to 
   * execute a shell script stored in the repository that is not owned by an 
   * _ADMINISTRATOR_ user will be rejected.
   *
   * To execute a repository-managed shell script the caller must provide 
   * parameter values for _author_, _directory_, _filename_. This can be
   * achieved by providing a fully qualified shell script 
   * `/<author>/<directory>/<filename>`, for example:
   *
   *  ```
   *  .shell('/admin/external:public:admin/echo.sh', 'echo.sh args to pass.')
   *  ```
   *
   * @method shell
   * @param {String} filepath to define the fully qualified shell script for
   * execution. 
   * @param {String} args (optional) arguments to be passed into the shell 
   * script on execution.
   * @return {DeployR} for chaining.   
   * @api public
   */
  shell: function(path, args) {   
    var link = { 
          cookies: this.cookies, 
          queue: this.q, 
          deferred: this.deferred
        },
        tokens = Lang.isString(path) ? path.split('\/') : [];

    // handle both: `/author/directory/filename` & `author/directory/filename`
    if (tokens.length > 3) { tokens = tokens.slice(1); }

    return DeployR.new('/r/repository/shell/execute', link).data({
      author: tokens[0],
      directory: tokens[1],
      filename: tokens[2],
      args: args
    });
  },

  /** 
   * Convenience function for executing a block of R code on the R session.

   * Example:
   *  ```
   *  .code('x<-5')
   *  // -- or --
   *  .code('x<-5', projectId)
   *  ```
   *   
   * @method code
   * @param {String} r - The block of R code to execute.
   * @param {String} project - (optional) if omitted a new project will first be 
   * created and used, otherwise it will execute on the R session identified by 
   * this `project`.
   * @return {DeployR} for chaining.   
   * @api public
   */
  code: function(r, project) {
     var link = {
             cookies: this.cookies,
             queue: this.q,
             deferred: this.deferred
         },
         api = '/r/project/execute/code';

     if (!project) {
         return DeployR.new('/r/project/create', link)
             .end(function(res) {
                 return { project: res.get('project').project };
             })
             .io(api)
             .data({ code: r });
     } else {
         return DeployR.new(api, link).data({ code: r, project: project });
     }
  },
  
  /** 
   * Release any residual project resources associated with the application 
   * instance whenever a client application terminates. This includes closing 
   * any supplied projects down and logging out.
   *
   * @method release
   * @param {String|Array} projects The project or list of projects to close.
   * @param {Boolean} auth (optional) to remain authenticated.
   * @return {DeployR} for chaining.   
   * @api public
   */
  release: function(projects, auth) {
     projects = Lang.isArray(projects) ? projects : [projects];

     var self     = this,
         deferred = D(),
         empty    = !projects || !projects[0],
         count    = 0,
         last     = !empty ? projects.length - 1 : count,
         cookies  = this.getCookies();           

    function logout(index) {
      if (index === last) {
        if (!auth) {
          DeployR.new('/r/user/logout')
          .share(cookies)
          .error(function() {          
            deferred.reject(false);
          })      
          .end(function() { 
            deferred.resolve(true);
          })
          .ensure(function() {
            self.destroy();
          });
        } else {
          deferred.resolve(true);
          self.destroy();
        }
      } 
    }

    if (!empty) {
      projects.forEach(function(project) {
        DeployR.new('/r/project/close')
        .data({ project: project })
        .share(cookies)
        .end()
        .ensure(function() {
          logout(count);
          count++;
        });
      });   
    } else {
      logout(count);
    }

    return deferred.promise;  
  },  

  /** 
   * A convenience alternative to multiple `.rinput()` calls. Defines a name 
   * list of R objects that will be returned as DeployR-encoded R objects on the 
   * response markup.
   *
   * Calling this method ~.routputs([ ... ])` is equivalent to invoking multiple 
   * `.routput(...)` calls.
   *
   * @method routputs
   * @param {Array} robjects A name list of R objects that will be returned.
   * @return {DeployR} for chaining.   
   * @api public
   */
  routputs: function (routputs) {
    if (routputs) { this.outputs = this.outputs.concat(routputs); }

    return this;
  },
  
  /** 
   * Defines the name of the R object that will be returned as a DeployR-encoded 
   * R object on the response markup.
   *
   * @method routput
   * @param {String} robject The name of the R object that will be returned.
   * @return {DeployR} for chaining.   
   * @api public
   */
  routput: function (routput) {
    if (routput) { this.routputs([routput]); }

    return this;
  },

  /** 
   * Used to pass multiple inputs at once from JavaScript to an R script using 
   * one of the defined `RInput` factories.
   *
   * @method rinputs
   * @param {Array} rinputs The `RInput` list of DeployR-specific encoded R 
   * object data for use on an API call.
   * @return {DeployR} for chaining.   
   * @api public
   */
  rinputs: function (rinputs) {
    if (rinputs) { this.inputs = this.inputs.concat(rinputs); }

    return this;
  },

  /** 
   * Used to pass multiple inputs at once from JavaScript to an R script using 
   * one of the defined `RInput` factories.
   *
   * @method rinput
   * @param {RInput} rinput The DeployR-specific encoded R object data for use 
   * on an API call.   
   * @return {DeployR} for chaining.   
   * @api public
   */
  rinput: function (rinput) {
    if (rinput) { this.inputs.push(rinput); }

    return this;
  },

  /**
   * Destroy lifecycle method. Fires the `destroy` event, prior to invoking 
   * destructors for the class hierarchy. Called internally when `.release()`
   * is called.
   *
   * @method destroy
   * @api public   
   */
  destroy: function () {
    try {
      this.emit('destroy');
      this.offAll();
    
      for (var key in this) {
        if (this.hasOwnProperty(key)) { 
          this[key] = null; 
          delete this[key];
        }
      }
    } catch(err) {}
  },  

  // --------------------------------------------------------------------------
  // Private methods
  // --------------------------------------------------------------------------

  /**
   * @api private
   */
  _clear: function() {    
    this.params  = {};
    this.inputs  = [];
    this.outputs = [];
    this.rstream = false;
    this.delayed = false;
    this.api     = null;    
    this.file    = null;  
    this.filter  = null;
  }, 

  /**
   * @api private
   */
  _prepRequest: function (responseChain, args) {
    var req  = this.req,
        file = this.file;

    // set the request type    
    if (this.api.upload) {
       // If the env is the Browser there is no need to manually set the
       // Content-Type. The browser will automatically set the 
       // "multipart/form-data; boundary=..." value. If the env is Node we need
       // to set it manually.
       if (!win) { this.req.type('multipart/form-data'); }    
    } else {
      req.type('form');
    }    

    req.on('error', function(err) { 
      err = err || {  code: 'UNKNOWN CODE', text: 'UNKNOWN ERROR' };

      this._handleError({ 
        status: err.code || 'UNKNOWN CODE',
        text: err
      });
    }.bind(this));    

    this.share(args ? args.__cookies__ : null);

    // arguments returned from prev request's io().end(function() { return x; })
    if (args) { 
       this.data(args);
    } 

    if (this.inputs.length > 0) { 
      this.data({ inputs: encoder.encode(this.inputs) }); 
    }
  
    if (this.outputs.length > 0) { 
      this.data({ robjects: this.outputs.join() }); 
    }    

    if (this.cookies) {     
      this.cookies.forEach( function(c) { req.set('Cookie', c); });
    }

    if (this.api.upload) {    
      for(var p in this.params) {
       req.field(p, this.params[p] ? this.params[p] + '' : '');  
      } 
      req.attach('file', this.rstream ? fs.createReadStream(file) : file);
    } else {
      req[this.api.method === 'GET' ? 'query' : 'send'](this.params);
    } 
  },

  /**
   * @api private
   */
  _handleError: function (raw) {
    var stat  = raw.status,
        res   = (raw.body && raw.body.deployr ? raw.body : raw),
        error = ((stat !== 200) || res.deployr && !res.deployr.response.success);

    // -- Handle errors --
    if (error) {
      res = {
        get: function(key) { 
          return utils.get(this.deployr.response, key); 
        },
        deployr: {          
          response: {
            success: false,
            call: this.api['call'],
            errorCode: res.deployr ? res.deployr.response.errorCode : stat,
            error: res.deployr ? res.deployr.response.error : res.text
          }
        }
      };

      Logger.error('error()', this.api, res, raw);
      this.logger.error('error()', this.api, res, raw);

      // -- notify global errors first (if any) for this call --      
      if (this.globalEvts) {
        raiseGlobalErrors(this.api['call'], res);        
      }

      // -- tranaction level HTTP or DeployR errors come next --    
      this.emit('error', res);
      this.emit('deployr-io:' + res.deployr.response.errorCode, res);
      this.deferred.reject(res);
    }

    return error;
  }
});

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

// Include the `deprecated` jsDeployR for now.
if (win) {
  window.Revolution = window.Revolution || require('./lib/deprecated');
}

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/

/**
 * Expose for a cleaner client api into DeployR
 */
module.exports = {

  /**
   * Exposes the `DeployR` object for extending.
   *
   * ```var DeployR = require('deployr').DeployR;```
   *
   * @static
   * @api public
   * @return {DeployR} The `DeployR` object.
   */   
  DeployR: DeployR,

  /**
   * Exposes the supported DeployR APIs.
   *
   * @method apis
   * @param {Boolean} flat (optional) if `true` will return an array of just the 
   * API's endpoint properties, for example: 
   * ```
   * ['/r/user/login', '/r/user/logout', '/r/user/about', ...]
   * ```
   * @static
   * @api public
   * @return {Object|Array} The HTTP request to the DeployR server.      
   */  
  apis: function(flat) {
    return flat ? Object.keys(apis) : apis;
  },

  /**
   * Represents a static method for configuring all DeployR requests. Settings 
   * made here are applied globally across every request.
   *
   * @method configure
   * @param {Object} options The object literal configuration hash. 
   * @static
   * @chainable
   * @api public
   */
  configure: function(options) {
    options = options || {};

    for (var i in options) { globalOptions.set(i, options[i]); }

    // assert global cookies are empty if global `sticky` jsessionid is off
    if (!globalOptions.sticky)  { globalOptions.set('cookies', null); }

    // turn global logging on|off (off by default)
    Logger.setLevel(globalOptions.logging ? Logger.DEBUG : Logger.OFF);

    return this;
  },

  /**
   * Factory for creating new IO requests to `DeployR`.
   *
   * Example:
   * ```   
   *    deployr.io('/r/user/about').end(callback);
   * ```
   *
   * @method io
   * @param {String} api One of the supported DeployR APIs.
   * @static
   * @return {DeployR} The HTTP request to the DeployR server.
   * @api public   
   */
  io: function(api) {  
    return DeployR.new(api);
  },

  /**
   * Convenience function to sign the user in by authenticating the credentials 
   * with the DeployR server.   
   *
   * @method auth
   * @param {String} username Specifies the username.
   * @param {String} password Specifies the password.
   * @static
   * @return {DeployR} The HTTP request to the DeployR server.   
   * @api public   
   */   
  auth: function(un, pw) {
    var data = { username: un, password: pw };
    return DeployR.new('/r/user/login').data(data).end();    
  },

  /**
   * Convenience function to sign the user in by authenticating the credentials 
   * with the DeployR server.   
   *
   * Example:
   * ```
   *    deployr.script('/testuser/root/reduce.R')
   *    deployr.script({ filename: 'reduce.R', author: 'testuser',
   *                     directory: 'root'})
   *    deployr.script('reduce.R', 'testuser', 'root')
   *    deployr.script('/testuser/root/reduce.R', project)     
   * ```   
   *
   * @method script
   * @param {Arguments} arguments Arguments to define the fully qualified script 
   * for execution.
   * @static
   * @return {DeployR} The HTTP request to the DeployR server.   
   * @api public   
   */     
  script: function() {
    var args = utils.signature(arguments),
        opts = args.opts,
        api  = args.api;  

    // convenience - if the project is a boolen `true` rather than a pid, first
    // create a new project and then prepare the project api call to execute
    if (args.create) {
      return DeployR.new('/r/project/create')
               .end(function(res) {
                  return { project: res.get('project').project };
                })
               .io(api)
               .data(opts);
    } else {
      return DeployR.new(api).data(opts);
    }
  },  

  /**
   * Run an series of chained DeployR requests in sequence and without overlap.       
   *
   * @method pipline
   * @param {Array} tasks Specifies the list of `Function` tasks.
   * @static
   * @return {Promise} A promise wrapping the resolution of either "resolve" or
   * "reject" callback.
   * @api public   
   */
  pipeline: function(chains) {      
    var deployr  = this,
        deferred = D(),
        q        = new Queue(),
        results  = [],
        errors   = [],
        NOOP     = null, // NOOP errors|results for [a] batch request chain
        orig     = {
          sticky: globalOptions.sticky,
          cookies: globalOptions.cookies
        };

    // make a copy
    chains = chains.slice(0);

    // turn sticky session for these request (hacky)
    deployr.configure( { sticky: true });

    function add() {
      q.add(function() { 
        chains.shift().drain()
        .then(function(chain) {
          results.push(chain);  
          errors.push(NOOP);           
          if (q.isEmpty()) { 
            deployr.configure(orig); // reset
            deferred.resolve({ results: results, errors: errors }); 
          }  

          q.take();
        }, function(err) {          
          results.push(NOOP); 
          errors.push(err);
          // rejections are only met when they [all] fail
          if (q.isEmpty() && results.length === 0) { 
            deployr.configure(orig); // reset
            deferred.reject(errors); 
          }  
          q.take();
        });       
      }, null, true);
    }

    // convert to a seq queue for better handling
    for(var i = 0; i < chains.length; i++) { add(); }

    // start: dequeue first item and run it
    q.take();

    return deferred.promise;
  },

  /**
   * The event stream API is unique within the DeployR API as it supports push 
   * notifications from the DeployR server to client applications. Notifications 
   * correspond to discrete events that occur within the DeployR server. There 
   * are four distinct event categories:
   * 
   * - Stream Lifecycle events
   * - Execution events
   * - Job Lifecycle events
   * - Management events
   *
   * Example:
   * ```
   * deployr.es({ username: 'testuser', password: 'secret' })
   *    // -- connection choices for event types --
   *    .management()  //.session() | .all() | .project(id) | .job(id)
   *    .on('es:gridHeartbeat', function(data) {
   *        console.log('===================');
   *        console.log('es:gridHeartbeat');
   *        console.log('===================');          
   *     })
   *     .open();
   * ```
   * 
   * @method es
   * @param {Object} options The object literal configuration hash. 
   * @static
   * @return {EventStream} a new `EventStream` for binding.
   * @api public   
   */  
  es: function(options) {    
    var stream = EventStream.new(globalOptions.host, options);

    if (options && options.username && options.password) {
      var ruser = this.auth(options.username, options.password);
      ruser.ensure(function() { 
        stream.share(ruser.getCookies());
        stream.flush(); 
      });
    }

    return stream;
  },

  /**
   * Defines the factory for creating a DeployR-specific encoded R object to be 
   * sent as input parameters to an R script.
   *
   * Example:
   * ```
   *    var rinput = deployr.RInput.logical('logical_name', true);
   *    var rinput = deployr.RInput.numeric('numeric_name', 10.5);
   *    var rinput = deployr.RInput.integer('integer_name', 5);
   *    var rinput = deployr.RInput.character('character_name', 'Hello');
   *    // ect...
   * ```
   * @property RInput
   * @static
   * @api public
   */
  RInput: {
    numeric: function (name, value) {
      return RInput.new(name, value).numeric();
    },

    integer: function (name, value) {
      return RInput.new(name, value).integer();
    },

    logical: function (name, value) {
      return RInput.new(name, value).logical();
    },

    character: function (name, value) {
      return RInput.new(name, value).character();
    },

    date: function (name, value) {
      return RInput.new(name, value).date();
    },

    posixct: function (name, value) {
      return RInput.new(name, value).posixct();
    },  

    numericVector: function(name, value) {
      return RInput.new(name, value).numericVector();
    }, 

    integerVector: function (name, value) {
      return RInput.new(name, value).integerVector();
    },

    logicalVector: function (name, value) { 
      return RInput.new(name, value).logicalVector();
    },

    characterVector: function (name, value) { 
      return RInput.new(name, value).characterVector();
    },  

    dateVector: function (name, value) { 
      return RInput.new(name, value).dateVector();
    },  

    posixctVector: function (name, value) { 
      return RInput.new(name, value).posixctVector();
    },

    list: function (name, value) {
      return RInput.new(name, value).list(); 
    },

    dataframe: function (name, value) { 
      return RInput.new(name, value).dataframe();
    },
  
    factor: function (name, value, levels, labels) {
      var opts = { levels: levels, labels: labels };
      return RInput.new(name, value, opts).factor();
    },

    ordered: function (name, value, levels, labels) {
      var opts = { levels: levels, labels: labels };
      return RInput.new(name, value, opts).ordered();
    },

    numericMatrix: function (name, value) { 
      return RInput.new(name, value).numericMatrix();
    },

    integerMatrix: function (name, value) { 
      return RInput.new(name, value).integerMatrix();
    },

    logicalMatrix: function (name, value) { 
      return RInput.new(name, value).logicalMatrix();
    },

    characterMatrix: function (name, value) {
      return RInput.new(name, value).characterMatrix();
    }
  }
};
}).call(this,require('_process'))
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9kZXBsb3lyL2RlcGxveXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDE1IGJ5IFJldm9sdXRpb24gQW5hbHl0aWNzIEluYy5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSB0ZXJtcyBvZiBWZXJzaW9uIDIuMCBvZiB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlLiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5UWSwgSU5DTFVESU5HIFRIT1NFIE9GIE5PTi1JTkZSSU5HRU1FTlQsXG4gKiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFBsZWFzZSByZWZlciB0byB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlIDIuMCAoaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wKSBmb3IgbW9yZSBcbiAqIGRldGFpbHMuXG4gKi9cblxudmFyIHdpbiAgICAgICAgID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSwgICBcbiAgICByZXF1ZXN0ICAgICA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQnKSxcbiAgICBEICAgICAgICAgICA9IHJlcXVpcmUoJ2QuanMnKSxcbiAgICBmcyAgICAgICAgICA9IHJlcXVpcmUoJ2ZzJyksXG4gICAgYXBpcyAgICAgICAgPSByZXF1aXJlKCcuL2FwaXMuanNvbicpLCBcbiAgICBFdmVudFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL2VzJyksXG4gICAgdXRpbHMgICAgICAgPSByZXF1aXJlKCcuL2xpYi91dGlscycpLFxuICAgIExhbmcgICAgICAgID0gcmVxdWlyZSgnLi9saWIvbGFuZycpLCAgIFxuICAgIExvZ2dlciAgICAgID0gcmVxdWlyZSgnLi9saWIvbG9nZ2VyJyksICAgXG4gICAgUXVldWUgICAgICAgPSByZXF1aXJlKCcuL2xpYi9xdWV1ZScpLFxuICAgIEVtaXR0ZXIgICAgID0gcmVxdWlyZSgnLi9saWIvZW1pdHRlcicpLFxuICAgIGVuY29kZXIgICAgID0gcmVxdWlyZSgnLi9saWIvZW5jb2RlcicpLFxuICAgIEJhc2UgICAgICAgID0gcmVxdWlyZSgnLi9saWIvc2VsZmlzaCcpLkJhc2UsXG4gICAgUklucHV0ICAgICAgPSByZXF1aXJlKCcuL2xpYi9yaW5wdXQnKSwgICAgXG4gICAgUklucHV0cyAgICAgPSByZXF1aXJlKCcuL2xpYi9yaW5wdXRzJyksXG4gICAgbWVyZ2UgICAgICAgPSB1dGlscy5tZXJnZTtcblxuLypcbiAqIFR1cm4gZ2xvYmFsIGxvZ2dpbmcgb2ZmIGJ5IGRlZmF1bHRcbiAqL1xuTG9nZ2VyLnNldExldmVsKExvZ2dlci5PRkYpO1xuXG4vKlxuICogR2xvYmFsIG9wdGlvbnMgdGhhdCBwZXJzaXN0IHRocm91Z2ggYWxsIERlcGxveVIgcmVxdWVzdHMuXG4gKi9cbnZhciBnbG9iYWxPcHRpb25zID0geyBcbiAgY29yczogZmFsc2UsXG4gIGxvZ2dpbmc6IGZhbHNlLFxuICBzdGlja3k6IGZhbHNlLFxuICBjb29raWVzOiBudWxsLFxuICBob3N0OiAnJyxcbiAgYWxsb3dTZWxmU2lnbmVkU1NMQ2VydDogZmFsc2UsXG4gIG1heFJlcXVlc3RzOiBudWxsLCAvLyBubyBzb2NrZXQgcG9vbGluZyBpbiBodHRwLkFnZW50XG4gIGV2ZW50czp7fSxcbiAgc2V0OiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkgeyBcbiAgICBpZiAocHJvcCAhPT0gJ3NldCcpIHsgXG4gICAgICBpZiAocHJvcCA9PT0gJ2hvc3QnICYmIHZhbHVlKSB7ICAgICAgICAgXG4gICAgICAgICAvLyBCZSBtb3JlIGZvcmdpdmluZyBvbiB0aGUgZW50ZXJlZCBEZXBsb3lSICdlbmRwb2ludCc6XG4gICAgICAgICAvLyAgIC0gaHR0cChzKTovL2Rob3N0OnBvcnRcbiAgICAgICAgIC8vICAgLSBodHRwKHMpOi8vZGhvc3Q6cG9ydC9kZXBsb3lyXG4gICAgICAgICAvLyAgIC0gZGhvc3Q6cG9ydFxuICAgICAgICAgLy8gICAtIGRob3N0OnBvcnQvZGVwbG95ciAgICAgICAgIFxuICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXC8qJHxcXC8qZGVwbG95clxcLyokLywgJycpO1xuICAgICAgICAgdmFsdWUgPSAobmV3IFJlZ0V4cCgnXihodHRwfGh0dHBzKTovLycsICdpJykpLnRlc3QodmFsdWUpID8gdmFsdWUgOiBcbiAgICAgICAgICAgICdodHRwOi8vJyArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzW3Byb3BdID0gdmFsdWU7IFxuICAgIH0gXG4gIH1cbn07XG5cbi8qXG4gKiBUaGUgdG9wLWxldmVsIERlcGxveVIgQVBJIHJlc3BvbnNlIGVudGl0aWVzLlxuICovXG52YXIgVE9QTEVWRUxfRU5USVRJRVMgPSBbXG4gICd1c2VyJywgXG4gICdwcm9qZWN0JywgXG4gICd3b3Jrc3BhY2UnLCBcbiAgJ2V4ZWN1dGlvbicsIFxuICAnZGlyZWN0b3J5JywgXG4gICdyZXBvc2l0b3J5JywgXG4gICdwYWNrYWdlcycgXG5dO1xuXG4vKlxuICogTm90aWZ5IGdsb2JhbCBJTyBlcnJvciBldmVudHMgYWNjZXNzaWJsZSBieSBhbGwgc3Vic2NyaWJlcnMgYWNyb3NzIHJlcXVlc3RzLlxuICovXG5mdW5jdGlvbiByYWlzZUdsb2JhbEVycm9ycyhhcGksIHJlcykge1xuICB2YXIgY29kZSAgICA9IHJlcy5kZXBsb3lyID8gcmVzLmRlcGxveXIucmVzcG9uc2UuZXJyb3JDb2RlIDogcmVzLnN0YXR1cyxcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuXG4gIC8vIC0tIGdsb2JhbCBldmVudHMgaWYgcHJvdmlkZWQgLS1cbiAgaWYgKGdsb2JhbE9wdGlvbnMuZXZlbnRzKSB7XG4gICAgaWYgKCFyZXMuZGVwbG95cikge1xuICAgICAgcmVzID0gcmVzLnRleHQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGdsb2JhbE9wdGlvbnMuZXZlbnRzLmN0eCB8fCBjb250ZXh0O1xuXG4gICAgLy8gLS0gZ2VuZXJhbCBnbG9iYWwgZmFpbHVyZSAtLVxuICAgIGlmIChnbG9iYWxPcHRpb25zLmV2ZW50cy5lcnJvcikge1xuICAgICAgZ2xvYmFsT3B0aW9ucy5ldmVudHMuZXJyb3IuYXBwbHkoY29udGV4dCwgW2FwaSwgcmVzXSk7XG4gICAgfVxuXG4gICAgLy8gLS0gSFRUUCBvciBEZXBsb3lSIGdsb2JhbCBlcnJvcnMgLS0gICAgXG4gICAgaWYgKGdsb2JhbE9wdGlvbnMuZXZlbnRzW2NvZGVdKSB7XG4gICAgICBnbG9iYWxPcHRpb25zLmV2ZW50c1tjb2RlXS5hcHBseShjb250ZXh0LCBbYXBpLCByZXNdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYERlcGxveVJgIHJlcXVlc3QgY2xhc3MgaXMgYSB1dGlsaXR5IHRoYXQgYnJva2VycyBIVFRQIHJlcXVlc3RzIHRocm91Z2ggYSBcbiAqIHNpbXBsaWZpZWQgZmx1aWQgaW50ZXJmYWNlIHRvIERlcGxveVIuXG4gKlxuICogQG1vZHVsZSBkZXBsb3lyXG4gKiBAZm9yIGRlcGxveXJcbiAqL1xudmFyIERlcGxveVIgPSBCYXNlLmV4dGVuZChFbWl0dGVyLCBSSW5wdXRzLCB7XG5cbiAgLyoqXG4gICAqIFRoZSBgRGVwbG95UmAgUmVxdWVzdCBjbGFzcyBpcyBhIHV0aWxpdHkgdGhhdCBicm9rZXJzIEhUVFAgcmVxdWVzdHMgdGhyb3VnaCBcbiAgICogYSBzaW1wbGlmaWVkIGZsdWlkIGludGVyZmFjZSB0byBEZXBsb3lSLlxuICAgKiBcbiAgICogQGNsYXNzIFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFwaSBUaGUgRGVwbG95UiBBUElcbiAgICogQHBhcmFtIHtPYmplY3R9IGxpbmsgVGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgdGhlIHByZXZpb3VzIHJlcXVlc3QuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShhcGksIGxpbmspIHtcbiAgICAgRW1pdHRlci5pbml0aWFsaXplLmNhbGwodGhpcywge30pO1xuICBcbiAgICAgdmFyIG9wdHMgPSBnbG9iYWxPcHRpb25zO1xuXG4gICAgIGlmICghYXBpc1thcGldKSB7IHRocm93IG5ldyBFcnJvcignSW52YWxpZCBBUEkgXCInICsgYXBpICsgJ1wiJyk7IH1cbiAgICBcbiAgICAgdGhpcy5hcGkgICAgICAgID0gbWVyZ2UoeyAnY2FsbCc6IGFwaSB9LCBhcGlzW2FwaV0pOyAgICBcbiAgICAgdGhpcy5saW5rICAgICAgID0gbGluayB8fCB7fTtcbiAgICAgdGhpcy5xICAgICAgICAgID0gdGhpcy5saW5rLnF1ZXVlIHx8IG5ldyBRdWV1ZSgpO1xuICAgICB0aGlzLmRlZmVycmVkICAgPSB0aGlzLmxpbmsuZGVmZXJyZWQgfHwgRCgpO1xuICAgICB0aGlzLmNvb2tpZXMgICAgPSB0aGlzLmxpbmsuY29va2llcztcbiAgICAgdGhpcy5sb2dnZXIgICAgID0gTG9nZ2VyLmdldChhcGksIExvZ2dlci5PRkYpOyAvLyB0cmFuc2FjdGlvbi1sZXZlbCBsb2dnaW5nXG4gICAgIHRoaXMucGFyYW1zICAgICA9IHt9O1xuICAgICB0aGlzLmlucHV0cyAgICAgPSBbXTsgLy8gcmlucHV0cyBsaXN0IFxuICAgICB0aGlzLm91dHB1dHMgICAgPSBbXTsgLy8gcm91dHB1dCBvYmplY3QgbGlzdFxuICAgICB0aGlzLnJzdHJlYW0gICAgPSBmYWxzZTtcbiAgICAgdGhpcy5kZWxheWVkICAgID0gZmFsc2U7XG4gICAgIHRoaXMuZ2xvYmFsRXZ0cyA9IHRydWU7IC8vIHN1cHByZXNzfHJhaXNlIGdsb2JhbCBldmVudHMgZm90IHRoaXMgYGlvYCAgICAgXG4gICAgIHRoaXMuZmlsZSAgICAgICA9IG51bGw7IFxuICAgICB0aGlzLmZpbHRlciAgICAgPSBudWxsOyBcblxuICAgICAvLyBwcmVzZXQgZGVwbG95cidzIGFzc2lnbmVkIHJlc3BvbnNlIGZvcm1hdCBmb3IgYHRoaXNgIGFwaVxuICAgICB0aGlzLmRhdGEoeyBmb3JtYXQ6IHRoaXMuYXBpLmZvcm1hdCB9KTtcblxuICAgICAvLyB3cmFwIHN1cGVyYWdlbnQgZm9yIHRoZSBoZWF2eSBsaWZ0aW5nICAgICBcbiAgICAgdGhpcy5yZXEgPSBcbiAgICAgICAgcmVxdWVzdFt0aGlzLmFwaS5tZXRob2QudG9Mb3dlckNhc2UoKV0ob3B0cy5ob3N0ICsgJy9kZXBsb3lyJyArIGFwaSk7XG4gICAgIHRoaXMucmVxLnRpbWVvdXQoMjAgKiA2MCAqIDEwMDApOyAvLyBkZWZhdWx0IHRpbWVvdXQgLS0+IDIwIG1pbnV0ZXNcblxuICAgICAvLyBBbGwgQ09SUyBkZXBsb3lyIGNhbGxzIHJlcXVpcmUgc3RpY2t5IHNlc3Npb25zXG4gICAgIGlmICh3aW4gJiYgZ2xvYmFsT3B0aW9ucy5jb3JzKSB7IHRoaXMucmVxLndpdGhDcmVkZW50aWFscygpOyB9XG5cbiAgICAgLy8gTm9kZS5qcyAtIGFjY2VzcyBhbiBTU0wgZW5kcG9pbnQgd2l0aCBzZWxmIHNpZ25lZCBjZXJ0cyBmb3IgdGVzdGluZ3xkZXZcbiAgICAgaWYgKCF3aW4gJiYgZ2xvYmFsT3B0aW9ucy5hbGxvd1NlbGZTaWduZWRTU0xDZXJ0KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfVExTX1JFSkVDVF9VTkFVVEhPUklaRUQgPSAnMCc7ICAgICAgICBcbiAgICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgc2NvcGUgY29udGV4dCBmb3IgdGhlIGNvbmZpZ3VyZWQgYC5lbmQoKWAgYW5kIGAuZXJyb3IoKWAgZXZlbnQgICAgXG4gICAqIGhhbmRsZXIgY2FsbGJhY2tzIG9uIHRoaXMgcmVxdWVzdC5cbiAgICpcbiAgICogQG1ldGhvZCBjdHhcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGB0aGlzYCBvYmplY3QgZm9yIHRoZSBjb25maWd1cmVkIGAuZW5kKClgIGFuZFxuICAgKiBgLmVycm9yKClgIGV2ZW50IGhhbmRsZXJzIG9uIHRoaXMgcmVxdWVzdC5cbiAgICogQGFwaSBwdWJsaWMgICBcbiAgICovIFxuICBjdHg6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGhpcy5zY29wZSA9IGNvbnRleHQgfHwgdGhpcztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdXBwcmVzcyBvciByYWlzZSBnbG9iYWwgZXZlbnRzIGZvciB0aGlzIGBpb2AgcmVxdWVzdC5cbiAgICpcbiAgICogQG1ldGhvZCBnbG9iYWxcbiAgICogQHBhcmFtIHtCb29sZWFufSByYWlzZSBgdHJ1ZWAgdG8gcmFpc2UgZ2xvYmFsIGV2ZW50cywgYGZhbHNlYCB0byBzdXByZXNzIFxuICAgKiBldmVudCBmaXJpbmcgZ2xvYmFsbHkuXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovICBcbiAgZ2xvYmFsOiBmdW5jdGlvbihyYWlzZSkge1xuICAgIHRoaXMuZ2xvYmFsRXZ0cyA9IExhbmcuaXNCb29sZWFuKHJhaXNlKSA/IHJhaXNlIDogdGhpcy5nbG9iYWxFdnRzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sICBcblxuICAvKipcbiAgICogUmV0cmlldmUgZGV0YWlscyBhYm91dCB1c2VyLlxuICAgKiAgIFxuICAgKiBAbWV0aG9kIGFib3V0XG4gICAqIEByZXR1cm4ge09iamVjdH0gZGV0YWlscyBhYm91dCB1c2VyIG90aGVyd2llcyBgbnVsbGAuXG4gICAqIEBhcGkgcHVibGljICAgXG4gICAqL1xuICBhYm91dDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gdGhpcy5yZXEucmVzO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBpWydjYWxsJ10gPT09ICcvci91c2VyL2xvZ2luJyAmJiByZXNwb25zZSA/IFxuICAgICAgICAgICByZXNwb25zZS5ib2R5LmdldCgndXNlcicpIDogbnVsbDtcbiAgfSwgIFxuXG4gIC8qKlxuICAgKiBTaGFyZXMgdGhlIGNvb2tpZXMgZnJvbSBhIGRpZmZyZW50IGAuaW8oKWAgYWdlbnQgdG8gcHJlc2VydmUgc2Vzc2lvbiBzdGF0ZVxuICAgKiBhY3Jvc3MgYHRoaXNgIHJlcXVlc3QgYW5kIGFsbCByZXF1ZXN0cyBjaGFpbmVkIHRvIGl0LlxuICAgKlxuICAgKiBAbWV0aG9kIHNoYXJlXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWMgICBcbiAgICovICBcbiAgc2hhcmU6IGZ1bmN0aW9uIChjb29raWVzKSB7XG4gICAgaWYgKGdsb2JhbE9wdGlvbnMuc3RpY2t5KSB7XG4gICAgICBpZiAoZ2xvYmFsT3B0aW9ucy5jb29raWVzKSB7XG4gICAgICAgIHRoaXMuY29va2llcyA9IGdsb2JhbE9wdGlvbnMuY29va2llcy5zbGljZSgwKTsgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29va2llcykgeyBcbiAgICAgICAgICB0aGlzLmNvb2tpZXMgPSBjb29raWVzLnNsaWNlKDApOyBcbiAgICAgICAgICBnbG9iYWxPcHRpb25zLnNldCgnY29va2llcycsIHRoaXMuY29va2llcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb29raWVzID0gKGNvb2tpZXMgPyBjb29raWVzLnNsaWNlKDApIDogdGhpcy5jb29raWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgSFRUUCBjb29raWUgcHJldmlvdXNseSBzZW50IGJ5IHRoZSBzZXJ2ZXIgd2l0aCBTZXQtQ29va2llLlxuICAgKiBUaGlzIHZhbHVlIGNhbiBiZSBwYXNzZWQgdG8gYC5zaGFyZShydXNlci5nZXRDb29raWVzKCkpYCBvZiBhIGRpZmZyZW50XG4gICAqIGAuaW8oKWAgYWdlbnQgdG8gcHJlc2VydmUgc2Vzc2lvbiBzdGF0ZSBhY3Jvc3MgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0Q29va2llc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIEhUVFAgY29va2llIHByZXZpb3VzbHkgc2VudCBieSB0aGUgc2VydmVyIHdpdGggXG4gICAqIFNldC1Db29raWUuXG4gICAqIEBhcGkgcHVibGljICAgXG4gICAqLyAgXG4gIGdldENvb2tpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb29raWVzO1xuICB9LCBcblxuICBkZWxheTogZnVuY3Rpb24gKG1zKSB7XG4gICAgLy8gVE9ETzogc3VwcG9ydCBkZWxheWVkIHJlcXVlc3RzIGJhc2VkIG9uIG1zIGZvciBub3cgdGhpcyBpcyBqdXN0IGEgcGF1c2UuXG4gICAgdGhpcy5kZWxheWVkID0gIWlzTmFOKHBhcnNlRmxvYXQobXMpKSAmJiBpc0Zpbml0ZShtcykgPyBtcyA6IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSwgICBcblxuICAvKipcbiAgICogVW53aW5kIHRoZSBxdWV1ZSBjaGFpbiBjbGVhcmluZyByZXF1ZXN0cyB0aGF0IG1pZ2h0IGhhdmUgZGVsYXlzIGF0dGFjaGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIGRyYWluXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB3cmFwcGluZyB0aGUgcmVzb2x1dGlvbiBvZiBlaXRoZXIgXCJyZXNvbHZlXCIgb3JcbiAgICogXCJyZWplY3RcIiBjYWxsYmFjay5cbiAgICogQGFwaSBwdWJsaWMgICBcbiAgICovXG4gIGRyYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWxheWVkID0gZmFsc2U7XG4gICAgdGhpcy5xLmZsdXNoKCk7IFxuXG4gICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQucHJvbWlzZTtcbiAgfSwgICBcblxuICAvKipcbiAgICogVGhlIGAucHJvbWlzZSgpYCBtZXRob2QgcmV0dXJucyBhIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBQcm9taXNlIHRoYXQgaXMgXG4gICAqIHJlc29sdmVkIG9uY2UgYWxsIERlcGxveVIgYC5pbygpYCByZXF1ZXN0cyBoYXZlIGVuZGVkLlxuICAgKiAgIFxuICAgKiBAbWV0aG9kIHByb21pc2VcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHdyYXBwaW5nIHRoZSByZXNvbHV0aW9uIG9mIGVpdGhlciBcInJlc29sdmVcIiBvclxuICAgKiBcInJlamVjdFwiIGNhbGxiYWNrLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi8gICAgIFxuICBwcm9taXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmQoKTtcblxuICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnByb21pc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFib3J0IHRoZSBEZXBsb3lSIHJlcXVlc3QuXG4gICAqXG4gICAqIEBtZXRob2QgYWJvcnQgIFxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqLyAgXG4gIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXEuYWJvcnQoKTtcbiAgICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gICAgdGhpcy5kZWZlcnJlZC5yZWplY3QodGhpcy5faGFuZGxlRXJyb3IoeyBcbiAgICAgICAgc3RhdHVzOiAnYWJvcnQnLFxuICAgICAgICB0ZXh0OiAnRGVwbG95UiByZXF1ZXN0IGFib3J0ZWQuJ1xuICAgIH0pKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gLyoqXG4gICogU2V0IHRpbWVvdXQgdG8gYG1zYC5cbiAgKlxuICAqIEBtZXRob2QgdGltZW91dCAgXG4gICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nXG4gICogQGFwaSBwdWJsaWNcbiAgKi8gIFxuICB0aW1lb3V0OiBmdW5jdGlvbiAobXMpIHtcbiAgICB0aGlzLnJlcS50aW1lb3V0KG1zKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gLyoqXG4gICogVHVybiBsb2dnaW5nIG9uIGZvciB0aGUgc3BlY2lmaWMgdHJhbnNhY3Rpb24uXG4gICpcbiAgKiBAbWV0aG9kIGxvZ1xuICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZ1xuICAqIEBhcGkgcHVibGljXG4gICovIFxuICBsb2c6IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgIHRoaXMubG9nZ2VyLnNldExldmVsKGxldmVsIHx8IExvZ2dlci5ERUJVRyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyBzdWNjZXNzZnVsIHJlc3BvbnNlcyB0byBjb250YWluIG9ubHkgYSB0b3AtbGV2ZWwgRGVwbG95UiBBUEkgXG4gICAqIHJlc3BvbnNlIGVudGl0aWVzOlxuICAgKiAtICd1c2VyJ1xuICAgKiAtICdwcm9qZWN0J1xuICAgKiAtICd3b3Jrc3BhY2UnIFxuICAgKiAtICdleGVjdXRpb24nIFxuICAgKiAtICdkaXJlY3RvcnknIFxuICAgKiAtICdyZXBvc2l0b3J5J1xuICAgKiAtICdwYWNrYWdlcycgXG4gICAqICAgXG4gICAqIEBtZXRob2QgZW50aXR5XG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgZW50aXR5OiBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgdGhpcy5maWx0ZXIgPSB1dGlscy5pbkFycmF5KFRPUExFVkVMX0VOVElUSUVTLCBlbnRpdHkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIHJlcXVlc3QgZGF0YSBiZWluZyBzZW50IHRvIGEgRGVwbG95UiBBUEkuIFxuICAgKlxuICAgKiBAbWV0aG9kIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIG9iamVjdCBsaXRlcmFsIGNvbmZpZ3VyYXRpb24gaGFzaC4gXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgZGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTsgICAgXG5cbiAgICAvLyByZW1vdmUgYW55IGlubGluZWQgcmlucHV0KHMpIGFuZCBhdHRhY2ggdGhlbSB0byB0aGUgcmlucHV0KHMpIHByb3BlcnR5XG4gICAgaWYgKGRhdGEucmlucHV0IHx8IGRhdGEucmlucHV0cykge1xuICAgICAgdGhpcy5yaW5wdXQoZGF0YS5yaW5wdXQpO1xuICAgICAgdGhpcy5yaW5wdXRzKGRhdGEucmlucHV0cyk7XG4gICAgfSBcblxuICAgIC8vIHJlbW92ZSBhbnkgYHJlc2VydmVkYCB2YWx1ZXMgdGhhdCBjb3VsZCBoYXZlIGJlZW4gcGFzc2VkIGJ5IG1pc3Rha2VcbiAgICB2YXIgQkxBQ0tMSVNUID0gWydyaW5wdXQnLCAncmlucHV0cycsICdfX2Nvb2tpZXNfXyddO1xuICAgIEJMQUNLTElTVC5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7IGRlbGV0ZSBkYXRhW3BhcmFtXTsgfSk7ICBcblxuICAgIHRoaXMucGFyYW1zID0gbWVyZ2UodGhpcy5wYXJhbXMsIGRhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGEgZmlsZSB0byBiZSB1cGxvYWRlZC4gXG4gICAqXG4gICAqIEBtZXRob2QgYXR0YWNoXG4gICAqIEBwYXJhbSB7RmlsZXxCbG9ifHBhdGh9IGZpbGUgVGhlIGZpbGUgdG8gYmUgYXR0YWNoZWQgZm9yIGFuIHVwbG9hZC4gRm9yIFxuICAgKiBCcm93c2VyIGVudmlyb25tZW50cyB0aGUgSFRNTDUgRmlsZXxCbG9iIGlzIHVzZWQuIEZvciB0aGUgTm9kZS5qcyBcbiAgICogZW52aXJvbm1lbnQsIGEgZmlsZSBwYXRoIGlzIGFjY2VwdGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWUgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZC4gXG4gICAqIFRoaXMgbmFtZSBkb2VzIG5vdCBoYXZlIHRvIG1hdGNoIHRoZSBhY3R1YWwgc291cmNlIGZpbGVuYW1lLlxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGF0dGFjaDogZnVuY3Rpb24gKGZpbGUsIGZpbGVuYW1lKSB7XG4gICAgaWYgKHRoaXMuYXBpLnVwbG9hZCkge1xuICAgICAgdGhpcy5maWxlID0gZmlsZTtcblxuICAgICAgLy8gb3B0aW9uYWwgZmlsZW5hbWUgaGVyZSBmb3IgY29udmVuaWVuY2VcbiAgICAgIGlmIChmaWxlbmFtZSkgeyB0aGlzLmRhdGEoIHsgZmlsZW5hbWU6IGZpbGVuYW1lIH0gKTsgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdXBwb3J0ZWQgb25seSBpbiBOb2RlLmpzLCB0aGlzIG1ldGhvZCB3b3JrcyBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBcbiAgICogYXR0YWNoIG1ldGhvZCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBmaWxlIHNob3VsZCBiZSByZWFkIGluIGFzIGEgcmVhZGFibGUgXG4gICAqIHN0cmVhbSBkdXJpbmcgYSBmaWxlIHVwbG9hZC5cbiAgICpcbiAgICogQG1ldGhvZCBzdHJlYW1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgKG9wdGlvbmFsKSB0aGUgUmVhZGFibGUgU3RyZWFtIG9wdGlvbnMgaGFzaC5cbiAgICogIGBgYFxuICAgKiAgICB7IGZsYWdzOiAncicsXG4gICAqICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAqICAgICAgZmQ6IG51bGwsXG4gICAqICAgICAgbW9kZTogMDY2NixcbiAgICogICAgICBhdXRvQ2xvc2U6IHRydWVcbiAgICogICAgfVxuICAgKiBgYGBcbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBzdHJlYW06IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJzdHJlYW0gPSAoIXdpbiAmJiB0aGlzLmFwaS51cGxvYWQpOyAvL25vZGVqcyBvbmx5XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBBY3RzIGFzIGEgZmluYWxseSBzdGF0ZW1lbnQgYWxsb3dpbmcgeW91IHRvIGV4ZWN1dGUgXCJjbGVhbnVwXCIgdHlwZSB0YXNrcyBcbiAgICogaW4gYSByZXF1ZXN0IGNoYWluLiBJdCBhcnJhbmdlcyBmb3IgY2xlYW51cCB0byBiZSBjYWxsZWQsIHdpdGggbm8gXG4gICAqIGFyZ3VtZW50cywgd2hlbiB0aGUgRGVwbG95UiByZXF1ZXN0IGNoYWluIGlzIGVpdGhlciBjb21wbGV0ZWx5IGZ1bGZpbGxlZCBcbiAgICogb3IgcmVqZWN0ZWQuXG4gICAqXG4gICAqIEBtZXRob2QgZW5zdXJlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IM67IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqLyAgXG4gIGVuc3VyZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgdGhpcy5kZWZlcnJlZC5wcm9taXNlLmVuc3VyZShmbik7XG5cbiAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xuICB9LFxuICAgICAgXG4gIC8qKlxuICAgKiBUaGUgZ2VuZXJhbCBmYWlsdXJlIGNhbGxiYWNrLiBJZiBjYWxsZWQsIGFsbCBEZXBsb3lSIGVycm9ycyBmb3IgdGhpcyBcbiAgICogdHJhbnNhY3Rpb24gd2lsbCBiZSByZXR1cm5lZCBoZXJlIHdoZW4gcmFpc2VkLlxuICAgKlxuICAgKiBAbWV0aG9kIGVycm9yXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IM67IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBlcnJvcjogZnVuY3Rpb24gKGZuKSB7XG4gICAgdGhpcy5vbignZXJyb3InLCBmbik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU3RyZWFtIHRoZSBEZXBsb3lSIHJlc3BvbnNlIGludG8gdGhlIHBpcGUuIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgaWYgXG4gICAqIHRoZSBgLnBpcGUoKWAgbWV0aG9kIGlzIG5ldmVyIGNhbGxlZCB0aGUgcmVxdWVzdCB3aWxsIG5vdCBiZSBzZW50LlxuICAgKlxuICAgKiBUaGUgYC5waXBlKClgIG1ldGhvZCBzaG91bGQgYmUgYmUgdXNlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBgLmVuZCgpYCBhbmQgXG4gICAqIG5ldmVyIGFsb25nIHNpZGUgb2YgaXQuIGAucGlwZSgpYCBhbmQgYC5lbmQoKWAgYXJlIGFuIGVpdGhlci1vci5cbiAgICpcbiAgICogQG1ldGhvZCBwaXBlXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gQSBkZXN0aW5hdGlvbiBTdHJlYW0uXG4gICAqIEByZXR1cm4ge1N0cmVhbX0gVGhlIHBhc3NlZCBpbiBkZXN0aW5hdGlvbiBzdHJlYW0gdG8gYmUgdXNlZCBmb3IgYWRkaXRpb25hbCBcbiAgICogcGlwaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgcGlwZTogZnVuY3Rpb24gKGRlc3QpIHtcbiAgICB2YXIgcSAgID0gdGhpcy5xLFxuICAgICAgICBhcGkgPSB0aGlzLmFwaTsgICAgICAgIFxuXG4gICAgcS5hZGQoZnVuY3Rpb24ocmVzcG9uc2VDaGFpbiwgZXJyb3IsIHByZXZBcmdzKSB7ICAgIFxuICAgICAgLy8gYnJha2UgdGhlIGNhbGwgY2hhaW4gb24gZXJyb3IgICAgICBcbiAgICAgIGlmIChlcnJvcikgeyAgICAgICAgXG4gICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KGVycm9yKTsgICAgICBcbiAgICAgICAgcS5mbHVzaChyZXNwb25zZUNoYWluLCBlcnJvciwgcHJldkFyZ3MpOyAvLyBkcmFpbiB0aGUgcXVldWVcbiAgICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLl9wcmVwUmVxdWVzdChyZXNwb25zZUNoYWluLCBwcmV2QXJncyk7XG5cbiAgICAgIExvZ2dlci5pbmZvKCdwaXBlKCknLCBhcGksIHRoaXMucmVxKTtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ3BpcGUoKScsIGFwaSwgdGhpcy5yZXEpOyAgIFxuXG4gICAgICB2YXIgc3RyZWFtID0gdGhpcy5yZXEucGlwZShkZXN0KTtcbiAgICAgIHEueWllbGQodHJ1ZSk7XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkgeyB9KTsgICAgXG4gICAgICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkgeyB9KTsgICAgIFxuICAgICAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oKSB7IH0pOyAgICAgIFxuICAgIH0sIHRoaXMpO1xuICBcbiAgICBpZiAocS5zaXplKCkgPD0gMSkgeyBxLmZsdXNoKCk7IH1cblxuICAgIHJldHVybiBkZXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdCBpcyByZWFkeSB0byBiZSBzZW50IHRvIERlcGxveVIuIEl0IGlzIGltcG9ydGFudCBcbiAgICogdG8gbm90ZSB0aGF0IGlmIHRoZSBgLmVuZCgpYCBtZXRob2QgaXMgbmV2ZXIgY2FsbGVkIHRoZSByZXF1ZXN0IHdpbGwgbm90IGJlXG4gICAqIHNlbnQuXG4gICAqXG4gICAqIEBtZXRob2QgZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IM67IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi8gXG4gIGVuZDogZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHNlbGYgICA9IHRoaXMsXG4gICAgICAgIHEgICAgICA9IHRoaXMucSxcbiAgICAgICAgYXBpICAgID0gdGhpcy5hcGksXG4gICAgICAgIGFyZ3MgICA9IG51bGwsXG4gICAgICAgIGVudGl0eSA9IHRoaXMuZmlsdGVyO1xuXG4gICAgcS5hZGQoZnVuY3Rpb24ocmVzcG9uc2VDaGFpbiwgZXJyb3IsIHByZXZBcmdzKSB7XG4gICAgICAvLyBicmVhayB0aGUgY2FsbCBjaGFpbiBvbiBlcnJvciAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7ICAgICAgICBcbiAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyb3IpOyAgICAgICAgXG4gICAgICAgIHEuZmx1c2gocmVzcG9uc2VDaGFpbiwgZXJyb3IsIHByZXZBcmdzKTsgLy8gZHJhaW4gdGhlIHF1ZXVlXG4gICAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5fcHJlcFJlcXVlc3QocmVzcG9uc2VDaGFpbiwgcHJldkFyZ3MpO1xuXG4gICAgICBMb2dnZXIuaW5mbygnaW8oKScsIGFwaSwgdGhpcy5yZXEpO1xuICAgICAgdGhpcy5sb2dnZXIuaW5mbygnaW8oKScsIGFwaSwgdGhpcy5yZXEpOyAgICBcblxuICAgICAgdGhpcy5yZXEuZW5kKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBzZWxmLnNoYXJlKHNlbGYuY29va2llcyB8fCByZXMuaGVhZGVyc1snc2V0LWNvb2tpZSddKTsgICAgICAgICBcblxuICAgICAgICAvLyAtLSBsb2cgY29va2llcyBhY3Jvc3MgcmVxdWVzdHMgLS1cbiAgICAgICAgaWYgKHNlbGYuY29va2llcykge1xuICAgICAgICAgIExvZ2dlci5pbmZvKCdjb29raWVzJywgYXBpLCBzZWxmLmNvb2tpZXMpOyBcbiAgICAgICAgICBzZWxmLmxvZ2dlci5pbmZvKCdjb29raWVzJywgYXBpLCBzZWxmLmNvb2tpZXMpOyBcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yID0gc2VsZi5faGFuZGxlRXJyb3IocmVzKTtcbiAgICAgICAgdmFyIGRyZXMgPSAocmVzLmJvZHkgJiYgcmVzLmJvZHkuZGVwbG95ciA/IHJlcy5ib2R5IDogcmVzKTsgICAgICAgICAgICAgXG4gICAgICBcbiAgICAgICAgc2VsZi5pbnB1dHMgPSBbXTtcbiAgICAgICAgc2VsZi5vdXRwdXRzID0gW107XG5cbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAvLyAtLSBMb2cgZ2xvYmFsICsgdHJhbnNhY3Rpb24gbG9nIC0tXG4gICAgICAgICAgIExvZ2dlci5pbmZvKCdlbmQoKScsIGFwaSwgZHJlcywgcmVzKTtcbiAgICAgICAgICAgc2VsZi5sb2dnZXIuaW5mbygnZW5kKCknLCBhcGksIGRyZXMsIHJlcyk7XG5cbiAgICAgICAgICAgLy8gLS0gd2FsayByZXNwb25zZSBmb3IgdG9wLWxldmVsIGVudGl0eSByZXNwb25zZSBhc3NpZ25tZW50IC0tICAgICAgICBcbiAgICAgICAgICAgaWYgKGVudGl0eSkgeyBkcmVzID0gZHJlcy5kZXBsb3lyLnJlc3BvbnNlW2VudGl0eV0gfHwgZHJlczsgfVxuXG4gICAgICAgICAgIGRyZXMuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7IFxuICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuZ2V0KGRyZXMuZGVwbG95ci5yZXNwb25zZSwga2V5KTsgXG4gICAgICAgICAgIH07XG5cbiAgICAgICAgICAgZHJlcy53b3Jrc3BhY2UgPSBmdW5jdGlvbihuYW1lKSB7IFxuICAgICAgICAgICAgICByZXR1cm4gdXRpbHMud29ya3NwYWNlKGRyZXMuZGVwbG95ci5yZXNwb25zZSwgbmFtZSk7IFxuICAgICAgICAgICB9O1xuXG4gICAgICAgICAgIC8vIC0tIGNhbGxiYWNrIC0tXG4gICAgICAgICAgIGlmIChmbikgeyBhcmdzID0gZm4uYXBwbHkoc2VsZi5zY29wZSwgW2RyZXMsIHJlc3BvbnNlQ2hhaW5dKTt9XG5cbiAgICAgICAgICAgLy8gLS0gbm90aWZ5IHRoYXQgdGhlIHF1ZXVlIGhhcyBiZWVuIGRyYWluZWQuLi4gLS1cbiAgICAgICAgICAgaWYgKHEuc2l6ZSgpID09PSAwKSB7IFxuICAgICAgICAgICAgIHNlbGYuX2NsZWFyKCk7XG4gICAgICAgICAgICAgc2VsZi5kZWZlcnJlZC5yZXNvbHZlKHJlc3BvbnNlQ2hhaW4gfHwgZHJlcyk7XG4gICAgICAgICAgIH0gICAgICAgICAgXG5cbiAgICAgICAgICAgLy8gLS0gaW5jbHVkZSBjb29raWVzIGluIG5leHQgcmVxdWVzdCBpbiB0aGUgcXVldWUgLS1cbiAgICAgICAgICAgYXJncyA9IG1lcmdlKGFyZ3MsIHsgX19jb29raWVzX186IHNlbGYuY29va2llcyB9KTsgICAgICAgICAgXG4gICAgICAgIH0gICAgICAgIFxuXG4gICAgICAgIHEueWllbGQoZmFsc2UpO1xuICAgICAgICBxLmZsdXNoKGRyZXMsIGVycm9yLCBhcmdzKTsgLy8gcGFzcyByZXN1bHR8ZXJyb3J8YXJncyB0byBuZXh0IFxuICAgICAgfSk7XG5cbiAgICAgIHEueWllbGQodHJ1ZSk7XG4gICAgfSwgdGhpcywgdGhpcy5kZWxheWVkKTtcbiAgXG4gICAgaWYgKCF0aGlzLmRlbGF5ZWQgJiYgcS5zaXplKCkgPD0gMSkgeyBxLmZsdXNoKCk7IH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LCBcblxuICAvKiogXG4gICAqIEFkZCBhbiBhZGRpdGlvbmFsIElPIHJlcXVlc3QgdG8gdGhlIGV4c2lzdGluZyBzZXF1ZW50aWFsIHJlcXVlc3QgY2hhaW4uXG4gICAqXG4gICAqIEBtZXRob2QgaW9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFwaSBPbmUgb2YgdGhlIHN1cHBvcnRlZCBEZXBsb3lSIEFQSXMuXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovICAgXG4gIGlvOiBmdW5jdGlvbiAoYXBpKSB7ICAgIFxuICAgIHJldHVybiBEZXBsb3lSLm5ldyhhcGksIHsgXG4gICAgICBjb29raWVzOiB0aGlzLmNvb2tpZXMsIFxuICAgICAgcXVldWU6IHRoaXMucSwgXG4gICAgICBkZWZlcnJlZDogdGhpcy5kZWZlcnJlZFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKiBcbiAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFkZGluZyBhbiBhZGRpdGlvbmFsIHNjcmlwdCBleGVjdXRpb24gdG8gdGhlIFxuICAgKiBleHNpc3Rpbmcgc2VxdWVudGlhbCByZXF1ZXN0IGNoYWluLlxuICAgKlxuICAgKiBAbWV0aG9kIHNjcmlwdFxuICAgKiBAcGFyYW0ge0FyZ3VtZW50c30gQXJndW1lbnRzIHRvIGRlZmluZSB0aGUgZnVsbHkgcXVhbGlmaWVkIHNjcmlwdCBmb3IgXG4gICAqIGV4ZWN1dGlvbi5cbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nLiAgIFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgc2NyaXB0OiBmdW5jdGlvbigpIHtcbiAgICAgdmFyIGFyZ3MgPSB1dGlscy5zaWduYXR1cmUoYXJndW1lbnRzKSxcbiAgICAgICAgIG9wdHMgPSBhcmdzLm9wdHMsXG4gICAgICAgICBhcGkgID0gYXJncy5hcGksXG4gICAgICAgICBsaW5rID0geyBcbiAgICAgICAgICBjb29raWVzOiB0aGlzLmNvb2tpZXMsIFxuICAgICAgICAgIHF1ZXVlOiB0aGlzLnEsIFxuICAgICAgICAgIGRlZmVycmVkOiB0aGlzLmRlZmVycmVkXG4gICAgICAgIH07ICBcblxuICAgIC8vIGNvbnZlbmllbmNlIC0gaWYgdGhlIHByb2plY3QgaXMgYSBib29sZW4gYHRydWVgIHJhdGhlciB0aGFuIGEgcGlkLCBmaXJzdFxuICAgIC8vIGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGFuZCB0aGVuIHByZXBhcmUgdGhlIHByb2plY3QgYXBpIGNhbGwgdG8gZXhlY3V0ZVxuICAgIGlmIChhcmdzLmNyZWF0ZSkge1xuICAgICAgcmV0dXJuIERlcGxveVIubmV3KCcvci9wcm9qZWN0L2NyZWF0ZScsIGxpbmspXG4gICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvamVjdDogcmVzLmdldCgncHJvamVjdCcpLnByb2plY3QgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgLmlvKGFwaSlcbiAgICAgICAgICAgICAgIC5kYXRhKG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRGVwbG95Ui5uZXcoYXBpLCBsaW5rKS5kYXRhKG9wdHMpO1xuICAgIH0gICAgXG4gIH0sXG5cbiAgLyoqIFxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgYWRkaW5nIGFuIGFkZGl0aW9uYWwgcmVwb3NpdG9yeS1tYW5hZ2VkIHNoZWxsIFxuICAgKiBzY3JpcHQgZXhlY3V0aW9uIHRvIHRoZSBleHNpc3Rpbmcgc2VxdWVudGlhbCByZXF1ZXN0IGNoYWluLlxuICAgKlxuICAgKiBUaGlzIGNhbGwgZXhlY3V0ZXMgcmVwb3NpdG9yeS1tYW5hZ2VkIHNoZWxsIHNjcmlwdHMgLnNoLCAuY3NoLCAuYmFzaCwgLmJhdCBcbiAgICogb24gdGhlIERlcGxveVIgc2VydmVyLiBEdWUgdG8gdGhlIHNwZWNpYWwgc2VjdXJpdHkgY29uY2VybnMgYXNzb2NpYXRlZCB3aXRoIFxuICAgKiBleGN1dGluZyBzaGVsbCBzY3JpcHRzIG9uIHRoZSBEZXBsb3lSIHNlcnZlciwgb25seSBzaGVsbCBzY3JpcHRzIG93bmVkIGJ5IFxuICAgKiBfQURNSU5JU1RSQVRPUl8gdXNlcnMgY2FuIGJlIGV4ZWN1dGVkIG9uIHRoaXMgQVBJIGNhbGwuIEFueSBhdHRlbXB0IHRvIFxuICAgKiBleGVjdXRlIGEgc2hlbGwgc2NyaXB0IHN0b3JlZCBpbiB0aGUgcmVwb3NpdG9yeSB0aGF0IGlzIG5vdCBvd25lZCBieSBhbiBcbiAgICogX0FETUlOSVNUUkFUT1JfIHVzZXIgd2lsbCBiZSByZWplY3RlZC5cbiAgICpcbiAgICogVG8gZXhlY3V0ZSBhIHJlcG9zaXRvcnktbWFuYWdlZCBzaGVsbCBzY3JpcHQgdGhlIGNhbGxlciBtdXN0IHByb3ZpZGUgXG4gICAqIHBhcmFtZXRlciB2YWx1ZXMgZm9yIF9hdXRob3JfLCBfZGlyZWN0b3J5XywgX2ZpbGVuYW1lXy4gVGhpcyBjYW4gYmVcbiAgICogYWNoaWV2ZWQgYnkgcHJvdmlkaW5nIGEgZnVsbHkgcXVhbGlmaWVkIHNoZWxsIHNjcmlwdCBcbiAgICogYC88YXV0aG9yPi88ZGlyZWN0b3J5Pi88ZmlsZW5hbWU+YCwgZm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICBgYGBcbiAgICogIC5zaGVsbCgnL2FkbWluL2V4dGVybmFsOnB1YmxpYzphZG1pbi9lY2hvLnNoJywgJ2VjaG8uc2ggYXJncyB0byBwYXNzLicpXG4gICAqICBgYGBcbiAgICpcbiAgICogQG1ldGhvZCBzaGVsbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZXBhdGggdG8gZGVmaW5lIHRoZSBmdWxseSBxdWFsaWZpZWQgc2hlbGwgc2NyaXB0IGZvclxuICAgKiBleGVjdXRpb24uIFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncyAob3B0aW9uYWwpIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgaW50byB0aGUgc2hlbGwgXG4gICAqIHNjcmlwdCBvbiBleGVjdXRpb24uXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy4gICBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIHNoZWxsOiBmdW5jdGlvbihwYXRoLCBhcmdzKSB7ICAgXG4gICAgdmFyIGxpbmsgPSB7IFxuICAgICAgICAgIGNvb2tpZXM6IHRoaXMuY29va2llcywgXG4gICAgICAgICAgcXVldWU6IHRoaXMucSwgXG4gICAgICAgICAgZGVmZXJyZWQ6IHRoaXMuZGVmZXJyZWRcbiAgICAgICAgfSxcbiAgICAgICAgdG9rZW5zID0gTGFuZy5pc1N0cmluZyhwYXRoKSA/IHBhdGguc3BsaXQoJ1xcLycpIDogW107XG5cbiAgICAvLyBoYW5kbGUgYm90aDogYC9hdXRob3IvZGlyZWN0b3J5L2ZpbGVuYW1lYCAmIGBhdXRob3IvZGlyZWN0b3J5L2ZpbGVuYW1lYFxuICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMykgeyB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoMSk7IH1cblxuICAgIHJldHVybiBEZXBsb3lSLm5ldygnL3IvcmVwb3NpdG9yeS9zaGVsbC9leGVjdXRlJywgbGluaykuZGF0YSh7XG4gICAgICBhdXRob3I6IHRva2Vuc1swXSxcbiAgICAgIGRpcmVjdG9yeTogdG9rZW5zWzFdLFxuICAgICAgZmlsZW5hbWU6IHRva2Vuc1syXSxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KTtcbiAgfSxcblxuICAvKiogXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBleGVjdXRpbmcgYSBibG9jayBvZiBSIGNvZGUgb24gdGhlIFIgc2Vzc2lvbi5cblxuICAgKiBFeGFtcGxlOlxuICAgKiAgYGBgXG4gICAqICAuY29kZSgneDwtNScpXG4gICAqICAvLyAtLSBvciAtLVxuICAgKiAgLmNvZGUoJ3g8LTUnLCBwcm9qZWN0SWQpXG4gICAqICBgYGBcbiAgICogICBcbiAgICogQG1ldGhvZCBjb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByIC0gVGhlIGJsb2NrIG9mIFIgY29kZSB0byBleGVjdXRlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvamVjdCAtIChvcHRpb25hbCkgaWYgb21pdHRlZCBhIG5ldyBwcm9qZWN0IHdpbGwgZmlyc3QgYmUgXG4gICAqIGNyZWF0ZWQgYW5kIHVzZWQsIG90aGVyd2lzZSBpdCB3aWxsIGV4ZWN1dGUgb24gdGhlIFIgc2Vzc2lvbiBpZGVudGlmaWVkIGJ5IFxuICAgKiB0aGlzIGBwcm9qZWN0YC5cbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nLiAgIFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgY29kZTogZnVuY3Rpb24ociwgcHJvamVjdCkge1xuICAgICB2YXIgbGluayA9IHtcbiAgICAgICAgICAgICBjb29raWVzOiB0aGlzLmNvb2tpZXMsXG4gICAgICAgICAgICAgcXVldWU6IHRoaXMucSxcbiAgICAgICAgICAgICBkZWZlcnJlZDogdGhpcy5kZWZlcnJlZFxuICAgICAgICAgfSxcbiAgICAgICAgIGFwaSA9ICcvci9wcm9qZWN0L2V4ZWN1dGUvY29kZSc7XG5cbiAgICAgaWYgKCFwcm9qZWN0KSB7XG4gICAgICAgICByZXR1cm4gRGVwbG95Ui5uZXcoJy9yL3Byb2plY3QvY3JlYXRlJywgbGluaylcbiAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICByZXR1cm4geyBwcm9qZWN0OiByZXMuZ2V0KCdwcm9qZWN0JykucHJvamVjdCB9O1xuICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgLmlvKGFwaSlcbiAgICAgICAgICAgICAuZGF0YSh7IGNvZGU6IHIgfSk7XG4gICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gRGVwbG95Ui5uZXcoYXBpLCBsaW5rKS5kYXRhKHsgY29kZTogciwgcHJvamVjdDogcHJvamVjdCB9KTtcbiAgICAgfVxuICB9LFxuICBcbiAgLyoqIFxuICAgKiBSZWxlYXNlIGFueSByZXNpZHVhbCBwcm9qZWN0IHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcGxpY2F0aW9uIFxuICAgKiBpbnN0YW5jZSB3aGVuZXZlciBhIGNsaWVudCBhcHBsaWNhdGlvbiB0ZXJtaW5hdGVzLiBUaGlzIGluY2x1ZGVzIGNsb3NpbmcgXG4gICAqIGFueSBzdXBwbGllZCBwcm9qZWN0cyBkb3duIGFuZCBsb2dnaW5nIG91dC5cbiAgICpcbiAgICogQG1ldGhvZCByZWxlYXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwcm9qZWN0cyBUaGUgcHJvamVjdCBvciBsaXN0IG9mIHByb2plY3RzIHRvIGNsb3NlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGF1dGggKG9wdGlvbmFsKSB0byByZW1haW4gYXV0aGVudGljYXRlZC5cbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nLiAgIFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgcmVsZWFzZTogZnVuY3Rpb24ocHJvamVjdHMsIGF1dGgpIHtcbiAgICAgcHJvamVjdHMgPSBMYW5nLmlzQXJyYXkocHJvamVjdHMpID8gcHJvamVjdHMgOiBbcHJvamVjdHNdO1xuXG4gICAgIHZhciBzZWxmICAgICA9IHRoaXMsXG4gICAgICAgICBkZWZlcnJlZCA9IEQoKSxcbiAgICAgICAgIGVtcHR5ICAgID0gIXByb2plY3RzIHx8ICFwcm9qZWN0c1swXSxcbiAgICAgICAgIGNvdW50ICAgID0gMCxcbiAgICAgICAgIGxhc3QgICAgID0gIWVtcHR5ID8gcHJvamVjdHMubGVuZ3RoIC0gMSA6IGNvdW50LFxuICAgICAgICAgY29va2llcyAgPSB0aGlzLmdldENvb2tpZXMoKTsgICAgICAgICAgIFxuXG4gICAgZnVuY3Rpb24gbG9nb3V0KGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgaWYgKCFhdXRoKSB7XG4gICAgICAgICAgRGVwbG95Ui5uZXcoJy9yL3VzZXIvbG9nb3V0JylcbiAgICAgICAgICAuc2hhcmUoY29va2llcylcbiAgICAgICAgICAuZXJyb3IoZnVuY3Rpb24oKSB7ICAgICAgICAgIFxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGZhbHNlKTtcbiAgICAgICAgICB9KSAgICAgIFxuICAgICAgICAgIC5lbmQoZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lbnN1cmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgIHNlbGYuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9IFxuICAgIH1cblxuICAgIGlmICghZW1wdHkpIHtcbiAgICAgIHByb2plY3RzLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdCkge1xuICAgICAgICBEZXBsb3lSLm5ldygnL3IvcHJvamVjdC9jbG9zZScpXG4gICAgICAgIC5kYXRhKHsgcHJvamVjdDogcHJvamVjdCB9KVxuICAgICAgICAuc2hhcmUoY29va2llcylcbiAgICAgICAgLmVuZCgpXG4gICAgICAgIC5lbnN1cmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG9nb3V0KGNvdW50KTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAgIFxuICAgIH0gZWxzZSB7XG4gICAgICBsb2dvdXQoY291bnQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlOyAgXG4gIH0sICBcblxuICAvKiogXG4gICAqIEEgY29udmVuaWVuY2UgYWx0ZXJuYXRpdmUgdG8gbXVsdGlwbGUgYC5yaW5wdXQoKWAgY2FsbHMuIERlZmluZXMgYSBuYW1lIFxuICAgKiBsaXN0IG9mIFIgb2JqZWN0cyB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgYXMgRGVwbG95Ui1lbmNvZGVkIFIgb2JqZWN0cyBvbiB0aGUgXG4gICAqIHJlc3BvbnNlIG1hcmt1cC5cbiAgICpcbiAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB+LnJvdXRwdXRzKFsgLi4uIF0pYCBpcyBlcXVpdmFsZW50IHRvIGludm9raW5nIG11bHRpcGxlIFxuICAgKiBgLnJvdXRwdXQoLi4uKWAgY2FsbHMuXG4gICAqXG4gICAqIEBtZXRob2Qgcm91dHB1dHNcbiAgICogQHBhcmFtIHtBcnJheX0gcm9iamVjdHMgQSBuYW1lIGxpc3Qgb2YgUiBvYmplY3RzIHRoYXQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nLiAgIFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgcm91dHB1dHM6IGZ1bmN0aW9uIChyb3V0cHV0cykge1xuICAgIGlmIChyb3V0cHV0cykgeyB0aGlzLm91dHB1dHMgPSB0aGlzLm91dHB1dHMuY29uY2F0KHJvdXRwdXRzKTsgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIFxuICAvKiogXG4gICAqIERlZmluZXMgdGhlIG5hbWUgb2YgdGhlIFIgb2JqZWN0IHRoYXQgd2lsbCBiZSByZXR1cm5lZCBhcyBhIERlcGxveVItZW5jb2RlZCBcbiAgICogUiBvYmplY3Qgb24gdGhlIHJlc3BvbnNlIG1hcmt1cC5cbiAgICpcbiAgICogQG1ldGhvZCByb3V0cHV0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSByb2JqZWN0IFRoZSBuYW1lIG9mIHRoZSBSIG9iamVjdCB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy4gICBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIHJvdXRwdXQ6IGZ1bmN0aW9uIChyb3V0cHV0KSB7XG4gICAgaWYgKHJvdXRwdXQpIHsgdGhpcy5yb3V0cHV0cyhbcm91dHB1dF0pOyB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKiogXG4gICAqIFVzZWQgdG8gcGFzcyBtdWx0aXBsZSBpbnB1dHMgYXQgb25jZSBmcm9tIEphdmFTY3JpcHQgdG8gYW4gUiBzY3JpcHQgdXNpbmcgXG4gICAqIG9uZSBvZiB0aGUgZGVmaW5lZCBgUklucHV0YCBmYWN0b3JpZXMuXG4gICAqXG4gICAqIEBtZXRob2QgcmlucHV0c1xuICAgKiBAcGFyYW0ge0FycmF5fSByaW5wdXRzIFRoZSBgUklucHV0YCBsaXN0IG9mIERlcGxveVItc3BlY2lmaWMgZW5jb2RlZCBSIFxuICAgKiBvYmplY3QgZGF0YSBmb3IgdXNlIG9uIGFuIEFQSSBjYWxsLlxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmcuICAgXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICByaW5wdXRzOiBmdW5jdGlvbiAocmlucHV0cykge1xuICAgIGlmIChyaW5wdXRzKSB7IHRoaXMuaW5wdXRzID0gdGhpcy5pbnB1dHMuY29uY2F0KHJpbnB1dHMpOyB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKiogXG4gICAqIFVzZWQgdG8gcGFzcyBtdWx0aXBsZSBpbnB1dHMgYXQgb25jZSBmcm9tIEphdmFTY3JpcHQgdG8gYW4gUiBzY3JpcHQgdXNpbmcgXG4gICAqIG9uZSBvZiB0aGUgZGVmaW5lZCBgUklucHV0YCBmYWN0b3JpZXMuXG4gICAqXG4gICAqIEBtZXRob2QgcmlucHV0XG4gICAqIEBwYXJhbSB7UklucHV0fSByaW5wdXQgVGhlIERlcGxveVItc3BlY2lmaWMgZW5jb2RlZCBSIG9iamVjdCBkYXRhIGZvciB1c2UgXG4gICAqIG9uIGFuIEFQSSBjYWxsLiAgIFxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmcuICAgXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICByaW5wdXQ6IGZ1bmN0aW9uIChyaW5wdXQpIHtcbiAgICBpZiAocmlucHV0KSB7IHRoaXMuaW5wdXRzLnB1c2gocmlucHV0KTsgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgbGlmZWN5Y2xlIG1ldGhvZC4gRmlyZXMgdGhlIGBkZXN0cm95YCBldmVudCwgcHJpb3IgdG8gaW52b2tpbmcgXG4gICAqIGRlc3RydWN0b3JzIGZvciB0aGUgY2xhc3MgaGllcmFyY2h5LiBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIGAucmVsZWFzZSgpYFxuICAgKiBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBtZXRob2QgZGVzdHJveVxuICAgKiBAYXBpIHB1YmxpYyAgIFxuICAgKi9cbiAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICAgIHRoaXMub2ZmQWxsKCk7XG4gICAgXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7IFxuICAgICAgICAgIHRoaXNba2V5XSA9IG51bGw7IFxuICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge31cbiAgfSwgIFxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIF9jbGVhcjogZnVuY3Rpb24oKSB7ICAgIFxuICAgIHRoaXMucGFyYW1zICA9IHt9O1xuICAgIHRoaXMuaW5wdXRzICA9IFtdO1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgIHRoaXMucnN0cmVhbSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsYXllZCA9IGZhbHNlO1xuICAgIHRoaXMuYXBpICAgICA9IG51bGw7ICAgIFxuICAgIHRoaXMuZmlsZSAgICA9IG51bGw7ICBcbiAgICB0aGlzLmZpbHRlciAgPSBudWxsO1xuICB9LCBcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBfcHJlcFJlcXVlc3Q6IGZ1bmN0aW9uIChyZXNwb25zZUNoYWluLCBhcmdzKSB7XG4gICAgdmFyIHJlcSAgPSB0aGlzLnJlcSxcbiAgICAgICAgZmlsZSA9IHRoaXMuZmlsZTtcblxuICAgIC8vIHNldCB0aGUgcmVxdWVzdCB0eXBlICAgIFxuICAgIGlmICh0aGlzLmFwaS51cGxvYWQpIHtcbiAgICAgICAvLyBJZiB0aGUgZW52IGlzIHRoZSBCcm93c2VyIHRoZXJlIGlzIG5vIG5lZWQgdG8gbWFudWFsbHkgc2V0IHRoZVxuICAgICAgIC8vIENvbnRlbnQtVHlwZS4gVGhlIGJyb3dzZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgXG4gICAgICAgLy8gXCJtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0uLi5cIiB2YWx1ZS4gSWYgdGhlIGVudiBpcyBOb2RlIHdlIG5lZWRcbiAgICAgICAvLyB0byBzZXQgaXQgbWFudWFsbHkuXG4gICAgICAgaWYgKCF3aW4pIHsgdGhpcy5yZXEudHlwZSgnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpOyB9ICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICByZXEudHlwZSgnZm9ybScpO1xuICAgIH0gICAgXG5cbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7IFxuICAgICAgZXJyID0gZXJyIHx8IHsgIGNvZGU6ICdVTktOT1dOIENPREUnLCB0ZXh0OiAnVU5LTk9XTiBFUlJPUicgfTtcblxuICAgICAgdGhpcy5faGFuZGxlRXJyb3IoeyBcbiAgICAgICAgc3RhdHVzOiBlcnIuY29kZSB8fCAnVU5LTk9XTiBDT0RFJyxcbiAgICAgICAgdGV4dDogZXJyXG4gICAgICB9KTtcbiAgICB9LmJpbmQodGhpcykpOyAgICBcblxuICAgIHRoaXMuc2hhcmUoYXJncyA/IGFyZ3MuX19jb29raWVzX18gOiBudWxsKTtcblxuICAgIC8vIGFyZ3VtZW50cyByZXR1cm5lZCBmcm9tIHByZXYgcmVxdWVzdCdzIGlvKCkuZW5kKGZ1bmN0aW9uKCkgeyByZXR1cm4geDsgfSlcbiAgICBpZiAoYXJncykgeyBcbiAgICAgICB0aGlzLmRhdGEoYXJncyk7XG4gICAgfSBcblxuICAgIGlmICh0aGlzLmlucHV0cy5sZW5ndGggPiAwKSB7IFxuICAgICAgdGhpcy5kYXRhKHsgaW5wdXRzOiBlbmNvZGVyLmVuY29kZSh0aGlzLmlucHV0cykgfSk7IFxuICAgIH1cbiAgXG4gICAgaWYgKHRoaXMub3V0cHV0cy5sZW5ndGggPiAwKSB7IFxuICAgICAgdGhpcy5kYXRhKHsgcm9iamVjdHM6IHRoaXMub3V0cHV0cy5qb2luKCkgfSk7IFxuICAgIH0gICAgXG5cbiAgICBpZiAodGhpcy5jb29raWVzKSB7ICAgICBcbiAgICAgIHRoaXMuY29va2llcy5mb3JFYWNoKCBmdW5jdGlvbihjKSB7IHJlcS5zZXQoJ0Nvb2tpZScsIGMpOyB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcGkudXBsb2FkKSB7ICAgIFxuICAgICAgZm9yKHZhciBwIGluIHRoaXMucGFyYW1zKSB7XG4gICAgICAgcmVxLmZpZWxkKHAsIHRoaXMucGFyYW1zW3BdID8gdGhpcy5wYXJhbXNbcF0gKyAnJyA6ICcnKTsgIFxuICAgICAgfSBcbiAgICAgIHJlcS5hdHRhY2goJ2ZpbGUnLCB0aGlzLnJzdHJlYW0gPyBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGUpIDogZmlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcVt0aGlzLmFwaS5tZXRob2QgPT09ICdHRVQnID8gJ3F1ZXJ5JyA6ICdzZW5kJ10odGhpcy5wYXJhbXMpO1xuICAgIH0gXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgX2hhbmRsZUVycm9yOiBmdW5jdGlvbiAocmF3KSB7XG4gICAgdmFyIHN0YXQgID0gcmF3LnN0YXR1cyxcbiAgICAgICAgcmVzICAgPSAocmF3LmJvZHkgJiYgcmF3LmJvZHkuZGVwbG95ciA/IHJhdy5ib2R5IDogcmF3KSxcbiAgICAgICAgZXJyb3IgPSAoKHN0YXQgIT09IDIwMCkgfHwgcmVzLmRlcGxveXIgJiYgIXJlcy5kZXBsb3lyLnJlc3BvbnNlLnN1Y2Nlc3MpO1xuXG4gICAgLy8gLS0gSGFuZGxlIGVycm9ycyAtLVxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmVzID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkgeyBcbiAgICAgICAgICByZXR1cm4gdXRpbHMuZ2V0KHRoaXMuZGVwbG95ci5yZXNwb25zZSwga2V5KTsgXG4gICAgICAgIH0sXG4gICAgICAgIGRlcGxveXI6IHsgICAgICAgICAgXG4gICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgY2FsbDogdGhpcy5hcGlbJ2NhbGwnXSxcbiAgICAgICAgICAgIGVycm9yQ29kZTogcmVzLmRlcGxveXIgPyByZXMuZGVwbG95ci5yZXNwb25zZS5lcnJvckNvZGUgOiBzdGF0LFxuICAgICAgICAgICAgZXJyb3I6IHJlcy5kZXBsb3lyID8gcmVzLmRlcGxveXIucmVzcG9uc2UuZXJyb3IgOiByZXMudGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgTG9nZ2VyLmVycm9yKCdlcnJvcigpJywgdGhpcy5hcGksIHJlcywgcmF3KTtcbiAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdlcnJvcigpJywgdGhpcy5hcGksIHJlcywgcmF3KTtcblxuICAgICAgLy8gLS0gbm90aWZ5IGdsb2JhbCBlcnJvcnMgZmlyc3QgKGlmIGFueSkgZm9yIHRoaXMgY2FsbCAtLSAgICAgIFxuICAgICAgaWYgKHRoaXMuZ2xvYmFsRXZ0cykge1xuICAgICAgICByYWlzZUdsb2JhbEVycm9ycyh0aGlzLmFwaVsnY2FsbCddLCByZXMpOyAgICAgICAgXG4gICAgICB9XG5cbiAgICAgIC8vIC0tIHRyYW5hY3Rpb24gbGV2ZWwgSFRUUCBvciBEZXBsb3lSIGVycm9ycyBjb21lIG5leHQgLS0gICAgXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcmVzKTtcbiAgICAgIHRoaXMuZW1pdCgnZGVwbG95ci1pbzonICsgcmVzLmRlcGxveXIucmVzcG9uc2UuZXJyb3JDb2RlLCByZXMpO1xuICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QocmVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEluY2x1ZGUgdGhlIGBkZXByZWNhdGVkYCBqc0RlcGxveVIgZm9yIG5vdy5cbmlmICh3aW4pIHtcbiAgd2luZG93LlJldm9sdXRpb24gPSB3aW5kb3cuUmV2b2x1dGlvbiB8fCByZXF1aXJlKCcuL2xpYi9kZXByZWNhdGVkJyk7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gKiBFeHBvc2UgZm9yIGEgY2xlYW5lciBjbGllbnQgYXBpIGludG8gRGVwbG95UlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogRXhwb3NlcyB0aGUgYERlcGxveVJgIG9iamVjdCBmb3IgZXh0ZW5kaW5nLlxuICAgKlxuICAgKiBgYGB2YXIgRGVwbG95UiA9IHJlcXVpcmUoJ2RlcGxveXInKS5EZXBsb3lSO2BgYFxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IFRoZSBgRGVwbG95UmAgb2JqZWN0LlxuICAgKi8gICBcbiAgRGVwbG95UjogRGVwbG95UixcblxuICAvKipcbiAgICogRXhwb3NlcyB0aGUgc3VwcG9ydGVkIERlcGxveVIgQVBJcy5cbiAgICpcbiAgICogQG1ldGhvZCBhcGlzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmxhdCAob3B0aW9uYWwpIGlmIGB0cnVlYCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBqdXN0IHRoZSBcbiAgICogQVBJJ3MgZW5kcG9pbnQgcHJvcGVydGllcywgZm9yIGV4YW1wbGU6IFxuICAgKiBgYGBcbiAgICogWycvci91c2VyL2xvZ2luJywgJy9yL3VzZXIvbG9nb3V0JywgJy9yL3VzZXIvYWJvdXQnLCAuLi5dXG4gICAqIGBgYFxuICAgKiBAc3RhdGljXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEByZXR1cm4ge09iamVjdHxBcnJheX0gVGhlIEhUVFAgcmVxdWVzdCB0byB0aGUgRGVwbG95UiBzZXJ2ZXIuICAgICAgXG4gICAqLyAgXG4gIGFwaXM6IGZ1bmN0aW9uKGZsYXQpIHtcbiAgICByZXR1cm4gZmxhdCA/IE9iamVjdC5rZXlzKGFwaXMpIDogYXBpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHN0YXRpYyBtZXRob2QgZm9yIGNvbmZpZ3VyaW5nIGFsbCBEZXBsb3lSIHJlcXVlc3RzLiBTZXR0aW5ncyBcbiAgICogbWFkZSBoZXJlIGFyZSBhcHBsaWVkIGdsb2JhbGx5IGFjcm9zcyBldmVyeSByZXF1ZXN0LlxuICAgKlxuICAgKiBAbWV0aG9kIGNvbmZpZ3VyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IGxpdGVyYWwgY29uZmlndXJhdGlvbiBoYXNoLiBcbiAgICogQHN0YXRpY1xuICAgKiBAY2hhaW5hYmxlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBjb25maWd1cmU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykgeyBnbG9iYWxPcHRpb25zLnNldChpLCBvcHRpb25zW2ldKTsgfVxuXG4gICAgLy8gYXNzZXJ0IGdsb2JhbCBjb29raWVzIGFyZSBlbXB0eSBpZiBnbG9iYWwgYHN0aWNreWAganNlc3Npb25pZCBpcyBvZmZcbiAgICBpZiAoIWdsb2JhbE9wdGlvbnMuc3RpY2t5KSAgeyBnbG9iYWxPcHRpb25zLnNldCgnY29va2llcycsIG51bGwpOyB9XG5cbiAgICAvLyB0dXJuIGdsb2JhbCBsb2dnaW5nIG9ufG9mZiAob2ZmIGJ5IGRlZmF1bHQpXG4gICAgTG9nZ2VyLnNldExldmVsKGdsb2JhbE9wdGlvbnMubG9nZ2luZyA/IExvZ2dlci5ERUJVRyA6IExvZ2dlci5PRkYpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBJTyByZXF1ZXN0cyB0byBgRGVwbG95UmAuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYCAgIFxuICAgKiAgICBkZXBsb3lyLmlvKCcvci91c2VyL2Fib3V0JykuZW5kKGNhbGxiYWNrKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBtZXRob2QgaW9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFwaSBPbmUgb2YgdGhlIHN1cHBvcnRlZCBEZXBsb3lSIEFQSXMuXG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybiB7RGVwbG95Un0gVGhlIEhUVFAgcmVxdWVzdCB0byB0aGUgRGVwbG95UiBzZXJ2ZXIuXG4gICAqIEBhcGkgcHVibGljICAgXG4gICAqL1xuICBpbzogZnVuY3Rpb24oYXBpKSB7ICBcbiAgICByZXR1cm4gRGVwbG95Ui5uZXcoYXBpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2lnbiB0aGUgdXNlciBpbiBieSBhdXRoZW50aWNhdGluZyB0aGUgY3JlZGVudGlhbHMgXG4gICAqIHdpdGggdGhlIERlcGxveVIgc2VydmVyLiAgIFxuICAgKlxuICAgKiBAbWV0aG9kIGF1dGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lIFNwZWNpZmllcyB0aGUgdXNlcm5hbWUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBTcGVjaWZpZXMgdGhlIHBhc3N3b3JkLlxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IFRoZSBIVFRQIHJlcXVlc3QgdG8gdGhlIERlcGxveVIgc2VydmVyLiAgIFxuICAgKiBAYXBpIHB1YmxpYyAgIFxuICAgKi8gICBcbiAgYXV0aDogZnVuY3Rpb24odW4sIHB3KSB7XG4gICAgdmFyIGRhdGEgPSB7IHVzZXJuYW1lOiB1biwgcGFzc3dvcmQ6IHB3IH07XG4gICAgcmV0dXJuIERlcGxveVIubmV3KCcvci91c2VyL2xvZ2luJykuZGF0YShkYXRhKS5lbmQoKTsgICAgXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNpZ24gdGhlIHVzZXIgaW4gYnkgYXV0aGVudGljYXRpbmcgdGhlIGNyZWRlbnRpYWxzIFxuICAgKiB3aXRoIHRoZSBEZXBsb3lSIHNlcnZlci4gICBcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqICAgIGRlcGxveXIuc2NyaXB0KCcvdGVzdHVzZXIvcm9vdC9yZWR1Y2UuUicpXG4gICAqICAgIGRlcGxveXIuc2NyaXB0KHsgZmlsZW5hbWU6ICdyZWR1Y2UuUicsIGF1dGhvcjogJ3Rlc3R1c2VyJyxcbiAgICogICAgICAgICAgICAgICAgICAgICBkaXJlY3Rvcnk6ICdyb290J30pXG4gICAqICAgIGRlcGxveXIuc2NyaXB0KCdyZWR1Y2UuUicsICd0ZXN0dXNlcicsICdyb290JylcbiAgICogICAgZGVwbG95ci5zY3JpcHQoJy90ZXN0dXNlci9yb290L3JlZHVjZS5SJywgcHJvamVjdCkgICAgIFxuICAgKiBgYGAgICBcbiAgICpcbiAgICogQG1ldGhvZCBzY3JpcHRcbiAgICogQHBhcmFtIHtBcmd1bWVudHN9IGFyZ3VtZW50cyBBcmd1bWVudHMgdG8gZGVmaW5lIHRoZSBmdWxseSBxdWFsaWZpZWQgc2NyaXB0IFxuICAgKiBmb3IgZXhlY3V0aW9uLlxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IFRoZSBIVFRQIHJlcXVlc3QgdG8gdGhlIERlcGxveVIgc2VydmVyLiAgIFxuICAgKiBAYXBpIHB1YmxpYyAgIFxuICAgKi8gICAgIFxuICBzY3JpcHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gdXRpbHMuc2lnbmF0dXJlKGFyZ3VtZW50cyksXG4gICAgICAgIG9wdHMgPSBhcmdzLm9wdHMsXG4gICAgICAgIGFwaSAgPSBhcmdzLmFwaTsgIFxuXG4gICAgLy8gY29udmVuaWVuY2UgLSBpZiB0aGUgcHJvamVjdCBpcyBhIGJvb2xlbiBgdHJ1ZWAgcmF0aGVyIHRoYW4gYSBwaWQsIGZpcnN0XG4gICAgLy8gY3JlYXRlIGEgbmV3IHByb2plY3QgYW5kIHRoZW4gcHJlcGFyZSB0aGUgcHJvamVjdCBhcGkgY2FsbCB0byBleGVjdXRlXG4gICAgaWYgKGFyZ3MuY3JlYXRlKSB7XG4gICAgICByZXR1cm4gRGVwbG95Ui5uZXcoJy9yL3Byb2plY3QvY3JlYXRlJylcbiAgICAgICAgICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBwcm9qZWN0OiByZXMuZ2V0KCdwcm9qZWN0JykucHJvamVjdCB9O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAuaW8oYXBpKVxuICAgICAgICAgICAgICAgLmRhdGEob3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEZXBsb3lSLm5ldyhhcGkpLmRhdGEob3B0cyk7XG4gICAgfVxuICB9LCAgXG5cbiAgLyoqXG4gICAqIFJ1biBhbiBzZXJpZXMgb2YgY2hhaW5lZCBEZXBsb3lSIHJlcXVlc3RzIGluIHNlcXVlbmNlIGFuZCB3aXRob3V0IG92ZXJsYXAuICAgICAgIFxuICAgKlxuICAgKiBAbWV0aG9kIHBpcGxpbmVcbiAgICogQHBhcmFtIHtBcnJheX0gdGFza3MgU3BlY2lmaWVzIHRoZSBsaXN0IG9mIGBGdW5jdGlvbmAgdGFza3MuXG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHdyYXBwaW5nIHRoZSByZXNvbHV0aW9uIG9mIGVpdGhlciBcInJlc29sdmVcIiBvclxuICAgKiBcInJlamVjdFwiIGNhbGxiYWNrLlxuICAgKiBAYXBpIHB1YmxpYyAgIFxuICAgKi9cbiAgcGlwZWxpbmU6IGZ1bmN0aW9uKGNoYWlucykgeyAgICAgIFxuICAgIHZhciBkZXBsb3lyICA9IHRoaXMsXG4gICAgICAgIGRlZmVycmVkID0gRCgpLFxuICAgICAgICBxICAgICAgICA9IG5ldyBRdWV1ZSgpLFxuICAgICAgICByZXN1bHRzICA9IFtdLFxuICAgICAgICBlcnJvcnMgICA9IFtdLFxuICAgICAgICBOT09QICAgICA9IG51bGwsIC8vIE5PT1AgZXJyb3JzfHJlc3VsdHMgZm9yIFthXSBiYXRjaCByZXF1ZXN0IGNoYWluXG4gICAgICAgIG9yaWcgICAgID0ge1xuICAgICAgICAgIHN0aWNreTogZ2xvYmFsT3B0aW9ucy5zdGlja3ksXG4gICAgICAgICAgY29va2llczogZ2xvYmFsT3B0aW9ucy5jb29raWVzXG4gICAgICAgIH07XG5cbiAgICAvLyBtYWtlIGEgY29weVxuICAgIGNoYWlucyA9IGNoYWlucy5zbGljZSgwKTtcblxuICAgIC8vIHR1cm4gc3RpY2t5IHNlc3Npb24gZm9yIHRoZXNlIHJlcXVlc3QgKGhhY2t5KVxuICAgIGRlcGxveXIuY29uZmlndXJlKCB7IHN0aWNreTogdHJ1ZSB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIHEuYWRkKGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgY2hhaW5zLnNoaWZ0KCkuZHJhaW4oKVxuICAgICAgICAudGhlbihmdW5jdGlvbihjaGFpbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChjaGFpbik7ICBcbiAgICAgICAgICBlcnJvcnMucHVzaChOT09QKTsgICAgICAgICAgIFxuICAgICAgICAgIGlmIChxLmlzRW1wdHkoKSkgeyBcbiAgICAgICAgICAgIGRlcGxveXIuY29uZmlndXJlKG9yaWcpOyAvLyByZXNldFxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh7IHJlc3VsdHM6IHJlc3VsdHMsIGVycm9yczogZXJyb3JzIH0pOyBcbiAgICAgICAgICB9ICBcblxuICAgICAgICAgIHEudGFrZSgpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHsgICAgICAgICAgXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKE5PT1ApOyBcbiAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgIC8vIHJlamVjdGlvbnMgYXJlIG9ubHkgbWV0IHdoZW4gdGhleSBbYWxsXSBmYWlsXG4gICAgICAgICAgaWYgKHEuaXNFbXB0eSgpICYmIHJlc3VsdHMubGVuZ3RoID09PSAwKSB7IFxuICAgICAgICAgICAgZGVwbG95ci5jb25maWd1cmUob3JpZyk7IC8vIHJlc2V0XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3JzKTsgXG4gICAgICAgICAgfSAgXG4gICAgICAgICAgcS50YWtlKCk7XG4gICAgICAgIH0pOyAgICAgICBcbiAgICAgIH0sIG51bGwsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdG8gYSBzZXEgcXVldWUgZm9yIGJldHRlciBoYW5kbGluZ1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjaGFpbnMubGVuZ3RoOyBpKyspIHsgYWRkKCk7IH1cblxuICAgIC8vIHN0YXJ0OiBkZXF1ZXVlIGZpcnN0IGl0ZW0gYW5kIHJ1biBpdFxuICAgIHEudGFrZSgpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBldmVudCBzdHJlYW0gQVBJIGlzIHVuaXF1ZSB3aXRoaW4gdGhlIERlcGxveVIgQVBJIGFzIGl0IHN1cHBvcnRzIHB1c2ggXG4gICAqIG5vdGlmaWNhdGlvbnMgZnJvbSB0aGUgRGVwbG95UiBzZXJ2ZXIgdG8gY2xpZW50IGFwcGxpY2F0aW9ucy4gTm90aWZpY2F0aW9ucyBcbiAgICogY29ycmVzcG9uZCB0byBkaXNjcmV0ZSBldmVudHMgdGhhdCBvY2N1ciB3aXRoaW4gdGhlIERlcGxveVIgc2VydmVyLiBUaGVyZSBcbiAgICogYXJlIGZvdXIgZGlzdGluY3QgZXZlbnQgY2F0ZWdvcmllczpcbiAgICogXG4gICAqIC0gU3RyZWFtIExpZmVjeWNsZSBldmVudHNcbiAgICogLSBFeGVjdXRpb24gZXZlbnRzXG4gICAqIC0gSm9iIExpZmVjeWNsZSBldmVudHNcbiAgICogLSBNYW5hZ2VtZW50IGV2ZW50c1xuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGBcbiAgICogZGVwbG95ci5lcyh7IHVzZXJuYW1lOiAndGVzdHVzZXInLCBwYXNzd29yZDogJ3NlY3JldCcgfSlcbiAgICogICAgLy8gLS0gY29ubmVjdGlvbiBjaG9pY2VzIGZvciBldmVudCB0eXBlcyAtLVxuICAgKiAgICAubWFuYWdlbWVudCgpICAvLy5zZXNzaW9uKCkgfCAuYWxsKCkgfCAucHJvamVjdChpZCkgfCAuam9iKGlkKVxuICAgKiAgICAub24oJ2VzOmdyaWRIZWFydGJlYXQnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAqICAgICAgICBjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PT09PScpO1xuICAgKiAgICAgICAgY29uc29sZS5sb2coJ2VzOmdyaWRIZWFydGJlYXQnKTtcbiAgICogICAgICAgIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09PT09Jyk7ICAgICAgICAgIFxuICAgKiAgICAgfSlcbiAgICogICAgIC5vcGVuKCk7XG4gICAqIGBgYFxuICAgKiBcbiAgICogQG1ldGhvZCBlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IGxpdGVyYWwgY29uZmlndXJhdGlvbiBoYXNoLiBcbiAgICogQHN0YXRpY1xuICAgKiBAcmV0dXJuIHtFdmVudFN0cmVhbX0gYSBuZXcgYEV2ZW50U3RyZWFtYCBmb3IgYmluZGluZy5cbiAgICogQGFwaSBwdWJsaWMgICBcbiAgICovICBcbiAgZXM6IGZ1bmN0aW9uKG9wdGlvbnMpIHsgICAgXG4gICAgdmFyIHN0cmVhbSA9IEV2ZW50U3RyZWFtLm5ldyhnbG9iYWxPcHRpb25zLmhvc3QsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51c2VybmFtZSAmJiBvcHRpb25zLnBhc3N3b3JkKSB7XG4gICAgICB2YXIgcnVzZXIgPSB0aGlzLmF1dGgob3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZCk7XG4gICAgICBydXNlci5lbnN1cmUoZnVuY3Rpb24oKSB7IFxuICAgICAgICBzdHJlYW0uc2hhcmUocnVzZXIuZ2V0Q29va2llcygpKTtcbiAgICAgICAgc3RyZWFtLmZsdXNoKCk7IFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgZmFjdG9yeSBmb3IgY3JlYXRpbmcgYSBEZXBsb3lSLXNwZWNpZmljIGVuY29kZWQgUiBvYmplY3QgdG8gYmUgXG4gICAqIHNlbnQgYXMgaW5wdXQgcGFyYW1ldGVycyB0byBhbiBSIHNjcmlwdC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqICAgIHZhciByaW5wdXQgPSBkZXBsb3lyLlJJbnB1dC5sb2dpY2FsKCdsb2dpY2FsX25hbWUnLCB0cnVlKTtcbiAgICogICAgdmFyIHJpbnB1dCA9IGRlcGxveXIuUklucHV0Lm51bWVyaWMoJ251bWVyaWNfbmFtZScsIDEwLjUpO1xuICAgKiAgICB2YXIgcmlucHV0ID0gZGVwbG95ci5SSW5wdXQuaW50ZWdlcignaW50ZWdlcl9uYW1lJywgNSk7XG4gICAqICAgIHZhciByaW5wdXQgPSBkZXBsb3lyLlJJbnB1dC5jaGFyYWN0ZXIoJ2NoYXJhY3Rlcl9uYW1lJywgJ0hlbGxvJyk7XG4gICAqICAgIC8vIGVjdC4uLlxuICAgKiBgYGBcbiAgICogQHByb3BlcnR5IFJJbnB1dFxuICAgKiBAc3RhdGljXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBSSW5wdXQ6IHtcbiAgICBudW1lcmljOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5udW1lcmljKCk7XG4gICAgfSxcblxuICAgIGludGVnZXI6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmludGVnZXIoKTtcbiAgICB9LFxuXG4gICAgbG9naWNhbDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkubG9naWNhbCgpO1xuICAgIH0sXG5cbiAgICBjaGFyYWN0ZXI6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmNoYXJhY3RlcigpO1xuICAgIH0sXG5cbiAgICBkYXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5kYXRlKCk7XG4gICAgfSxcblxuICAgIHBvc2l4Y3Q6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLnBvc2l4Y3QoKTtcbiAgICB9LCAgXG5cbiAgICBudW1lcmljVmVjdG9yOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLm51bWVyaWNWZWN0b3IoKTtcbiAgICB9LCBcblxuICAgIGludGVnZXJWZWN0b3I6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmludGVnZXJWZWN0b3IoKTtcbiAgICB9LFxuXG4gICAgbG9naWNhbFZlY3RvcjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IFxuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmxvZ2ljYWxWZWN0b3IoKTtcbiAgICB9LFxuXG4gICAgY2hhcmFjdGVyVmVjdG9yOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHsgXG4gICAgICByZXR1cm4gUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkuY2hhcmFjdGVyVmVjdG9yKCk7XG4gICAgfSwgIFxuXG4gICAgZGF0ZVZlY3RvcjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IFxuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmRhdGVWZWN0b3IoKTtcbiAgICB9LCAgXG5cbiAgICBwb3NpeGN0VmVjdG9yOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHsgXG4gICAgICByZXR1cm4gUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkucG9zaXhjdFZlY3RvcigpO1xuICAgIH0sXG5cbiAgICBsaXN0OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5saXN0KCk7IFxuICAgIH0sXG5cbiAgICBkYXRhZnJhbWU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5kYXRhZnJhbWUoKTtcbiAgICB9LFxuICBcbiAgICBmYWN0b3I6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgbGV2ZWxzLCBsYWJlbHMpIHtcbiAgICAgIHZhciBvcHRzID0geyBsZXZlbHM6IGxldmVscywgbGFiZWxzOiBsYWJlbHMgfTtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlLCBvcHRzKS5mYWN0b3IoKTtcbiAgICB9LFxuXG4gICAgb3JkZXJlZDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBsZXZlbHMsIGxhYmVscykge1xuICAgICAgdmFyIG9wdHMgPSB7IGxldmVsczogbGV2ZWxzLCBsYWJlbHM6IGxhYmVscyB9O1xuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUsIG9wdHMpLm9yZGVyZWQoKTtcbiAgICB9LFxuXG4gICAgbnVtZXJpY01hdHJpeDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IFxuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLm51bWVyaWNNYXRyaXgoKTtcbiAgICB9LFxuXG4gICAgaW50ZWdlck1hdHJpeDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IFxuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmludGVnZXJNYXRyaXgoKTtcbiAgICB9LFxuXG4gICAgbG9naWNhbE1hdHJpeDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IFxuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmxvZ2ljYWxNYXRyaXgoKTtcbiAgICB9LFxuXG4gICAgY2hhcmFjdGVyTWF0cml4OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5jaGFyYWN0ZXJNYXRyaXgoKTtcbiAgICB9XG4gIH1cbn07Il19
},{"./apis.json":20,"./lib/deprecated":22,"./lib/emitter":23,"./lib/encoder":24,"./lib/es":25,"./lib/lang":26,"./lib/logger":27,"./lib/queue":29,"./lib/rinput":30,"./lib/rinputs":31,"./lib/selfish":33,"./lib/utils":34,"_process":18,"d.js":19,"fs":17,"superagent":35}],22:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */
var Lang = require('./lang'),
    Base = require('./selfish').Base,
    RInput = require('./rinput');

var Deprecated,
    emitter,
    _config = {},
    TOPLEVEL_ENTITIES = [
        'user',
        'project',
        'workspace',
        'execution',
        'directory',
        'repository',
        'packages'
    ];

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/

var SessionManager = {
    ENDPOINT_WHITELIST: {
        login: '/r/user/login',
        logout: '/r/user/logout',
        projectCreate: '/r/project/create',
        projectClose: '/r/project/close',
        projectAboutUpdate: '/r/project/about/update',
        projectSave: '/r/project/save',
        projectSaveAs: '/r/project/saveas',
        // --- private APIS ---
        clientProjectSave: '/r/client/project/save',
        clientProjectClose: '/r/client/project/close'
    },

    session: {},

    config: {},

    setUnloadConfig: function(config) {
        config = config || {};
        this.config = {
            disableautosave: config.disableautosave || true,
            dropworkspace: config.dropworkspace || true,
            dropdirectory: config.dropdirectory || true,
            drophistory: config.drophistory || true,
            flushhistory: config.flushhistory || true
        };
    },
    setSession: function(session) {
        this.session = session;
    },
    setProject: function(project) {
        this.session.project = project;
    },
    clearSession: function() {
        this.session = {};
    },
    clearProject: function() {
        this.session.project = null;
    },
    unloadHandler: function() {
        try {
            var project = this.session.project;
            if (project) {

                var data = this._config;
                data.project = project.id;
                data.projectcookie = project.cookie;

                deployr.io('/r/project/close')
                    .data(data)
                    .sync()
                    .end();
            }
        } catch (e) {
            throw new Error(e);
        }
    }
};

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/

function format(response, transEntity) {
    // -- transaction entity formats override global entity formats --  
    //var format = transEntity || _config.entity;
    var format = transEntity || globalConfig.entity;

    if (format) {
        var resObj = response.deployr.response,
            // -- top-level entities --
            entities = TOPLEVEL_ENTITIES;

        for (var index = 0; index < entities.length; index++) {
            var entity = entities[index];

            if (resObj[entity] && format[entity]) { // response entity hit
                // -- user-defined parse for top-level entity --                
                if (format[entity].parser) {
                    var formatScope = format[entity].scope || this;
                    resObj[entity] = format[entity].parser.call(formatScope, resObj[entity]);
                }
            }
        }
    }

    return response;
}

function changeEndpoint(response, endpoint, args) {

    var resObj = response.deployr.response,
        ENDPOINT = SessionManager.ENDPOINT_WHITELIST;

    switch (endpoint) {

        case ENDPOINT.login:

            SessionManager.setSession({
                httpcookie: resObj.httpcookie,
                user: resObj.user,
                limits: resObj.limits,
                project: null
            });
            break;

        case ENDPOINT.logout:
            SessionManager.clearSession();
            break;

        case ENDPOINT.projectClose:
        case ENDPOINT.clientProjectClose:
            SessionManager.clearProject();
            break;

        case ENDPOINT.projectCreate:
        case ENDPOINT.projectAboutUpdate:
        case ENDPOINT.projectSave:
        case ENDPOINT.projectSaveAs:
        case ENDPOINT.clientProjectSave:
            var project = resObj.project;
            SessionManager.setProject({
                id: project.project,
                cookie: project.cookie
            });
            break;

    } // end switch

    Deprecated.Event.fire('DeployR:endpointChange', {
        response: response,
        endpoint: endpoint,
        args: args
    });
}


function camelCase(input) {
    // convert format: '/r/user/login' --> 'userLogin'
    input = input.replace('\/r\/', '');
    return input.toLowerCase().replace(/\/(.)/g, function(match, segment) {
        return segment.toUpperCase();
    });
}

// turn the old deprecated inputs into new inputs
function normalizeInputs(inputs) {
    var rinputs = [];

    for (var i = 0; i < inputs.length; i++) {
        rinputs.push(inputs[i].normalize());
    }

    return rinputs;
}

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/

/**
 * The Deprecated interface.
 */
var RData = Base.extend({
    initialize: function(type, rclass, rinput) {
        this.type = type;
        this.rclass = rclass;
        this.rinput = rinput;
    },

    getType: function() {
        return this.type;
    },

    getRClass: function() {
        return this.rclass;
    },

    getName: function() {
        return this.rinput.name;
    },

    getValue: function() {
        return this.rinput.value;
    },

    getLevels: function() {
        return this.rinput.levels;
    },

    getLabels: function() {
        return this.rinput.labels;
    },

    getOrdered: function() {
        return this.rinput.ordered;
    },

    normalize: function() {
        return this.rinput;
    }
});

/**********************************************************************/
/**********************************************************************/
/**********************************************************************/

function Emitter(obj) {  
  
}

function debug(msg) {  
}

Emitter.prototype = {

  events: {},

  scope: null,

  /**
   * Adds a listener.  Multiple can be added per name.  Aliased as `on`.
   *
   * @param {String} name The name of the event
   * @param {Function} handler A callback
   */
  on: function(name, handler) {
    if (name in this.events === false) { this.events[name] = []; }        

    this.events[name].push(handler);
    debug('Emitter.on("' + name + '")');

    return this;
  },

  /**
   * Triggers all matching listeners.
   *
   * @param {String} name The name of the event
   * @returns {Boolean} `true` if an event fired
   */
  emit: function(name) {
    if (name in this.events === false) { return this; }

    for (var i = 0; i < this.events[name].length; i++) {
      debug('Fired event: "' + name + '"');
      this.events[name][i].apply(this.scope || this, Array.prototype.slice.call(arguments, 1));       
    }

    return this;
  },

  /**
   * Removes all matching listeners.
   *
   * @param {String} name The name of the event
   * @returns {Boolean} `true` if an event was removed
   */
  removeAllListeners: function(name) {
    if (!name) {
      for (var e in this.events) {
        delete this.events[e];
      }
    } else {
      if (name in this.events === false) { return this; }
      delete this.events[name];        
    }

    return this;
  },

  removeListenerAt: function(name, index) {
    var array = this.events[name],
        rest = array.slice(index + 1);

    array.length = index;
    array.push.apply(array, rest);
    this.events[name] = array;
  },

  /**
   * Removes a listener based on the handler function.
   *
   * @param {String} name The name of the event
   * @param {Function} handler The handler function to remove
   * @returns {Boolean} `true` if an event was removed
   */
  off: function(name, handler) {
    if (name in this.events === false) { return this; }

    // remove all events handlers by this name
    if (!handler) {
      return this.removeAllListeners(name);
    } else { // remove all events handlers == 'handler' by this name
      for (var i = 0; i < this.events[name].length; i++) {
        if (this.events[name][i] == handler) {
          this.removeListenerAt(name, i);
          return this;
        }
      }
    } 

    return this;
  }
};


emitter = new Emitter();

/**
 * Provides simple adapter methods which wrap the raw <code>Revolution.DeployR.io(...)</code>
 * remote DeployR API AJAX transactions. These methods are an opt-in feature to
 * complement the low level DeployR IO communication.
 *
 * @class Revolution.DeployR.PublicAdapter
 * @extensionfor Revolution.DeployR
 */

Deprecated = {
    version: require('../package').version,

    Event: {
        on: function(type, fn, scope) {
            emitter.on(type, fn, scope);
        },

        detach: function(type, fn, obj) {
            emitter.off(type, fn);            
        }
    },

    RDataFactory: {
        createNumeric: function(name, value) {
            return RData.new('primitive', 'numeric', RInput.new(name, value).numeric());
        },

        createInteger: function(name, value) {
            return RData.new('primitive', 'integer', RInput.new(name, value).integer());
        },

        createBoolean: function(name, value) {
            return RData.new('primitive', 'numeric', RInput.new(name, value).logical());
        },

        createString: function(name, value) {
            return RData.new('primitive', 'character', RInput.new(name, value).character());
        },

        createDate: function(name, value) {
            return RData.new('date', 'Date', RInput.new(name, value).date());
        },

        createPOSIXDate: function(name, value) {
            return RData.new('date', 'POSIXct', RInput.new(name, value).posixct());
        },

        createNumericVector: function(name, value) {
            return RData.new('vector', 'numeric', RInput.new(name, value).numericVector());
        },

        createIntegerVector: function(name, value) {
            return RData.new('vector', 'integer', RInput.new(name, value).integerVector());
        },

        createBooleanVector: function(name, value) {
            return RData.new('vector', 'logical', RInput.new(name, value).logicalVector());
        },

        createStringVector: function(name, value) {
            return RData.new('vector', 'character', RInput.new(name, value).characterVector());
        },

        createDateVector: function(name, value) {
            return RData.new('type', 'Date', RInput.new(name, value).dateVector());
        },

        createPOSIXDateVector: function(name, value) {
            return RData.new('vector', 'POSIXct', RInput.new(name, value).posixctVector());
        },

        createList: function(name, value) {
            return RData.new('list', 'list', RInput.new(name, value).list());
        },

        createDataframe: function(name, value) {
            return RData.new('dataframe', 'data.frame', RInput.new(name, value).dataframe());
        },

        createFactor: function(name, value, ordered, levels, labels) {
            var opts = {
                levels: levels,
                labels: labels
            };

            if (ordered) {
                return RData.new('factor', 'factor', RInput.new(name, value, opts).ordered());
            } else {
                return RData.new('factor', 'factor', RInput.new(name, value, opts).factor());
            }
        },

        createNumericMatrix: function(name, value) {
            return RData.new('matrix', 'matrix', RInput.new(name, value).numericMatrix());
        },

        createIntegerMatrix: function(name, value) {
            return RData.new('matrix', 'matrix', RInput.new(name, value).integerMatrix());
        },

        createBooleanMatrix: function(name, value) {
            return RData.new('matrix', 'matrix', RInput.new(name, value).logicalMatrix());
        },

        createStringMatrix: function(name, value) {
            return RData.new('matrix', 'matrix', RInput.new(name, value).characterMatrix());
        }
    }, // RDataFactory

    DeployR: {

        init: function(config) {
            config = config || {};

            // --- Assert JSDeploy compatability against the connected DeployR version ---
            if (config.compatibility) {
                //compatibilityCheck();
            }

            // --- Event registration ---
            if (config.events) {
                var events = config.events;

                // -- Manage cleanup on browser close (close project, logout, ect...)--
                if (events.unload) {
                    SessionManager.setUnloadConfig(events.unload);
                    Deprecated.Event.on('deployR:unload', SessionManager.unloadHandler, SessionManager);
                }

                // -- IO Global Events --
                if (events.globalIO) {
                    var scope = events.globalIO.scope || window,
                        lifecycle = events.globalIO.lifecycle,
                        statusCode = events.globalIO.statusCode;

                    if (lifecycle) {
                        for (var eventName in lifecycle) {
                            Deprecated.Event.on('deployR-io:' + eventName, lifecycle[eventName], scope);
                        }
                    }

                    if (statusCode) {
                        for (var eventName in statusCode) {
                            Deprecated.Event.on('deployR-io:' + eventName, statusCode[eventName], scope);
                        }
                    }
                }
            }

            // New API
            deployr.configure({
                host: config.deployrURI,
                cors: config.deployrURI ? true : false,
                logging: config.logging,
                sticky: true
            });
        },

        io: function(api, config, cb) {
            if (console) {
                console.warn('"' + camelCase(api) + '()" API is now deprecated.');
            }

            cb = cb || {};
            config = config || {};

            var transaction = config.transaction || {},
                transArgs = transaction['arguments'],
                statusCode = transaction.statusCode || {},
                scope = cb.scope || window,
                routputs = config.robjects,
                rinputs = config.inputs; // config.inputs = R.DeployR.parseInputs(config.inputs);

            // --- omit deprecated props ---
            if (config.transaction) {
                delete config.transaction;
            }
            if (config.method) {
                delete config.method;
            }
            if (config.on) {
                delete config.on;
            }
            if (config.format) {
                delete config.format;
            }
            if (config.inputs) {
                delete config.inputs;
            }
            if (config.robjects) {
                delete config.robjects;
            }

            // --- make the new request ---
            var io = deployr.io(api)
                .data(config || {})
                .error(function(response) {
                    // global-failure
                    emitter.emit('deployR-io:failure', [response, api, transArgs]);

                    // transaction-failure
                    if (cb.failure) {
                        cb.failure.apply(scope, [response, api, transArgs]);                        
                    }

                    // global-statusError
                    emitter.emit(('deployR-io:' + code), [response, api, transArgs]);
                });

            if (rinputs) {
                io.rinputs(normalizeInputs(rinputs));
            }
            if (routputs) {
                io.routputs(routputs);
            }
            if (transaction.sync) {
                io.sync();
            }
            if (transaction.timeout) {
                io.timeout(transaction.timeout);
            }

            // --- Error status code --- //
            if (statusCode) {

                for (var eventName in statusCode) {                    
                    io.on('deployr-io:' + eventName, function(response) {
                        var cb = statusCode;
                        var statusText = response.deployr.response.error;
                        var status = response.deployr.response.errorCode;
                        cb[status].apply(scope, [response, status, statusText, api, transArgs]);
                    });
                }                

                // @@@@TODO @@@@@@
            }

            // global-start
            emitter.emit('deployR-io:start');

            /// transaction-start
            if (cb.start) {
                cb.start.apply(scope, [api, transArgs]); 
            }

            io.end(function(response) {
                // global-complete
                emitter.emit('deployR-io:complete');

                // transaction-complete
                if (cb.complete) {
                    cb.complete.apply(scope, [response, api, transArgs]); 
                }

                // entity manipulation of the response
                if (transaction.entity) {
                    response = format(response, transaction.entity);
                }

                // global-success
                emitter.emit('deployR-io:success', [response, api]);

                // transaction-success
                if (cb.success) {
                    cb.success.apply(scope, [response, api, transArgs]);                    
                }

                // global-end
                emitter.emit('deployR-io:end', [response, api]);

                // transaction-end
                if (cb.end) {
                    cb.end.apply(scope, [response, api, transArgs]); 
                }                
            });

            return io;
        },

        /**
         * Flattens a given <code>Revolution.RData</code> type into a JSON
         * string representing the expected DeployR input format.
         *
         * @method parseInputs
         * @public
         * @param {Array} rdata An Array of RData Objects to be flattened.
         * @return {String} The flattend RData JSON string representing the
         * DeployR input format.
         */
        parseInputs: function(rdata) {
            return rdata;
        },

        /////////////////////////////////////
        // Project Workspace APIs
        //////////////////////////////////////

        /**
         * This call lists the objects in the workspace for the project indicated.
         *
         * @method projectWorkspaceList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>root</dt>
         *    <dd>(optional) specifies object graph root</dd>
         *
         *    <dt>clazz</dt>
         *    <dd>(optional) specifies R class based filter</dd>
         *
         *    <dt>filter</dt>
         *    <dd>(optional) specifies R object name based filter</dd>
         *
         *    <dt>restrict</dt>
         *    <dd>
         *       (optional) if <code>true</code, limits returned objects to object
         *       types with supported RevoDeployR-encoding
         *    </dd>
         *
         *    <dt>pagesize</dt>
         *    <dd>
         *       (optional) specifies the page size for paging results in response
         *       markup
         *    </dd>
         *
         *    <dt>pageoffset</dt>
         *    <dd>
         *       (optional) specifies the page offset for paging results in response
         *       markup
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectWorkspaceList: function(config, callback) {
            return this.io('/r/project/workspace/list', config, callback);
        },

        /**
         * This call retrieves RevoDeployR-encoded objects from the workspace for the
         * specified project.
         *
         * @method projectWorkspaceGet
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>specifies a comma-separated list of object names</dd>
         *
         *    <dt>root</dt>
         *    <dd>optional) specifies object graph root</dd>
         *
         *    <dt>start</dt>
         *    <dd>optional) specifies the offset into object data</dd>
         *
         *    <dt>length</dt>
         *    <dd>optional) specifies the segment of object data to retrieve</dd>
         *
         *      <dt>infinity</dt>
         *    <dd>
         *       (optional) specifies a custom value for Infinity appearing in R
         *       object data returned on the call, otherwise Infinity is represented
         *       by 0x7ff0000000000000L
         *    </dd>
         *
         *      <dt>nan</dt>
         *    <dd>
         *       (optional) specifies custom value for NaN appearing in R object data
         *       returned on the call, otherwise NaN is represented by null
         *    </dd>
         *
         *    <dt>encodeDataFramePrimitiveAsVector</dt>
         *    <dd>
         *       (optional) if <code>true</code>, data.frame primitives are encoded
         *       vectors in R object data returned on call
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectWorkspaceGet: function(config, callback) {
            return this.io('/r/project/workspace/get', config, callback);
        },

        /**
         * This call uploads a binary object from file into the workspace for the
         * specified project.
         *
         * @method projectWorkspaceUpload
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>specifies the name of the object file</dd>
         *
         *    <dt>file</dt>
         *    <dd>file content</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectWorkspaceUpload: function(config, callback) {
            config.format = "text";
            var ioConfig = {
                data: config,
                method: "POST",
                form: {
                    id: config.formId
                },
                on: callback
            };
            return this.io('/r/project/workspace/upload', config, callback);
        },

        /**
         * This call transfers a binary object from a URL into the workspace for the
         * specified project.
         *
         * @method projectWorkspaceTransfer
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>specifies the name of the object file found on the URL</dd>
         *
         *    <dt>url</dt>
         *    <dd>specifies the URL</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectWorkspaceTransfer: function(config, callback) {
            return this.io('/r/project/workspace/transfer', config, callback);
        },

        /**
         * This call pushes a RevoDeployR-encoded object into the workspace for the
         * specified project.
         *
         * @method projectWorkspacePush
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) RevoDeployR-encoded object inputs</dd>
         *
         *    <dt>csvinputs</dt>
         *    <dd>(optional) comma-separated list of primitive name/value inputs</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectWorkspacePush: function(config, callback) {            
            return this.io('/r/project/workspace/push', config, callback);
        },

        /**
         * This call saves the workspace to a file in the working directory for the
         * specified project.
         *
         * If the name parameter is specified on the call then only the named object
         * is saved as a binary object file to the working directory. Otherwise the
         * entire contents of the workspace are saved.
         *
         * @method projectWorkspaceSave
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>(optional) specifies a named object for saving</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies a description to accompany the saved file</dd>
         *
         *    <dt>version</dt>
         *    <dd>
         *       (optional) if true, the new file will be renamed to avoid
         *       overwriting
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectWorkspaceSave: function(config, callback) {            
            return this.io('/r/project/workspace/save', config, callback);
        },

        /**
         * This call stores the workspace as a binary object to the repository.
         *
         * If the name parameter is specified on the call, then only the named object
         * is stored as a binary object in the repository. Otherwise the entire
         * contents of the workspace are stored.
         *
         * @method projectWorkspaceStore
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *      <dt>name</dt>
         *      <dd>(optional) specifies a named object for storing</dd>
         *
         *      <dt>descr</dt>
         *      <dd>(optional) specifies a description to accompany the saved file</dd>
         *
         *    <dt>tags</dt>
         *    <dd>
         *       (optional) specifies tag words to associate with the repository file
         *    </dd>
         *
         *    <dt>restricted</dt>
         *    <dd>
         *       (optional) comma-separated list of role names, which makes the file
         *       visible to authenticated users with these roles
         *    </dd>
         *
         *    <dt>shared</dt>
         *    <dd>
         *       (optional) if <code>true</code>, the file will be shared, which
         *       makes the file visible to authenticated users
         *    </dd>
         *
         *    <dt>published</dt>
         *    <dd>
         *       (optional) if <code>true</code>, the file will be published, which
         *       makes the file visible to authenticated and anonymous users
         *    </dd>
         *
         *      <dt>newversion</dt>
         *      <dd>
         *       (optional) if <code>true</code>, the new file will be renamed to
         *       avoid overwriting
         *    </dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectWorkspaceStore: function(config, callback) {
            return this.io('/r/project/workspace/store', config, callback);
        },

        /**
         * This call loads a binary object from a file in the repository into the
         * workspace for the specified project.
         *
         * @method projectWorkspaceLoad
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>repo</dt>
         *    <dd>specifies the repository name</dd>
         *
         *      <dt>filename</dt>
         *      <dd>specifies the repository file name</dd>
         *
         *    <dt>author</dt>
         *    <dd>specifies the repository file author</dd>
         *
         *      <dt>version</dt>
         *      <dd>(optional) specifies the repository file version</dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectWorkspaceLoad: function(config, callback) {
            return this.io('/r/project/workspace/load', config, callback);
        },

        /**
         * This call deletes an object from the workspace for the specified project.
         *
         * @method projectWorkspaceDelete
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>specifies the object name</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectWorkspaceDelete: function(config, callback) {            
            return this.io('/r/project/workspace/delete', config, callback);
        },

        /////////////////////////////////////
        // Project Management APIs
        /////////////////////////////////////

        /**
         * This call creates a new project for the currently authenticated user.
         * If the projectname parameter is specified on the call, then the newly
         * created project will be a persistent project . If the projectname parameter
         * is omitted on the call, then the newly created project will be a temporary
         * project. The projectdescr parameter is ignored if the projectname parameter
         * is omitted.
         *
         * The blackbox parameter ensures that calls on the temporary project are
         * limited to the Blackbox API Controls .
         *
         * Using the inputs , preloadfile , preloadobject and adopt parameters the
         * project can be pre-initialized with data in the workspace and/or working
         * directory.
         *
         * The inputs parameter allows the caller to pass RevoDeployR-encoded R object
         * values as inputs. These inputs are turned into R objects in the workspace
         * of the new R session before the call returns.
         *
         * The preloadfile parameters allow the caller to load one or more files from
         * the repository into the working directory of the new R session before the
         * call returns.
         *
         * The preloadobject parameters allow the caller to load one or more binary R
         * objects (.rData) from the repository into the workspace of the new R
         * session before the call returns.
         *
         * The adopt parameters allow the caller to load a pre-existing project
         * workspace, project working directory and/or project package dependencies
         * into the new R session before the call returns.
         *
         * @method projectCreate
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>projectname</dt>
         *    <dd>(optional) names a new persistent project</dd>
         *
         *    <dt>projectdescr</dt>
         *    <dd>(optional) describes a new persistent project</dd>
         *
         *    <dt>blackbox</dt>
         *    <dd>
         *       (optional) when enabled, a temporary project is limited to blackbox
         *       API controls
         *    </dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) RevoDeployR-encoded inputs</dd>
         *
         *    <dt>csvinputs</dt>
         *    <dd>(optional) comma-separated list of primitive name/value inputs</dd>
         *
         *    <dt>preloadfilename</dt>
         *    <dd>(optional) comma-separated list of repository filenames</dd>
         *
         *    <dt>preloadfileauthor</dt>
         *    <dd>
         *       (optional) comma-separated list of authors,
         *       author-per-preloadfilename
         *    </dd>
         *
         *    <dt>preloadfileversion</dt>
         *    <dd>
         *       (optional) comma-separated list of versions,
         *       version-per-preloadfilename
         *    </dd>
         *
         *    <dt>preloadobjectname</dt>
         *    <dd>
         *       (optional) comma-separated list of repository object (.rData)
         *       filenames
         *    </dd>
         *
         *    <dt>preloadobjectauthor</dt>
         *    <dd>
         *       (optional) comma-separated list of authors,
         *       author-per-preloadobjectname
         *    </dd>
         *
         *    <dt>preloadobjectversion</dt>
         *    <dd>
         *       (optional) comma-separated list of versions,
         *       version-per-object-preloadobjectname
         *    </dd>
         *
         *    <dt>adoptworkspace</dt>
         *    <dd>
         *       (optional) identifies the project whose workspace is to be adopted
         *    </dd>
         *
         *    <dt>adoptdirectory</dt>
         *    <dd>
         *       (optional) identifies the project whose directory is to be adopted
         *    </dd>
         *
         *    <dt>adoptpackages</dt>
         *    <dd>
         *       (optional) identifies the project whose package dependencies are to
         *       be adopted
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectCreate: function(config, callback) {
            return this.io('/r/project/create', config, callback);            
        },

        /**
         * This call creates a pool of temporary projects for the currently
         * authenticated user. The caller can specify their preferred number of
         * projects to create using the poolsize parameter. RevoDeployR will attempt
         * to create up to poolsize number of projects. However, standard com
         * policy contraints apply to individual users and on the grid so there is no
         * guarantee that poolsize projects will be returned. If the number of
         * projects returned on this call is less than poolsize the caller can inspect
         * the error and errorCode properties in the response markup to determine
         * exactly why their pool size was limited.
         *
         * The blackbox parameter ensures that calls on each project in the pool are
         * limited to the Blackbox API Controls .
         *
         * Using the inputs, preloadfile, preloadobject and adopt parameters each
         * project in the pool can be pre-initialized with data in the workspace
         * and/or working directory.
         *
         * The inputs parameter allows the caller to pass RevoDeployR-encoded R object
         * values as inputs. These inputs are turned into R objects in the workspace
         * of the new R session before the call returns.
         *
         * The preloadfile parameters allow the caller to load one or more files from
         * the repository into the working directory of the new R session before the
         * call returns.
         *
         * The preloadobject parameters allow the caller to load one or more binary R
         * objects (.rData) from the repository into the workspace of the new R
         * session before the call returns.
         *
         * The adopt parameters allow the caller to load a pre-existing project
         * workspace, project working directory and/or project package dependencies
         * into the new R session before the call returns.
         *
         * @method projectPool
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>poolsize</dt>
         *    <dd>the preferred size of the pool of temporary projects</dd>
         *    <dt>blackbox</dd>
         *    <dd>(optional) when enabled, each temporary project in the pool is limited to blackbox API controls</dd>
         *    <dt>inputs</dt>
         *    <dd>(optional) RevoDeployR-encoded inputs</dd>
         *    <dt>preloadfilename</dt>
         *    <dd>(optional) comma-separated list of repository filenames</dd>
         *    <dt>preloadfileauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadfilename</dd>
         *    <dt>preloadfileversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-preloadfilename</dd>
         *    <dt>preloadobjectname</dt>
         *    <dd>(optional) comma-separated list of repository object (.rData) filenames</dd>
         *    <dt>preloadobjectauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadobjectname</dd>
         *    <dt>preloadobjectversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-object-preloadobjectname</dd>
         *    <dt>adoptworkspace</dt>
         *    <dd>(optional) identifies project from which workspace is to be adopted</dd>
         *    <dt>adoptdirectory</dt>
         *    <dd>(optional) identifies project from which directory is to be adopted</dd>
         *    <dt>adoptpackages</dt>
         *    <dd>(optional) identifies project from which package dependencies are to be adopted</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectPool: function(config, callback) {
            return this.io('/r/project/pool', config, callback);
        },

        /**
         * This call recycles the R session associated with the project by deleting
         * all R objects from the workspace and all files from the working directory.
         *
         * Recycling a project is a convenient and efficient alternative to starting
         * over by closing an existing project and then creating a new project.
         *
         * @method projectRecycle
         * @static
         * @param {Object} config the call configuration. The configuration object
         * supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *    <dt>preserveworkspace</dt>
         *    <dd>(optional) if true, the objects in the workspace are preserved on recycle</dd>
         *    <dt>preservedirectory</dt>
         *    <dd>(optional) if true, the files in the working directory are preserved on recycle</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectRecycle: function(config, callback) {
            return this.io('/r/project/recycle', config, callback);
        },

        /**
         * This call lists all projects owned by the currently authenticated user
         * and/or all projects shared by other users.
         *
         * Shared projects are available as read-only projects to the caller. The
         * shared or private nature of a project can be controlled using the
         * <code>/r/project/about/update</code> call
         * <a href="#method_projectAboutUpdate">projectAboutUpdate</a>.
         *
         * @method projectList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>sharedprojectsalso</dt>
         *    <dd>
         *       (optional) when true, the project response list contains the caller's
         *       projects plus projects shared by other users
         *    </dd>
         *
         *    <dt>sharedprojectsonly</dt>
         *    <dd>
         *       (optional) when true, the project response list contains only
         *       projects shared by other users and not the users's own projects
         *    </dd>
         *
         *    <dt>isordered</dt>
         *    <dd>
         *       (optional) when true, the project response list is ordered in a
         *       most-recently-modified first order. Otherwise the list is ordered
         *       chronologically by creation date
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectList: function(config, callback) {
            return this.io('/r/project/list', config, callback);
        },
        /**
         * This call pings the specified project to determine if the project is live
         * on the RevoDeployR grid.
         *
         * @method projectPing
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         *  <dl>
         *      <dt>project</dt>
         *      <dd>specifies the project identifier</dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectPing: function(config, callback) {
            return this.io('/r/project/ping', config, callback);
        },

        /**
         * This call retrieves a set of properties that describe the specified
         * project.
         *
         * @method projectAbout
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectAbout: function(config, callback) {
            return this.io('/r/project/about', config, callback);
        },

        /**
         * This call updates a set of properties that describe the specified project.
         *
         * @method projectAboutUpdate
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>specifies the project name</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies the project description</dd>
         *
         *    <dt>longdescr</dt>
         *    <dd>(optional) specifies the project long description</dd>
         *
         *    <dt>shared</dt>
         *    <dd>
         *       (optional) if <code>true</code>, specifies that the project is a
         *       shared project
         *    </dd>
         *
         *    <dt>projectcookie</dt>
         *    <dd>
         *       (optional) specifies a client-application specific project cookie
         *    </dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectAboutUpdate: function(config, callback) {
            return this.io('/r/project/about/update', config, callback);
        },

        /**
         * This call saves the persistent state of the project indicated.
         *
         * The set of drop parameters allows the caller to selectively drop aspects,
         * such as workspace, working directory, or execution history of the project
         * state when saving. The flushhistory parameter allows the caller to preserve
         * the project execution history itself while destroying all generated console
         * output and results associated with that history.
         *
         * @method projectSave
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>(optional) specifies the project name</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies the project description</dd>
         *
         *    <dt>longdescr</dt>
         *    <dd>(optional) specifies the project long description</dd>
         *
         *    <dt>shared</dt>
         *    <dd>(optional) if true, specifies the project is a shared project</dd>
         *
         *    <dt>projectcookie</dt>
         *    <dd>(optional) specifies a client-application specific project cookie</dd>
         *
         *    <dt>dropworkspace</dt>
         *    <dd>(optional) if true, the content of the project's workspace is dropped on save</dd>
         *
         *    <dt>dropdirectory</dt>
         *    <dd>(optional) if true, the content of the project's working directory is dropped on save</dd>
         *
         *    <dt>drophistory</dt>
         *    <dd>(optional) if true, the project's execution history is dropped on save</dd>
         *
         *    <dt>flushhistory</dt>
         *    <dd>(optional) if true, the project's execution history is flushed on save</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectSave: function(config, callback) {
            return this.io('/r/project/save', config, callback);
        },

        /**
         * This call saves the persistent state of the specified project to a new
         * persistent project.
         *
         * The set of drop parameters allows the caller to selectively drop aspects,
         * such as workspace, working directory, or execution history of the project
         * state when saving to the new project. The flushhistory parameter allows the
         * caller to preserve the project execution history itself for the new project
         * while dropping all generated console output and results associated with the
         * original history.
         *
         * @method projectSaveas
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>specifies the new project name</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies the new project description</dd>
         *
         *    <dt>longdescr</dt>
         *    <dd>(optional) specifies the new project long description</dd>
         *
         *    <dt>shared</dt>
         *    <dd>(optional) if true, specifies the new project is a shared project</dd>
         *
         *    <dt>projectcookie</dt>
         *    <dd>(optional) specifies a client-application specific cookie for the new project</dd>
         *
         *    <dt>dropworkspace</dt>
         *    <dd>(optional) if true, the content of the original project's workspace is dropped when saving to the new project</dd>
         *
         *    <dt>dropdirectory</dt>
         *    <dd>(optional) if true, the content of the project's working directory is dropped when saving to the new project</dd>
         *
         *    <dt>drophistory</dt>
         *    <dd>(optional) if true, the project's execution history is dropped when saving to the new project</dd>
         *
         *    <dt>flushhistory</dt>
         *    <dd>(optional) if true, the project's execution history is flushed when saving to the new project</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectSaveas: function(config, callback) {
            return this.io('/r/project/saveas', config, callback);
        },

        /**
         * This call closes the project indicated.
         *
         * Closing a live project releases all resources associated with the project
         * on the RevoDeployR grid. If the specified project is a persistent project
         * then the default autosave semantics will cause the project to be saved
         * automatically. The caller can override that default behavior using the
         * disableautosave parameter.
         *
         * The set of drop parameters allow the caller to selectively drop aspects,
         * such as workspace, working directory, or execution history, of the project
         * state when closing. The flushhistory parameter allows the caller to
         * preserve the project execution history itself while destroying all
         * generated console output and results associated with that history.
         *
         * @method projectClose
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies project identifier</dd>
         *
         *    <dt>disableautosave</dt>
         *    <dd>(optional) if true, the default autosave semantics for persistent projects are disabled</dd>
         *
         *    <dt>projectcookie</dt>
         *    <dd>(optional) specifies a client-application specific project cookie</dd>
         *
         *    <dt>dropworkspace</dt>
         *    <dd>(optional) if true, the content of the project's workspace is dropped on close</dd>
         *
         *    <dt>dropdirectory</dt>
         *    <dd>(optional) if true, the content of the project's working directory is dropped on close</dd>
         *
         *    <dt>drophistory</dt>
         *    <dd>(optional) if true, the project's execution history is dropped on close</dd>
         *
         *    <dt>flushhistory</dt>
         *    <dd>(optional) if true, the project's execution history is flushed on close</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectClose: function(config, callback) {
            return this.io('/r/project/close', config, callback);
        },

        /**
         * This call grants authorship of the specified project to other users.
         *
         * @method projectGrant
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>newauthor</dt>
         *    <dd>
         *       specifies a comma-separated list of usernames indicating the new
         *       owners
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectGrant: function(config, callback) {
            return this.io('/r/project/grant', config, callback);
        },

        /**
         * This call imports the specified project archive as a new persistent
         * project.
         *
         * @method projectImport
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>name</dt>
         *    <dd>specifies the name of the project archive file</dd>
         *
         *    <dt>file</dt>
         *    <dd>...file content...</dd>
         *
         *    <dt>descr</dt>
         *    <dd>
         *       (optional) specifies a description for the newly imported project
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectImport: function(config, callback) {
            config.format = "text";
            var ioConfig = {
                data: config,
                method: "POST",
                form: {
                    id: config.formId
                },
                on: callback
            };
            return this.io('/r/project/import', config, callback);
        },
        /**
         * This call exports a compressed archive file for the specified project.
         *
         * The set of drop parameters allow the caller to selectively drop aspects,
         * such as workspace, working directory, or execution history of the project
         * state when generating the archive. The flushhistory parameter allows the
         * caller to preserve the project execution history itself while excluding all
         * generated console output and results associated with that history.
         *
         * @method projectExport
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies project identifier</dd>
         *
         *    <dt>dropworkspace</dt>
         *    <dd>(optional) if true, the content of the project's workspace is dropped on export</dd>
         *
         *    <dt>dropdirectory</dt>
         *    <dd>(optional) if true, the content of the project's working directory is dropped on export</dd>
         *
         *    <dt>drophistory</dt>
         *    <dd>(optional) if true, the project's execution history is dropped on export</dd>
         *
         *    <dt>flushhistory</dt>
         *    <dd>(optional) if true, the project's execution history is flushed on export</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExport: function(config, callback) {
            return this.io('/r/project/export', config, callback);
        },

        /**
         * This call deletes the specified project.
         * Deleting a project is a permanent operation that cannot be undone or
         * recovered.
         *
         * @method projectDelete
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies project identifier</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDelete: function(config, callback) {
            return this.io('/r/project/delete', config, callback);
        },

        /////////////////////////////////////
        // Project Execution APIs
        /////////////////////////////////////

        /**
         * This call executes a block of R code on the R session identified by the
         * project parameter.
         *
         * Please note the following pre and post execution parameters:
         *
         * <strong>Pre-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The inputs parameter allows the caller to pass RevoDeployR-encoded
         *       R object values as inputs. These inputs are turned into R objects
         *       in the workspace before the execution begins.
         *    </li>
         *    <li>
         *       The preloadfile parameters allows the caller to load one or more
         *       files from the repository into the working directory before the
         *       execution begins.
         *    </li>
         *    <li>
         *       The preloadobject parameters allow the caller to load one or more
         *       binary R objects (.rData) from the repository into the workspace
         *       before the execution begins.
         *    </li>
         *    <li>
         *       The adopt parameters allow the caller to load a pre-existing
         *       project workspace, project working directory and/or project package
         *       dependencies before the execution begins.
         *    </li>
         * </ol>
         *
         * <strong>Post-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The robjects parameter allows the caller to specify a comma-separated
         *       list of object names that will be returned as RevoDeployR-encoded R
         *       objects on the response markup after the execution completes.
         *    </li>
         *    <li>
         *       The storefile parameter allows the caller specify a comma-separated
         *       list of working directory files to be stored in the repository after
         *       the execution completes.
         *    </li>
         *    <li>
         *       The storeobject parameter allows the caller specify a comma-separated
         *       list of workspace objects to be stored in the repository after the
         *       execution completes.
         *    </li>
         *    <li>
         *       The storeworkspace parameter allows the caller to store the entire
         *       workspace in the repository after the execution completes.
         *    </li>
         *    <li>
         *       The storedirectory parameter allows the caller to specify a target
         *       repository directory for stored files and objects after the execution
         *       completes.
         *    </li>
         *    <li>
         *       The storenewversion parameter allows the caller to create new
         *       versions of each stored file in the repository after the execution
         *       completes. By default, stored files overwrite any pre-existing file
         *       by the same name.
         *    </li>
         *    <li>
         *       The storepublic parameter allows the caller to assign public access
         *       to each stored file in the repository after the execution completes.
         *    </li>
         * </ol>
         *
         *  <strong>Some key data indicated in the response markup on this call:</strong>
         *
         * <ol>
         *    <li>code - indicates the code that has been executed</li>
         *    <li>
         *       console - indicates the console output resulting from the code
         *       execution
         *    </li>
         *    <li>
         *       results - indicates the list of files generated by the R graphics
         *       device
         *    </li>
         *    <li>
         *       artifacts - indicates the list of files generated or modified in the
         *       working directory
         *    </li>
         *    <li>
         *       objects -  indicates the list of R objects returned from the
         *       workspace
         *    </li>
         *    <li>
         *       files - indicates the list of files and objects stored in the
         *       repository after the execution completes
         *    </li>
         *    <li>
         *       interrupted - indicates the interrupted status of execution
         *    </li>
         *    <li>
         *       error - on failure, indicates the reason for failure
         *    </li>
         *    <li>
         *       errorCode - on failure, indicates the error code for failure
         *    </li>
         * </ol>
         *
         * @method projectExecuteCode
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>code</dt>
         *    <dd>specifies the block of R code</dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) RevoDeployR-encoded script inputs</dd>
         *
         *    <dt>csvinputs</dt>
         *    <dd>(optional) comma-separated list of primitive name/value inputs</dd>
         *
         *    <dt>preloadfilename</dt>
         *    <dd>(optional) comma-separated list of repository filenames</dd>
         *
         *    <dt>preloadfileauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadfilename</dd>
         *
         *    <dt>preloadfileversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-preloadfilename</dd>
         *
         *    <dt>preloadobjectname</dt>
         *    <dd>(optional) comma-separated list of repository object (.rData) filenames</dd>
         *
         *    <dt>preloadobjectauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadobjectname</dd>
         *
         *    <dt>preloadobjectversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-object-preloadobjectname</dd>
         *
         *    <dt>adoptworkspace</dt>
         *    <dd>(optional) identifies project from which workspace is to be adopted</dd>
         *
         *    <dt>adoptdirectory</dt>
         *    <dd>(optional) identifies project from which directory is to be adopted</dd>
         *
         *    <dt>adoptpackages</dt>
         *    <dd>(optional) identifies project from which package dependencies are to be adopted</dd>
         *
         *    <dt>tag</dt>
         *    <dd>(optional) specifies a tag that labels the execution</dd>
         *
         *    <dt>echooff</dt>
         *    <dd>(optional) if true R commands will not appear in the console output</dd>
         *
         *    <dt>consoleoff</dt>
         *    <dd>(optional) if true console output is not returned in the response markup</dd>
         *
         *      <dt>graphics</dt>
         *      <dd>(optional) specifies preferred R graphics device for execution: png or svg</dd>
         *
         *      <dt>graphicswidth</dt>
         *      <dd>(optional) specifies preferred width for R graphics device images</dd>
         *
         *      <dt>graphicsheight</dt>
         *      <dd>(optional) specifies preferred height for R graphics device images</dd>
         *
         *      <dt>robjects</dt>
         *      <dd>(optional) specifies a comma-separated list of objects for retrieval following the execution</dd>
         *
         *      <dt>storefile</dt>
         *      <dd>(optional) comma-separated list of working directory filenames</dd>
         *
         *      <dt>storeobject</dt>
         *      <dd>(optional) comma-separated list of workspace object names</dd>
         *
         *      <dt>storeworkspace</dt>
         *      <dd>(optional) filename (.rData) where workspace contents will be saved in the repository</dd>
         *
         *      <dt>storenewversion</dt>
         *      <dd>(optional) if <code>true</code>, ensures each file stored in
         *    repository results in new version being created if needed</dd>
         *
         *      <dt>storepublic</dt>
         *      <dd>(optional) if <code>true</code>, publishes each file stored in the repository</dd>
         *
         *      <dt>infinity</dt>
         *      <dd>(optional) specifies custom value for Infinity appearing in R object
         *    data returned on call, otherwise Infinity is represented by <code>0x7ff0000000000000L</code>
         *    </dd>
         *
         *      <dt>nan</dt>
         *      <dd>(optional) specifies custom value for NaN appearing in R object data
         *    returned on call, otherwise NaN is represented by <code>null</code></dd>
         *
         *      <dt>encodeDataFramePrimitiveAsVector</dt>
         *      <dd>(optional) if <code>true</code>, data.frame primitives are encoded vectors in R object data returned on call</dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExecuteCode: function(config, callback) {           
            return this.io('/r/project/execute/code', config, callback);
        },
        /**
         * This call executes executes repository-managed scripts or external scripts
         * on the R session identified by the project parameter.
         *
         * To execute a single repository-managed script the caller must provide
         * parameter values for filename, author and optionally version. To execute
         * a chain of repository-managed scripts the caller must provide a
         * comma-separated list of values on the filename , author and optionally
         * version parameters.
         *
         * To execute a single external script the caller must provide a valid URL or
         * file path using the externalsource parameter. To execute a chain of
         * external scripts the caller must provide a comma-separated list of values
         * on the externalsource parameter. Note, to execute an external script the
         * caller must have POWER_USER privileges.
         *
         * Note: A chained execution executes each of the scripts identified on the
         * call in a sequential fashion on the R session, with execution occuring in
         * the order specified on the parameter list.
         *
         * Please not the following pre and post execution parameters:
         *
         * <strong>Pre-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The inputs parameter allows the caller to pass RevoDeployR-encoded
         *       R object values as inputs. These inputs are turned into R objects
         *       in the workspace before the execution begins.
         *    </li>
         *    <li>
         *       The preloadfile parameters allows the caller to load one or more
         *       files from the repository into the working directory before the
         *       execution begins.
         *    </li>
         *    <li>
         *       The preloadobject parameters allow the caller to load one or more
         *       binary R objects (.rData) from the repository into the workspace
         *       before the execution begins.
         *    </li>
         *    <li>
         *       The adopt parameters allow the caller to load a pre-existing
         *       project workspace, project working directory and/or project package
         *       dependencies before the execution begins.
         *    </li>
         * </ol>
         *
         * <strong>Post-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The robjects parameter allows the caller to specify a comma-separated
         *       list of object names that will be returned as RevoDeployR-encoded R
         *       objects on the response markup after the execution completes.
         *    </li>
         *    <li>
         *       The storefile parameter allows the caller specify a comma-separated
         *       list of working directory files to be stored in the repository after
         *       the execution completes.
         *    </li>
         *    <li>
         *       The storeobject parameter allows the caller specify a comma-separated
         *       list of workspace objects to be stored in the repository after the
         *       execution completes.
         *    </li>
         *    <li>
         *       The storeworkspace parameter allows the caller to store the entire
         *       workspace in the repository after the execution completes.
         *    </li>
         *    <li>
         *       The storedirectory parameter allows the caller to specify a target
         *       repository directory for stored files and objects after the execution
         *       completes.
         *    </li>
         *    <li>
         *       The storenewversion parameter allows the caller to create new
         *       versions of each stored file in the repository after the execution
         *       completes. By default, stored files overwrite any pre-existing file
         *       by the same name.
         *    </li>
         *    <li>
         *       The storepublic parameter allows the caller to assign public access
         *       to each stored file in the repository after the execution completes.
         *    </li>
         * </ol>
         *
         * <strong>
         *    Some of the key data indicated in the response markup on this call
         *    include:
         * </strong>
         *
         * <ol>
         *    <li>
         *       console - indicates the console output resulting from the script
         *       execution
         *    </li>
         *    <li>
         *       results - indicates the list of files generated by the R graphics
         *       device
         *    </li>
         *    <li>
         *       artifacts - indicates the list of files generated or modified in the
         *       working directory
         *    </li>
         *    <li>
         *       objects - indicates the list of R objects returned from the workspace
         *    </li>
         *    <li>
         *       files - indicates the list of files and objects stored in the
         *       repository after the execution completes
         *    </li>
         *    <li>interrupted - indicates the interrupted status of execution</li>
         *    <li>error - on failure, indicates the reason for failure</li>
         *    <li>errorCode - on failure, indicates the error code for failure</li>
         * </ol>
         *
         * @method projectExecuteScript
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         *  <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>(optional) comma-separated list of repository-managed script filenames</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) comma-separated list of repository-managed directories for
         *       scripts, defaults to root
         *    </dd>
         *
         *    <dt>author</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-filename</dd>
         *
         *    <dt>version</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-filename</dd>
         *
         *    <dt>externalsource</dt>
         *    <dd>(optional) comma-separated list of URLs or file paths to external scripts</dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) RevoDeployR-encoded script inputs</dd>
         *
         *    <dt>csvinputs</dt>
         *    <dd>(optional) comma-separated list of primitive name/value inputs</dd>
         *
         *    <dt>preloadfilename</dt>
         *    <dd>(optional) comma-separated list of repository filenames</dd>
         *
         *    <dt>preloadfileauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadfilename</dd>
         *
         *    <dt>preloadfileversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-preloadfilename</dd>
         *
         *    <dt>preloadobjectname</dt>
         *    <dd>(optional) comma-separated list of repository object (.rData) filenames</dd>
         *
         *    <dt>preloadobjectauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadobjectname</dd>
         *
         *    <dt>preloadobjectversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-object-preloadobjectname</dd>
         *
         *    <dt>adoptworkspace</dt>
         *    <dd>(optional) identifies project from which workspace is to be adopted</dd>
         *
         *    <dt>adoptdirectory</dt>
         *    <dd>(optional) identifies project from which directory is to be adopted</dd>
         *
         *    <dd>adoptpackages</dd>
         *    <dt>(optional) identifies project from which package dependencies are to be adopted</dt>
         *
         *    <dt>tag</dt>
         *    <dd>(optional) specifies a tag that labels the execution</dd>
         *
         *    <dt>echooff</dt>
         *    <dd>(optional) if true R commands will not appear in the console output</dd>
         *
         *    <dt>graphics</dt>
         *    <dd>(optional) specifies preferred R graphics device for execution: png or svg</dd>
         *
         *    <dt>graphicswidth</dt>
         *    <dd>(optional) specifies preferred width for R graphics device images</dd>
         *
         *    <dt>graphicsheight</dt>
         *    <dd>(optional) specifies preferred height for R graphics device images</dd>
         *
         *    <dt>robjects</dt>
         *    <dd>(optional) specifies a comma-separated list of objects for retrieval following the execution</dd>
         *
         *    <dt>storefile</dt>
         *    <dd>(optional) comma-separated list of working directory filenames</dd>
         *
         *    <dt>storeobject</dt>
         *    <dd>(optional) comma-separated list of workspace object names</dd>
         *
         *    <dt>storeworkspace</dt>
         *    <dd>(optional) filename (.rData) where workspace contents will be saved in the repository</dd>
         *
         *    <dt>storenewversion</dt>
         *    <dd>(optional) if <code>true</code>, ensures each file stored in repository results in new version being created if needed</dd>
         *
         *    <dt>storepublic</dt>
         *    <dd>(optional) if <code>true</code>, publishes each file stored in the repository</dd>
         *
         *    <dt>infinity</dt>
         *    <dd>(optional) specifies custom value for Infinity appearing in R object data returned on call, otherwise Infinity is represented by <code>0x7ff0000000000000L</code></dd>
         *
         *    <dt>nan</dt>
         *    <dd>(optional) specifies custom value for NaN appearing in R object data returned on call, otherwise NaN is represented by <code>null</code></dd>
         *
         *    <dt>encodeDataFramePrimitiveAsVector</dt>
         *    <dd>(optional) if <code>true</code>, data.frame primitives are encoded vectors in R object data returned on call</dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExecuteScript: function(config, callback) {            
            return this.io('/r/project/execute/script', config, callback);
        },

        /**
         * This call interrupts the current execution on specified project.
         *
         * @method projectExecuteInterrupt
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         *  <dl>
         *      <dt>project</dt>
         *      <dd>specifies the project identifier</dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExecuteInterrupt: function(config, callback) {
            return this.io('/r/project/execute/interrupt', config, callback);
        },

        /**
         * This call retrieves the R console output for the latest execution on
         * specified project.
         *
         * @method projectExecuteConsole
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         *  <dl>
         *    <dt>project</dt>
         *      <dd>specifies the project identifier</dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExecuteConsole: function(config, callback) {
            return this.io('/r/project/execute/console', config, callback);
        },

        /**
         * This call retrieves the execution history for the specified project.
         *
         * Some of the key data indicated for each history item in the response markup
         * on this call include:
         *
         * <ol>
         *  <li>code - indicates the code that has been executed</li>
         *  <li>console - indicates the console output resulting from the code execution</li>
         *  <li>resultsGenerated - indicates the number of generated results on the execution</li>
         *  <li>resultsAvailable - indicates the number of generated results still stored on the execution</li>
         *  <li>resourceUsage - indicates the current storage byte count for results on the execution</li>
         *  <li>execution - indicates the execution identifier, which can then be used on /r/project/execution/result calls to retrieve or manage results</li>
         *  <li>interrupted - indicates the interrupted status of execution</li>
         *  <li>error - on failure, indicates the reason for failure</li>
         *  <li>errorCode - on failure, indicates the error code for failure</li>
         * </ol>
         * @method projectExecuteHistory
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filterdepth</dt>
         *    <dd>specifies the max number of executions to be returned in the history</dd>
         *
         *    <dt>execution</dt>
         *    <dd>(optional) specifies the comma-separated list of execution identifiers on which to filter history</dd>
         *
         *    <dt>filtertag</dt>
         *    <dd>(optional) specifies the execution tag on which to filter history</dd>
         *
         *    <dt>reversed</dt>
         *    <dd>
         *       (optional) if true, the execution history is returned in a
         *       reverse-chronological order
         *    </dt>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExecuteHistory: function(config, callback) {
            return this.io('/r/project/execute/history', config, callback);
        },

        /**
         * This call flushes executions in the history on the specified project.
         * Flushing an execution deletes both the R console output and the generated
         * results associated with that execution but does not remove the execution
         * itself from the history. By omitting the execution parameter, the caller
         * can flush every execution in the history on the specified project.
         *
         * This flushing facility is provided to help users manage the levels of
         * resource usage associated with their persistent projects.
         *
         * @method projectExecuteFlush
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         *  <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>execution</dt>
         *    <dd>(optional) comma-separated list of execution identifiers</dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExecuteFlush: function(config, callback) {
            return this.io('/r/project/execute/flush', config, callback);
        },

        /**
         * This call lists the execution results for the specified project.
         *
         * By specifying a value for the execution parameter the caller can limit the
         * response to those results found on a specific execution or set of
         * executions.
         *
         * <blockquote>
         *    Important! The URLs indicated in the response markup on this call remain
         *    valid for as long as the results remain part of the project.
         * </blockquote>
         *
         * @method projectExecuteResultList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>execution</dt>
         *    <dd>
         *       (optional) specifies a comma-separated list of execution identifiers
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExecuteResultList: function(config, callback) {
            return this.io('/r/project/execute/result/list', config, callback);
        },

        /**
         * This call downloads the execution results for the specified project.
         *
         * By specifying a value for the execution parameter the caller can download
         * only results on the specified executions. By specifying a value for the
         * filename parameter the caller can download a specific result on the
         * specified execution.
         *
         * @method projectExecuteResultDownload
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>execution</dt>
         *    <dd>
         *       (optional) specifies a comma-separated list of execution identifiers
         *    </dd>
         *
         *    <dt>filename</dt>
         *    <dd>(optional) specifies a result file name</dd>
         *
         *    <dt>inline</dt>
         *    <dd>
         *       (optional) if true, the Content-Disposition response header
         *       indicating attachment is omitted
         *    </dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExecuteResultDownload: function(config, callback) {
            return this.io('/r/project/execute/result/download', config, callback);
        },

        /**
         * This call deletes the execution results for the specified project.
         *
         * By specifying a value for the execution parameter the caller can delete
         * only those results on the specified executions. By specifying a value for
         * the filename parameter the caller can delete a specific result on the
         * specified executions.
         *
         * @method projectExecuteResultDelete
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *   <dt>project</dt>
         *   <dd>specifies the project identifier</dd>
         *
         *   <dt>execution</dt>
         *   <dd>
         *      (optional) specifies a comma-separated list of execution identifiers
         *   </dd>
         *
         *   <dt>filename</dt>
         *   <dd>(optional) specifies a result file name</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectExecuteResultDelete: function(config, callback) {
            return this.io('/r/project/execute/result/delete', config, callback);
        },

        /////////////////////////////////////
        // Project Directory APIs
        /////////////////////////////////////

        /**
         * This call lists working directory files for the specified project.
         *
         * The filter parameter can be specified on the call to filter, the types of
         * files returned according to their category. The following filter values are
         * supported:
         *
         * <ol>
         *    <li>plot - files ending with a .png, .svg or .jpg extension</li>
         *    <li>script - files ending with a .R or .r extension</li>
         *    <li>R - files ending with a .rData or .rdata extension</li>
         *    <li>data - files ending with a .csv or .xls extension</li>
         *    <li>text - files ending with a .txt extension</li>
         * </ol>
         *
         * @method projectDirectoryList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filter</dt>
         *    <dd>(optional) specifies the filter by category value</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDirectoryList: function(config, callback) {
            return this.io('/r/project/directory/list', config, callback);
        },

        /**
         * This call uploads a file into the working directory for the specified
         * project.
         *
         * @method projectDirectoryUpload
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>specifies the name of the file</dd>
         *
         *    <dt>file</dt>
         *    <dd>...file content...</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies the description to be associated with file</dd>
         *
         *    <dt>overwrite</dt>
         *    <dd>(optional) if true, overwrites the existing file of same name</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDirectoryUpload: function(config, callback) {
            config.format = "text";
            var ioConfig = {
                data: config,
                method: "POST",
                form: {
                    id: config.formId
                },
                on: callback
            };
            return this.io('/r/project/directory/upload', config, callback);
        },

        /**
         * This call transfers a file from a URL into the working directory for the
         * specified project.
         *
         * @method projectDirectoryTransfer
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>specifies the name of the file</dd>
         *
         *    <dt>url</dt>
         *    <dd>specifies the URL for the file</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies the description to be associated with file</dd>
         *
         *    <dt>overwrite</dt>
         *    <dd>(optional) if true, overwrites the existing file of same name</dd>
         *  </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDirectoryTransfer: function(config, callback) {
            return this.io('/r/project/directory/transfer', config, callback);
        },

        /**
         * This call writes a text file into the working directory for the specified
         * project.
         *
         * @method projectDirectoryWrite
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>specifies the name of the file</dd>
         *
         *    <dt>text</dt>
         *    <dd>specifies the text content for the file</dd>
         *
         *    <dt>delimiter</dt>
         *    <dd>
         *       (optional) specifies a custom delimiter for text when writing
         *       multiple files, defaults to #,#
         *    </dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies the description to be associated with file</dd>
         *
         *    <dt>overwrite</dt>
         *    <dd>(optional) if true, overwrites the existing file of same name</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDirectoryWrite: function(config, callback) {
            return this.io('/r/project/directory/write', config, callback);
        },

        /** 
         * This call updates a file name and/or description in the working directory
         * for the specified project.
         *
         * @method projectDirectoryUpdate
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>specifies the name of the file</dd>
         *
         *    <dt>rename</dt>
         *    <dd>(optional) specifies the new name for the file</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifices the new description for the file</dd>
         *
         *    <dt>overwrite</dt>
         *    <dd>(optional) if true, overwrites the existing file of same name</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDirectoryUpdate: function(config, callback) {
            return this.io('/r/project/directory/update', config, callback);
        },

        /**
         * This call stores a file from the working directory to the repository.
         *
         * @method projectDirectoryStore
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>(optional) specifies the file for storing</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies a description to accompany the saved file</dd>
         *
         *    <dt>tags</dt>
         *    <dd>
         *       (optional) specifies tag words to associate with repository file
         *    </dd>
         *
         *    <dt>restricted</dt>
         *    <dd>
         *        (optional) comma-separated list of role names, which makes the file
         *        visible to authenticated users with these roles
         *    </dd>
         *
         *    <dt>shared</dt>
         *    <dd>
         *       (optional) if true, the file will be shared , which makes the file
         *       visible to authenticated users
         *    </dd>
         *
         *    <dt>published</dt>
         *    <dd>
         *       (optional) if true, the file will be published , which makes the
         *       file visible to authenticated and anonymous users
         *    </dd>
         *
         *    <dt>newversion</dt>
         *    <dd>
         *       (optional) if true, the new file will be renamed to avoid overwriting
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDirectoryStore: function(config, callback) {
            return this.io('/r/project/directory/store', config, callback);
        },

        /**
         * This call loads a file from the repository into the working directory for
         * the specified project.
         *
         * @method projectDirectoryLoad
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>specifies the repository file name</dd>
         *
         *    <dt>author</dt>
         *    <dd>specifies the author name</dd>
         *
         *    <dt>version</dt>
         *    <dd>(optional) specifies the repository file version</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDirectoryLoad: function(config, callback) {
            return this.io('/r/project/directory/load', config, callback);
        },

        /**
         * This call downloads the working directory contents for the specified
         * project.
         *
         * By specifying a single value for the filename parameter, the caller can
         * download a specific file. By specifying multiple values for the filename
         * parameter, the caller can download a zip archive of those files. By
         * omitting the filename parameter, then the caller can download a zip archive
         * with all of the files in the working directory.
         *
         * @method projectDirectoryDownload
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>(optional) specifies comma-separated file names for download</dd>
         *
         *    <dt>inline</dt>
         *    <dd>
         *       (optional) if true, the Content-Disposition response header
         *       indicating attachment is omitted
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDirectoryDownload: function(config, callback) {
            return this.io('/r/project/directory/download', config, callback);
        },

        /**
         * This call deletes files from the working directory for the specified
         * project.
         *
         * @method projectDirectoryDelete
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>specifies a comma-separated list of file names for deletion</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectDirectoryDelete: function(config, callback) {
            return this.io('/r/project/directory/delete', config, callback);
        },

        /////////////////////////////////////
        // Project Package APIs
        /////////////////////////////////////

        /**
         * This call lists R package dependencies for the specified project.
         *
         * @method projectPackageList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>installed</dt>
         *    <dd>
         *       if true, response lists all packages installed in project environment
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectPackageList: function(config, callback) {
            return this.io('/r/project/package/list', config, callback);
        },

        /**
         * This call attaches R package dependencies for the specified project.
         *
         * @method projectPackageAttach
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>specifies a comma-separated list of R package names to attach</dd>
         *
         *    <dt>repo</dt>
         *    <dd>(optional) specifies R repository location for named packages</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectPackageAttach: function(config, callback) {
            return this.io('/r/project/package/attach', config, callback);
        },

        /**
         * This call detaches R package dependencies for the specified project.
         *
         * @method projectPackageDetach
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>name</dt>
         *    <dd>specifies a comma-separated list of R package names to detach</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        projectPackageDetach: function(config, callback) {
            return this.io('/r/project/package/detach', config, callback);
        },

        /////////////////////////////////////
        // User APIs
        /////////////////////////////////////

        /**
         * This call signs the user in by authenticating the credentials with the
         * RevoDeployR server.
         *
         * @method userLogin
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>username</dt>
         *    <dd>specifies the username</dd>
         *
         *    <dt>password</dt>
         *    <dd>specifies the password</dd>
         *
         *    <dt>disableautosave</dt>
         *    <dd>
         *       (optional) when true, disables autosave semantics for persistent
         *       projects
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        userLogin: function(config, callback) {
            return this.io('/r/user/login', config, callback);            
        },

        /**
         * This call signs out the currently authenticated user.
         *
         * @method userLogout
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>usercookie</dt>
         *    <dd>
         *       (optional) when specified, value sets application-specific persistent
         *       user cookie, which is retrievable on response to
         *       <a href="#method_userLogin">userLogin</a> call.
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        userLogout: function(config, callback) {
            return this.io('/r/user/logout', config, callback);            
        },

        /**
         * This call retrieves details about the currently authenticated user. The
         * details returned in the response markup on this call are exactly the same
         * details as those returned in the response markup on the
         * <a href="#method_userLogin">userLogin</a> call.
         *
         * @method userAbout
         * @static
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        userAbout: function(callback) {            
            return this.io('/r/user/about', {}, callback);
        },

        /**
         * This call enables or disables the autosave semantics on persistent projects
         * for the duration of the current users HTTP session. By default, all live
         * persistent projects are autosaved under the following conditions:
         *
         * <ul>
         *    <li>
         *       When a user closes a project using the
         *       <a href="#method_projectClose">projectClose</a> call.
         *    </li>
         *    <li>
         *       When a user signs-out using the
         *       <a href="#method_userLogout">userLogout</a> call.
         *    </li>
         *    <li>
         *       When a user is automatically signed-out by the system after a
         *       prolonged period of inactivity.
         *    </li>
         * </ul>
         *
         * When the autosave feature is disabled a user must make an explicit call on
         * <a href="#method_projectSave">projectSave</a> in order to save a project.
         *
         * @method userAutosave
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>enable</dt>
         *    <dd>(optional) toggles autosave semantics for persistent projects.</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        userAutosave: function(config, callback) {
            return this.io('/r/user/autosave', config, callback);
        },

        /////////////////////////////////////
        // Repository Script APIs
        /////////////////////////////////////

        /**
         * This call lists repository-managed scripts.
         *
         * This call is available to authenticated and anonymous users. However, if
         * the caller is an anonymous user then only published scripts will be
         * returned in the response markup.
         *
         * @method repositoryScriptList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>filename</dt>
         *    <dd>
         *       (optional) when specified, call returns list of script versions for
         *       filename
         *   </dd>
         *
         *    <dt>shared</dt>
         *    <dd>
         *       (optional) if <code>true</code>, files that are restricted but
         *       visible or shared by other users are included in the response markup
         *    </dd>
         *
         *    <dt>published</dt>
         *    <dd>
         *       (optional) if <code>true</code>, scripts published by other users are
         *       included in the response markup
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryScriptList: function(callback) {            
            return this.io('/r/repository/script/list', {}, callback);
        },
        /**
         * This call executes repository-managed scripts or external scripts on an
         * Anonymous Project.
         *
         * To execute a single repository-managed script the caller must provide
         * parameter values for filename, author and optionally version. To execute a
         * chain of repository-managed scripts the caller must provide a
         * comma-separated list of values on the filename , author and optionally
         * version parameters.
         *
         * To execute a single external script the caller must provide a valid URL
         * or file path using the externalsource parameter. To execute a chain of
         * external scripts the caller must provide a comma-separated list of
         * values on the externalsource parameter. Note, to execute an external script
         * the caller must have POWER_USER privileges so this feature is not available
         * to anonymous users on this call.
         *
         * Note: A chained execution executes each of the scripts identified on the
         * call in a sequential fashion on the R session, with execution occuring in
         * the order specified on the parameter list.
         *
         * <strong>Pre-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The inputs parameter allows the caller to pass RevoDeployR-encoded
         *       R object values as inputs. These inputs are turned into R objects
         *       in the workspace before the execution begins.
         *    </li>
         *    <li>
         *       The preloadfile parameters allows the caller to load one or more
         *       files from the repository into the working directory before the
         *       execution begins.
         *    </li>
         *    <li>
         *       The preloadobject parameters allow the caller to load one or more
         *       binary R objects (.rData) from the repository into the workspace
         *       before the execution begins.
         *    </li>
         *    <li>
         *       The adopt parameters allow the caller to load a pre-existing
         *       project workspace, project working directory and/or project package
         *       dependencies before the execution begins.
         *    </li>
         * </ol>
         *
         * <strong>Post-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The robjects parameter allows the caller to specify a comma-separated
         *       list of object names that will be returned as RevoDeployR-encoded R
         *       objects on the response markup after the execution completes.
         *    </li>
         *    <li>
         *       The storefile parameter allows the caller specify a comma-separated
         *       list of working directory files to be stored in the repository after
         *       the execution completes.
         *    </li>
         *    <li>
         *       The storeobject parameter allows the caller specify a comma-separated
         *       list of workspace objects to be stored in the repository after the
         *       execution completes.
         *    </li>
         *    <li>
         *       The storeworkspace parameter allows the caller to store the entire
         *       workspace in the repository after the execution completes.
         *    </li>
         *    <li>
         *       The storedirectory parameter allows the caller to specify a target
         *       repository directory for stored files and objects after the execution
         *       completes.
         *    </li>
         *    <li>
         *       The storenewversion parameter allows the caller to create new
         *       versions of each stored file in the repository after the execution
         *       completes. By default, stored files overwrite any pre-existing file
         *       by the same name.
         *    </li>
         *    <li>
         *       The storepublic parameter allows the caller to assign public access
         *       to each stored file in the repository after the execution completes.
         *    </li>
         *    <li>
         *       The infinity , nan and encodeDataFramePrimitiveAsVector parameters
         *       allow the caller to control how RevoDeployR-encoded R object data is
         *       encoded in the response markkup.
         *    </li>
         * </ol>
         *
         *  <strong>
         *     Some key data indicated in the response markup on this call:
         *  </strong>
         *
         *  <ol>
         *    <li>
         *       console - indicates the console output resulting from the code
         *       execution
         *    </li>
         *    <li>
         *       results - indicates the list of files generated by the R graphics
         *       device
         *    </li>
         *    <li>
         *       artifacts - indicates the list of files generated or modified in the
         *       working directory
         *    </li>
         *    <li>
         *       objects -  indicates the list of R objects returned from the
         *       workspace
         *    </li>
         *    <li>
         *       files - indicates the list of files and objects stored in the
         *       repository after the execution completes
         *    </li>
         *    <li>interrupted - indicates the interrupted status of execution</li>
         *    <li>error - on failure, indicates the reason for failure</li>
         *    <li>errorCode - on failure, indicates the error code for failure</li>
         * </ol>
         * @method repositoryScriptExecute
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>comma-separated list of repository-managed script filenames</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) comma-separated list of repository-managed directories for
         *       scripts, defaults to root
         *    </dd>
         *
         *    <dt>author</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-filename</dd>
         *
         *    <dt>version</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-filename</dd>
         *
         *    <dt>externalsource</dt>
         *    <dd>(optional) comma-separated list of URLs or file paths to external scripts</dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) RevoDeployR-encoded script inputs</dd>
         *
         *    <dt>csvinputs</dt>
         *    <dd>(optional) comma-separated list of primitive name/value inputs</dd>
         *
         *    <dt>preloadfilename</dt>
         *    <dd>(optional) comma-separated list of repository filenames</dd>
         *
         *    <dt>preloadfileauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadfilename</dd>
         *
         *    <dt>preloadfileversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-preloadfilename</dd>
         *
         *    <dt>preloadobjectname</dt>
         *    <dd>(optional) comma-separated list of repository object (.rData) filenames</dd>
         *
         *    <dt>preloadobjectauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadobjectname</dd>
         *
         *    <dt>preloadobjectversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-object-preloadobjectname</dd>
         *
         *    <dt>adoptworkspace</dt>
         *    <dd>(optional) identifies project from which workspace is to be adopted</dd>
         *
         *    <dt>adoptdirectory</dt>
         *    <dd>(optional) identifies project from which directory is to be adopted</dd>
         *
         *    <dt>adoptpackages</dt>
         *    <dd>(optional) identifies project from which package dependencies are to be adopted</dd>
         *
         *    <dt>blackbox</dt>
         *      <dd>
         *       (optional) if true, the execution will occur on the HTTP blackbox
         *       project for the current HTTP session
         *    </dd>
         *
         *      <dt>recycle</dt>
         *      <dd>
         *       (optional) if true, recycles the R session associated with the HTTP
         *       blackbox project on the current HTTP session
         *    </dd>
         *
         *    <dt>tag</dt>
         *    <dd>(optional) specifies a tag that labels the execution</dd>
         *
         *    <dt>echooff</dt>
         *    <dd>(optional) </dd>
         *
         *    <dt>graphics</dt>
         *    <dd>(optional) specifies preferred R graphics device for execution: png or svg</dd>
         *
         *    <dt>graphicswidth</dt>
         *    <dd>(optional) specifies preferred width for R graphics device images</dd>
         *
         *    <dt>graphicsheight</dt>
         *    <dd>(optional) specifies preferred height for R graphics device images</dd>
         *
         *    <dt>robjects</dt>
         *    <dd>(optional) specifies a comma-separated list of objects for retrieval following the execution</dd>
         *
         *    <dt>storefile</dt>
         *    <dd>(optional) comma-separated list of working directory filenames</dd>
         *
         *    <dt>storeobject</dt>
         *    <dd>(optional) comma-separated list of workspace object names</dd>
         *
         *    <dt>storeworkspace</dt>
         *    <dd>(optional) filename (.rData) where workspace contents will be saved in the repository</dd>
         *
         *    <dt>storenewversion</dt>
         *    <dd>(optional) if <code>true</code>, ensures each file stored in repository results in new version being created if needed</dd>
         *
         *    <dt>storepublic</dt>
         *    <dd>(optional) if <code>true</code>, publishes each file stored in the repository</dd>
         *
         *    <dt>infinity</dt>
         *    <dd>
         *       (optional) specifies custom value for Infinity appearing in R object
         *       data returned on call, otherwise Infinity is represented by
         *       <code>0x7ff0000000000000L</code>
         *    </dd>
         *
         *    <dt>nan</dt>
         *    <dd>
         *       (optional) specifies custom value for NaN appearing in R object data
         *       returned on call, otherwise NaN is represented by <code>null</code>
         *    </dd>
         *
         *    <dt>encodeDataFramePrimitiveAsVector</dt>
         *    <dd>
         *       (optional) if <code>true</code>, data.frame primitives are encoded
         *       vectors in R object data returned on call
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryScriptExecute: function(config, callback) {            
            return this.io('/r/repository/script/execute', config, callback);
        },


        /**
         * This call executes repository-managed scripts or external scripts on an
         * Anonymous Project and returns a simple HTML page that displays the results
         * generated on the execution.
         *
         * On a successful execution, the HTML page will display the following data
         * when available on the response:
         *
         * <ul>
         *    <li>R console output</li>
         *    <li>R workspace object data</li>
         *    <li>R generated plots</li>
         *    <li>Links to R working directory artifacts</li>
         *    <li>Links to Repository stored artifacts</li>
         * </ul>
         *
         * On a failed execution, the HTML page will display an error message
         * indicating the cause of the failure and when available, R console output.
         *
         * The API call makes it very simple to integrate outputs generated by
         * RevoDeployR-managed R scripts into any third-party application. It can also
         * be used as a very simple test and debugging aid for R script and
         * application developers.
         *
         * To execute a single repository-managed script the caller must provide
         * parameter values for filename , author and optionally version . To execute
         * a chain of repository-managed scripts the caller must provide a
         * comma-separated list of values on the filename , author and optionally
         * version parameters.
         *
         * To execute a single external script the caller must provide a valid URL or
         * file path using the externalsource parameter. To execute a chain of
         * external scripts the caller must provide a comma-separated list of values
         * on the externalsource parameter. Note, to execute an external script the
         * caller must have POWER_USER privileges so this feature is not available to
         * anonymous users on this call.
         *
         * Note: A chained execution executes each of the scripts identified on the
         * call in a sequential fashion on the R session, with execution occuring in
         * the order specified on the parameter list.
         *
         * Please note the following pre and post execution parameters:
         *
         * <strong>Pre-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The inputs parameter allows the caller to pass RevoDeployR-encoded
         *       R object values as inputs. These inputs are turned into R objects
         *       in the workspace before the execution begins.
         *    </li>
         *    <li>
         *       The csvinputs parameter allows the caller to pass R object primitive
         *       values as comma-separated name/value pairs. These inputs are turned
         *       into R objects in the workspace before the execution begins.
         *    </li>
         *    <li>
         *       The preloadfile parameters allows the caller to load one or more
         *       files from the repository into the working directory before the
         *       execution begins.
         *    </li>
         *    <li>
         *       The preloadobject parameters allow the caller to load one or more
         *       binary R objects (.rData) from the repository into the workspace
         *       before the execution begins.
         *    </li>
         *    <li>
         *       The adopt parameters allow the caller to load a pre-existing
         *       project workspace, project working directory and/or project package
         *       dependencies before the execution begins.
         *    </li>
         * </ol>
         *
         * <strong>Post-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The robjects parameter allows the caller to specify a comma-separated
         *       list of object names that will be returned as RevoDeployR-encoded R
         *       objects on the response markup after the execution completes.
         *    </li>
         *    <li>
         *       The storefile parameter allows the caller to specify a comma-separated
         *       list of working directory files to be stored in the repository after
         *       the execution completes.
         *    </li>
         *    <li>
         *       The storeobject parameter allows the caller to specify a comma-separated
         *       list of workspace objects to be stored in the repository after the
         *       execution completes.
         *    </li>
         *    <li>
         *       The storeworkspace parameter allows the caller to store the entire
         *       workspace in the repository after the execution completes.
         *    </li>
         *    <li>
         *       The storedirectory parameter allows the caller to specify a target
         *       repository directory for stored files and objects after the execution
         *       completes.
         *    </li>
         *    <li>
         *       The storenewversion parameter allows the caller to create new
         *       versions of each stored file in the repository after the execution
         *       completes. By default, stored files overwrite any pre-existing file
         *       by the same name.
         *    </li>
         *    <li>
         *       The storepublic parameter allows the caller to assign public access
         *       to each stored file in the repository after the execution completes.
         *    </li>
         *    <li>
         *      The infinity , nan and encodeDataFramePrimitiveAsVector parameters
         *      allow the caller to control how RevoDeployR-encoded R object data is
         *      encoded in the response markkup.
         *    </li>
         * </ol>
         *
         * <strong>Some key data indicated in the response markup on this call:</strong>
         *
         * <ol>
         *    <li>
         *       console - indicates the R console output resulting from the execution
         *    </li>
         *    <li>
         *       results - indicates the list of files generated by the R graphics
         *       device
         *    </li>
         *    <li>
         *       artifacts - indicates the list of files generated or modified in the
         *       working directory
         *    </li>
         *    <li>
         *       objects -  indicates the list of R objects returned from the
         *       workspace
         *    </li>
         *    <li>
         *       files - indicates the list of files and objects stored in the
         *       repository after the execution completes
         *    </li>
         *    <li>
         *       interrupted - indicates the interrupted status of execution
         *    </li>
         *    <li>
         *       error - on failure, indicates the reason for failure
         *    </li>
         *    <li>
         *       errorCode - on failure, indicates the error code for failure
         *    </li>
         * </ol>
         *
         * @method repositoryScriptRender
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>project</dt>
         *    <dd>specifies the project identifier</dd>
         *
         *    <dt>filename</dt>
         *    <dd>
         *       (optional) comma-separated list of repository-managed script
         *       filenames
         *    </dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) comma-separated list of repository-managed directories for
         *       scripts, defaults to root
         *    </dd>
         *
         *    <dt>author</dt>
         *    <dd>
         *       (optional) comma-separated list of authors, one author per filename
         *    </dd>
         *
         *    <dt>version</dt>
         *    <dd>
         *       (optional) comma-separated list of versions, one version per filename
         *    </dd>
         *
         *    <dt>externalsource</dt>
         *    <dd>
         *       (optional) comma-separated list of URLs or file paths to external
         *       scripts
         *    </dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) RevoDeployR-encoded script inputs</dd>
         *
         *    <dt>csvinputs</dt>
         *    <dd>(optional) comma-separated list of primitive name/value inputs</dd>
         *
         *    <dt>preloadfilename</dt>
         *    <dd>(optional) comma-separated list of repository filenames</dd>
         *
         *    <dt>preloadfileauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadfilename</dd>
         *
         *    <dt>preloadfileversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-preloadfilename</dd>
         *
         *    <dt>preloadobjectname</dt>
         *    <dd>(optional) comma-separated list of repository object (.rData) filenames</dd>
         *
         *    <dt>preloadobjectauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadobjectname</dd>
         *
         *    <dt>preloadobjectversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-object-preloadobjectname</dd>
         *
         *    <dt>adoptworkspace</dt>
         *    <dd>(optional) identifies project from which workspace is to be adopted</dd>
         *
         *    <dt>adoptdirectory</dt>
         *    <dd>(optional) identifies project from which directory is to be adopted</dd>
         *
         *    <dt>adoptpackages</dt>
         *    <dd>(optional) identifies project from which package dependencies are to be adopted</dd>
         *
         *      <dt>blackbox</dt>
         *      <dd>(optional) if true, the execution will occur on the HTTP blackbox project for the current HTTP session</dd>
         *
         *      <dt>recycle</dt>
         *      <dd>(optional) if true, recycles the R session associated with the HTTP blackbox project on the current HTTP session</dd>
         *
         *    <dt>tag</dt>
         *    <dd>(optional) specifies a tag that labels the execution</dd>
         *
         *    <dt>echooff</dt>
         *    <dd>(optional) if true R commands will not appear in the console output</dd>
         *
         *    <dt>consoleoff</dt>
         *    <dd>(optional) if true console output is not returned in the response markup</dd>
         *
         *    <dt>graphics</dt>
         *    <dd>(optional) specifies preferred R graphics device for execution: png or svg</dd>
         *
         *    <dt>graphicswidth</dt>
         *    <dd>(optional) specifies preferred width for R graphics device images</dd>
         *
         *    <dt>graphicsheight</dt>
         *    <dd>(optional) specifies preferred height for R graphics device images</dd>
         *
         *    <dt>robjects</dt>
         *    <dd>(optional) specifies a comma-separated list of objects for retrieval following the execution</dd>
         *
         *    <dt>storefile</dt>
         *    <dd>(optional) comma-separated list of working directory filenames</dd>
         *
         *    <dt>storeobject</dt>
         *    <dd>(optional) comma-separated list of workspace object names</dd>
         *
         *    <dt>storeworkspace</dt>
         *    <dd>(optional) filename (.rData) where workspace contents will be saved in the repository</dd>
         *
         *    <dt>storenewversion</dt>
         *    <dd>(optional) if <code>true</code>, ensures each file stored in repository results in new version being created if needed</dd>
         *
         *    <dt>storepublic</dt>
         *    <dd>(optional) if <code>true</code>, publishes each file stored in the repository</dd>
         *
         *    <dt>infinity</dt>
         *    <dd>
         *       (optional) specifies custom value for Infinity appearing in R object
         *       data returned on call, otherwise Infinity is represented by
         *       0x7ff0000000000000L
         *    </dd>
         *
         *    <dt>nan</dt>
         *    <dd>
         *       (optional) specifies custom value for NaN appearing in R object data
         *       returned on call, otherwise NaN is represented by null
         *    </dd>
         *
         *    <dt>encodeDataFramePrimitiveAsVector</dt>
         *    <dd>
         *       (optional) if true, data.frame primitives are encoded vectors in R
         *       object data returned on call
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryScriptRender: function(config, callback) {
            return this.io('/r/repository/script/render', config, callback);
        },

        /**
         * This call interrupts the current execution on the HTTP Blackbox project
         * associated with the current HTTP session.
         *
         * @method repositoryScriptInterrupt
         * @static
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryScriptInterrupt: function(callback) {            
            return this.io('/r/repository/script/interrupt', config, callback);
        },

        /////////////////////////////////////
        // Repository File APIs
        /////////////////////////////////////

        /**
         * This call lists repository-managed files.
         *
         * @method repositoryFiletList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>filename</dt>
         *    <dd>
         *       (optional) when specified, call returns list of script versions for
         *       filename
         *   </dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>shared</dt>
         *    <dd>
         *       (optional) if <code>true</code>, files that are restricted but
         *       visible or shared by other users are included in the response markup
         *    </dd>
         *
         *    <dt>published</dt>
         *    <dd>
         *       (optional) if <code>true</code>, scripts published by other users are
         *       included in the response markup
         *    </dd>
         *
         *    <dt>categoryFilter</dt>
         *    <dd>
         *       (optional) when specified list of files in response markup is limited
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileList: function(config, callback) {            
            return this.io('/r/repository/file/list', config, callback);
        },
        /**
         * This call uploads a file from the user's computer to the repository.
         *
         * @method repositoryFileUpload
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>filename</dt>
         *    <dd>specifies name of the file to upload</dd>
         *
         *    <dt>file</dt>
         *    <dd>...file content...</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies a description to associate with the uploaded file</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>tags</dt>
         *    <dd>(optional) specifies tag words to associate with the repository file</dd>
         *
         *    <dt>restricted</dt>
         *    <dd>(optional) (optional) comma-separated list of role names, which makes the file visible to authenticated users with these roles</dd>
         *
         *     <dt>shared</dt>
         *     <dd>(optional) if true, the file will be shared which makes the file visible to authenticated users</dd>
         *
         *    <dt>published</dt>
         *    <dd>(optional) if true, the file will be published which makes the file visible to authenticated and anonymous users</dd>
         *
         *    <dt>newversion</dt>
         *    <dd>(optional) if true, the repository will create new version rather than overwrite</dd>
         *
         *    <dt>newversionmsg</dt>
         *    <dd>(optional) if newversion is true, message to associate with new version</dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) specifies the inputs property on a repository-managed script</dd>
         *
         *    <dt>outputs</dt>
         *    <dd>(optional) specifies the outputs property on a repository-managed script</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileUpload: function(config, callback) {
            config.format = "text";
            var ioConfig = {
                data: config,
                method: "POST",
                form: {
                    id: config.formId
                },
                on: callback
            };
            return this.io('/r/repository/file/upload', config, callback);
        },

        /**
         * This call transfers a file from a URL to the repository.
         *
         * @method repositoryFileTransfer
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>filename</dt>
         *    <dd>specifies name of the file to upload</dd>
         *
         *    <dt>url</dt>
         *    <dd>specifies a url of the file to upload</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies a description to associate with the uploaded file</dd>
         *
         *    <dt>tags</dt>
         *    <dd>(optional) specifies tag words to associate with the repository file</dd>
         *
         *    <dt>restricted</dt>
         *    <dd>(optional) (optional) comma-separated list of role names, which makes the file visible to authenticated users with these roles</dd>
         *
         *     <dt>shared</dt>
         *     <dd>(optional) if true, the file will be shared which makes the file visible to authenticated users</dd>
         *
         *    <dt>published</dt>
         *    <dd>(optional) if true, the file will be published which makes the file visible to authenticated and anonymous users</dd>
         *
         *    <dt>newversion</dt>
         *    <dd>(optional) if true, the repository will create new version rather than overwrite</dd>
         *
         *    <dt>newversionmsg</dt>
         *    <dd>(optional) if newversion is true, message to associate with new version</dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) specifies the inputs property on a repository-managed script</dd>
         *
         *    <dt>outputs</dt>
         *    <dd>(optional) specifies the outputs property on a repository-managed script</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileTransfer: function(config, callback) {
            return this.io('/r/repository/file/transfer', config, callback);
        },

        /**
         * This call writes a text file to the repository.
         *
         * @method repositoryFileWrite
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>filename</dt>
         *    <dd>specifies name of the file to upload</dd>
         *
         *    <dt>text</dt>
         *    <dd>specifies the text content of the file to upload</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>descr</dt>
         *    <dd>
         *       (optional) specifies a description to associate with the uploaded
         *       file
         *    </dd>
         *
         *    <dt>tags</dt>
         *    <dd>
         *       (optional) specifies tag words to associate with the repository file
         *    </dd>
         *
         *    <dt>restricted</dt>
         *    <dd>
         *       (optional) (optional) comma-separated list of role names, which makes
         *       the file visible to authenticated users with these roles
         *    </dd>
         *
         *    <dt>share</dt>
         *    <dd>
         *       (optional) if true, ile is shared and visible to authenticated users
         *    </dd>
         *
         *    <dt>publish</dt>
         *    <dd>
         *       (optional) if true, the file will be published which makes the file
         *       visible to authenticated and anonymous users
         *    </dd>
         *
         *    <dt>newversion</dt>
         *    <dd>
         *       (optional) if true, the repository will create new version rather
         *       than overwrite
         *    </dd>
         *
         *    <dt>newversionmsg</dt>
         *    <dd>
         *       (optional) if newversion is true, message to associate with new
         *       version
         *    </dd>
         *
         *    <dt>inputs</dt>
         *    <dd>
         *       (optional) specifies the inputs property on a repository-managed
         *       script
         *    </dd>
         *
         *    <dt>outputs</dt>
         *    <dd>
         *       (optional) specifies the outputs property on a repository-managed
         *       script
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileWrite: function(config, callback) {
            return this.io('/r/repository/file/write', config, callback);
        },

        /**
         * This call updates the properties on a repository-managed file.
         *
         * @method repositoryFileUpdate
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>filename</dt>
         *    <dd>specifies name of the file to upload</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies a description to associate with the uploaded file</dd>
         *
         *    <dt>tags</dt>
         *    <dd>(optional) specifies tag words to associate with the repository file</dd>
         *
         *    <dt>restricted</dt>
         *    <dd>
         *       (optional) (optional) comma-separated list of role names, which makes
         *       the file visible to authenticated users with these roles
         *    </dd>
         *
         *     <dt>shared</dt>
         *     <dd>(optional) if true, the file will be shared which makes the file visible to authenticated users</dd>
         *
         *    <dt>published</dt>
         *    <dd>(optional) if true, the file will be published which makes the file visible to authenticated and anonymous users</dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) specifies the inputs property on a repository-managed script</dd>
         *
         *    <dt>outputs</dt>
         *    <dd>(optional) specifies the outputs property on a repository-managed script</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileUpdate: function(config, callback) {
            return this.io('/r/repository/file/update', config, callback);
        },

        /**
         * This call reverts the current working copy of a file to a specific version
         * found in the files version history.
         *
         * @method repositoryFileRevert
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>filename</dt>
         *    <dd>specifies name of the file to upload</dd>
         *
         *    <dt>version</dt>
         *    <dd>specifies the repository file version to revert into the current working copy</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) specifies a description to associate with the uploaded file</dd>
         *
         *    <dt>restricted</dt>
         *    <dd>(optional) (optional) comma-separated list of role names, which makes the file visible to authenticated users with these roles</dd>
         *
         *     <dt>shared</dt>
         *     <dd>(optional) if true, the file will be shared which makes the file visible to authenticated users</dd>
         *
         *    <dt>published</dt>
         *    <dd>(optional) if true, the file will be published which makes the file visible to authenticated and anonymous users</dd>
         *
         *    <dt>newversion</dt>
         *    <dd>(optional) if true, the repository will create new version rather than overwrite</dd>
         *
         *    <dt>newversionmsg</dt>
         *    <dd>(optional) if newversion is true, message to associate with new version</dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) specifies the inputs property on a repository-managed script</dd>
         *
         *    <dt>outputs</dt>
         *    <dd>(optional) specifies the outputs property on a repository-managed script</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileRevert: function(config, callback) {
            return this.io('/r/repository/file/revert', config, callback);
        },

        /**
         * This call generates a diff between the current working copy of a file and
         * a specific version found in the files version history.
         *
         * @method repositoryFileDiff
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>filename</dt>
         *    <dd>specifies the repository file name</dd>
         *
         *    <dt>author</dt>
         *    <dd>specifies the repository file author</dd>
         *
         *    <dt>version</dt>
         *    <dd>
         *       specifies the repository file version to diff against the current
         *       working copy
         *    </dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileDiff: function(config, callback) {
            return this.io('/r/repository/file/diff', config, callback);
        },

        /**
         * This call grants ownership rights on a file to one or more authenticated
         * users.
         *
         * Note, unlike most repository APIs that require both filename and author
         * parameters, there is no explicit author parameter on this call. The author
         * is understood to be the caller.
         *
         * @method repositoryFileGrant
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>filename</dt>
         *    <dd>specifies the name of the repository file</dd>
         *
         *    <dt>newauthor</dt>
         *    <dd> specifies a comma-separated list of grantee usernames</dd>
         *
         *    <dt>revokeauthor</dt>
         *    <dd>
         *       (optional) specifies a comma-separated list of revokee usernames
         *    </dd>
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileGrant: function(config, callback) {
            return this.io('/r/repository/file/grant', config, callback);
        },

        /**
         * This call downloads a repository-managed file.
         *
         * @method repositoryFileDownload
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *      <dt>filename</dt>
         *      <dd>specifies the repository file name</dd>
         *
         *      <dt>author</dt>
         *      <dd>specifies the repository author</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *      <dt>version</dt>
         *      <dd>(optional) specifies the repository file version</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileDownload: function(config, callback) {
            return this.io('/r/repository/file/download', config, callback);
        },

        /**
         * This call deletes a file from the repository.
         *
         * @method repositoryFileDelete
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *      <dt>filename</dt>
         *      <dd>specifies the repository file name</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileDelete: function(config, callback) {
            return this.io('/r/repository/file/delete', config, callback);
        },

        /**
         * This call fetches the latest meta-data on a file in the repository.
         *
         * @method repositoryFileFetch
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *      <dt>filename</dt>
         *      <dd>specifies the repository file name</dd>
         *
         *    <dt>author</dt>
         *    <dd>
         *       (optional) specifies the repository file author
         *    </dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>version</dt>
         *    <dd>
         *       (optional) specifies the repository file version
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileFetch: function(config, callback) {
            return this.io('/r/repository/file/fetch', config, callback);
        },

        /**
         * This call copies one or more repository-managed files to the destination
         * directory.
         *
         * If the destination directory already contains a filename matching an
         * incoming filename, then a new version of the file is automatically created.
         *
         * @method repositoryFileCopy
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *      <dt>filename</dt>
         *      <dd>specifies the repository file name</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>destination</dt>
         *    <dd>
         *       (optional) specifies the name of the destination user directory in
         *       the repository
         *    </dd>
         *
         *    <dt>version</dt>
         *    <dd>
         *       (optional) specifies the repository file version
         *    </dd>
         *
         *    <dt>filerename</dt>
         *    <dd>
         *       (optional) comma-separated list of new filenames for copied files
         *       identified on filename parameter
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileCopy: function(config, callback) {            
            return this.io('/r/repository/file/copy', config, callback);
        },

        /**
         * This call moves one or more repository-managed files to the destination
         * directory.
         *
         * If the destination directory already contains a filename matching an
         * incoming filename, then a new version of the file is automatically created.
         *
         * @method repositoryFileMove
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *      <dt>filename</dt>
         *      <dd>specifies the repository file name</dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>destination</dt>
         *    <dd>
         *       (optional) specifies the name of the destination user directory in
         *       the repository
         *    </dd>
         *
         *    <dt>version</dt>
         *    <dd>
         *       (optional) specifies the repository file version
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryFileMove: function(config, callback) {            
            return this.io('/r/repository/file/move', config, callback);
        },

        /////////////////////////////////////
        // Repository Directory APIs
        /////////////////////////////////////

        /**
         * This call lists repository-managed directories.
         * By default, a list of the caller's user directories ( root and custom ) are
         * returned in the response markup.
         *
         * If the userfiles parameter is specified, the files in all of the caller's
         * user directories are listed in the response markup. Note, depending on the
         * number of files owned by the caller, when this parameter is enabled the
         * response markup returned on this call can be a verbose.
         *
         * If the directory parameter is specified then only the files in the
         * directory indicated are returned in the response markup.
         *
         * Additional parameters are provided to return files in the caller's archived
         * directories and/or files in the Restricted , Shared and Public system
         * directories.
         *
         * Note: The metadata property in the response markup on this call is provided
         * as a convenience for client application developers. It provides a complete
         * list fo the user directories available to the current caller.
         *
         * @method repositoryDirectoryList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>userfiles</dt>
         *    <dd>
         *       (optional) if specified, files in all user directories are listed in
         *       the response markup
         *    </dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>archived</dt>
         *    <dd>
         *       (optional) if true, files found in archived directories are included
         *       in the response markup
         *    </dd>
         *
         *    <dt>shared</dt>
         *    <dd>
         *       (optional) if true, files that are restricted but visible or shared
         *       by other users are included in the response markup
         *    </dd>
         *
         *    <dt>published</dt>
         *    <dd>
         *       (optional) if true, files that are published by other users are
         *       included in the response markup
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryList: function(config, callback) {            
            return this.io('/r/repository/directory/list', config, callback);
        },

        /**
         * This call creates a repository-managed custom directory.
         *
         * If the name of the new custom directory is already in use by the caller the
         * response markup will indicate an appropriate error.
         *
         * @method repositoryDirectoryList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryCreate: function(config, callback) {            
            return this.io('/r/repository/directory/create', config, callback);
        },

        /**
         * This call renames an existing repository-managed user directory
         * ( custom or archived ). When renaming a user directory, all files in the
         * source directory are automatically moved to the destination directory. If
         * the destination directory already exists the call will be rejected and the
         * response markup will indicate an appropriate error.
         *
         * You can use this call to convert an archived directory back into a custom
         * directory, essentially unarchiving the archived directory.
         *
         * Note: You can not rename the root directory. To move files from the root
         * directory use the /r/repository/directory/move call.
         *
         * <strong>Important:</strong>
         *
         * This call will only move files that are owned by a single author to the
         * destination directory. If a repository-managed file in the source directory
         * has multiple authors, as a result of collaboration using the
         * /r/repository/file/grant call, the file will not be moved to the
         * destination directory and a warning to that affect will be indicated in the
         * response markup.
         *
         * @method repositoryDirectoryRename
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>destination</dt>
         *    <dd>
         *       (optional) specifies the new name for the destination custom directory
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryRename: function(config, callback) {           
            return this.io('/r/repository/directory/rename', config, callback);
        },

        /** 
         * This call copies one or more repository-managed files from a source user
         * directory to a destination user directory.
         *
         * If the filename parameter is specified, only those files indicated on that
         * parameter are copied. Otherwise, all files in the source directory are
         * copied.
         *
         * To ensure copying files does not accidentally overwrite any existing files
         * in the destination directory, all copied files are created as new versions
         * in the destination directory.
         *
         * @method repositoryDirectoryCopy
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>destination</dt>
         *    <dd>
         *       (optional) specifies the new name for the destination custom directory
         *    </dd>
         *
         *    <dt>filename</dt>
         *    <dd>
         *       (optional) comma-separated list of filenames to be copied. If omitted,
         *       all files in the source directory are copied
         *    </dd>
         *
         *    <dt>filerename</dt>
         *    <dd>
         *       (optional) comma-separated list of new filenames for copied files
         *       identified on filename parameter
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryCopy: function(config, callback) {            
            return this.io('/r/repository/directory/copy', config, callback);
        },

        /**
         * This call moves one or more repository-managed files from a source user
         * directory to a destination user directory.
         *
         * If the filename parameter is specified, only those files indicated on that
         * parameter are moved. Otherwise, all files in the source directory are moved.
         *
         * To ensure moving files does not accidentally overwrite any existing files
         * in the destination directory, all moved files are created as new versions
         * in the destination directory.
         *
         * <strong>Important:</strong>
         *
         * This call will only move files that are owned by a single author to the
         * destination directory. If a repository-managed file in the source directory
         * has multiple authors, as result of collaboration using the
         * /r/repository/file/grant call, the file will not be moved to the
         * destination directory and a warning to that affect will be indicated in the
         * response markup.
         *
         * @method repositoryDirectoryMove
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>destination</dt>
         *    <dd>
         *       (optional) specifies the new name for the destination custom directory
         *    </dd>
         *
         *    <dt>filename</dt>
         *    <dd>
         *       (optional) comma-separated list of filenames to be copied. If omitted,
         *       all files in the source directory are copied
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryMove: function(config, callback) {            
            return this.io('/r/repository/directory/move', config, callback);
        },

        /**
         * This call updates repository-managed file access controls by directory.
         *
         * If the filename parameter is specified, only those files indicated on that
         * parameter are updated. Otherwise, all files in the source directory are
         * updated.
         *
         * @method repositoryDirectoryUpdate
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>filename</dt>
         *    <dd>
         *       (optional) comma-separated list of filenames to be copied. If omitted,
         *       all files in the source directory are copied
         *    </dd>
         *
         *    <dt>restricted</dt>
         *    <dd>
         *       (optional) specifies the new name for the destination custom directory
         *    </dd>
         *
         *    <dt>shared</dt>
         *    <dd>
         *       (optional) if <code>true</code>, files are shared and visible to
         *       authenticated users
         *    </dd>
         *
         *    <dt>published</dt>
         *    <dd>
         *       (optional) if <code>true</code>, files are published and visible to
         *       authenticated and anonymous users
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryUpdate: function(config, callback) {
            return this.io('/r/repository/directory/update', config, callback);
        },

        /**
         * This call archives one or more repository-managed files from a source user
         * directory ( root or custom ) to an archive directory.
         *
         * If the value of the archive parameter indicates an existing archive
         * directory then the files in the source directory are added to the existing
         * archive. Otherwise, a new archive directory is automatically created on
         * behalf of the caller. Archived directories automatically have a .archive
         * postfix appended to their name if it is not supplied on the archive
         * parameter value.
         *
         * If all of the files in the source directory are successfully archived, the
         * source directory is automatically deleted from the repository. If the
         * source directory was root , an empty root directory is preserved. If any of
         * the files in the source directory are skipped or can not be archived (see
         * following note), those files and the source directory are preserved.
         *
         * <strong>Important:</strong>
         *
         * This call will only archive files that are owned by a single author to the
         * destination directory. If a repository-managed file in the source directory
         * has multiple authors, as a result of collaboration using the
         * /r/repository/file/grant call, the file will not be archived to the
         * destination directory and a warning to that affect will be indicated in the
         * response markup.
         *
         * @method repositoryDirectoryArchive
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>filename</dt>
         *    <dd>
         *       (optional) comma-separated list of filenames to be copied. If omitted,
         *       all files in the source directory are copied
         *    </dd>
         *
         *    <dt>restricted</dt>
         *    <dd>
         *       (optional) specifies the new name for the destination custom directory
         *    </dd>
         *
         *    <dt>shared</dt>
         *    <dd>
         *       (optional) if <code>true</code>, files are shared and visible to
         *       authenticated users
         *    </dd>
         *
         *    <dt>published</dt>
         *    <dd>
         *       (optional) if <code>true</code>, files are published and visible to
         *       authenticated and anonymous users
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryArchive: function(config, callback) {

            return this.io('/r/repository/directory/archive', config, callback);
        },

        /**
         * This call uploads a set of files in a zip archive into an existing
         * repository-managed user directory ( root , custom or archived ).
         *
         * @method repositoryDirectoryUpload
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>file</dt>
         *    <dd>
         *       ...zip archive file content...
         *    </dd>
         *
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>descr</dt>
         *    <dd>
         *       (optional) specifies a description to associate with the uploaded file
         *    </dd>
         *
         *    <dt>tags</dt>
         *    <dd>
         *       (optional) specifies tag words to associate with the repository file
         *    </dd>
         *
         *    <dt>restricted</dt>
         *    <dd>
         *       (optional) specifies the new name for the destination custom directory
         *    </dd>
         *
         *    <dt>shared</dt>
         *    <dd>
         *       (optional) if <code>true</code>, files are shared and visible to
         *       authenticated users
         *    </dd>
         *
         *    <dt>published</dt>
         *    <dd>
         *       (optional) if <code>true</code>, files are published and visible to
         *       authenticated and anonymous users
         *    </dd>
         *
         *    <dt>newversion</dt>
         *    <dd>
         *       (optional) if <code>true</code>, the repository will create new
         *       version rather than overwrite
         *    </dd>
         *
         *    <dt>newversionmsg</dt>
         *    <dd>
         *       (optional) if newversion is true, message to associate with new
         *       version
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryUpload: function(config, callback) {
            config = config || {};
            config.format = 'text';
            var ioConfig = {
                data: config,
                method: 'POST',
                form: {
                    id: config.formId
                },
                on: callback
            };
            return this.io('/r/repository/directory/upload', config, callback);
        },

        /**
         * This call downloads one or more repository-managed files from a directory
         * in the repository. The response type on this call is a zip archive file.
         *
         * If the filename parameter is specified, only those files indicated on that
         * parameter are downloaded. Otherwise, all files in the source directory are
         * downloaded.
         *
         * @method repositoryDirectoryDownload
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         *
         *    <dt>filename</dt>
         *    <dd>
         *       (optional) comma-separated list of filenames to be copied. If omitted,
         *       all files in the source directory are copied
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryDownload: function(config, callback) {            
            return this.io('/r/repository/directory/download', config, callback);
        },

        /**
         * This call deletes a repository-managed user directory ( root , custom or
         * archived ).
         *
         * When deleting a user directory, all files in the directory are
         * automatically deleted along with the directory. If the target directory is
         * root, an empty root directory is preserved.
         *
         * @method repositoryDirectoryDelete
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>directory</dt>
         *    <dd>
         *       (optional) specifies the target repository directory, defaults to root
         *       included in the response markup
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        repositoryDirectoryDelete: function(config, callback) {
            return this.io('/r/repository/directory/delete', config, callback);
        },

        /////////////////////////////////////
        // Job APIs
        /////////////////////////////////////

        /**  
         * This call lists jobs for the currently authenticated user.
         *
         * The openonly parameter allows the caller to see only those jobs in an open
         * state. The set of job open states are shown here:
         *
         * <ul>
         *  <li>Scheduled : job is scheduled but not yet queued for running.</li>
         *  <li>Queued : job is queued for running.</li>
         *  <li>Running : job is running.</li>
         * </ul>
         *
         * <blockquote>
         *    Important! Any open job can be cancelled using the
         *    <a href="#method_jobCancel">jobCancel</a> call.
         * </blockquote>
         *
         * @method jobList
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>openonly</dt>
         *    <dd>
         *       (optional) if true, only jobs in an open-state are listed in the
         *       response markup
         *    </dd>
         *
         *    <dt>extended</dt>
         *    <dd>
         *       (optional) If true, additional data properties describing each job
         *       are listed in the response markup
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        jobList: function(config, callback) {
            return this.io('/r/job/list', config, callback);
        },

        /**
         * This call submits a job for background execution on behalf of the user.
         *
         * To submit the execution of an arbitrary block of R code the caller must
         * provide a value on the code parameter.
         *
         *
         * To submit the execution of a single repository-managed script the caller
         * must provide parameter values for rscriptname , rscriptauthor and
         * optionally rscriptversion . To submit the execution of a chain of
         * repository-managed scripts the caller must provide a comma-separated list
         * of values on the rscriptname,, _rscriptauthor and optionally rscriptversion
         * parameters.
         *
         *
         * To submit the execution of a single external script the caller must
         * provide a valid URL or file path using the externalsource parameter. To
         * submit the execution of a chain of external scripts the caller must
         * provide a comma-separated list of values on the externalsource parameter.
         * Note, to submit the execution of an external script the caller must have
         * POWER_USER privileges.
         *
         * Note: A chained execution executes each of the scripts identified on the
         * call in a sequential fashion on the R session for the job, with execution
         * occuring in the order specified on the parameter list.
         *
         * Please not the following pre and post execution parameters:
         *
         * <strong>Pre-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The inputs parameter allows the caller to pass RevoDeployR-encoded
         *       R object values as inputs. These inputs are turned into R objects
         *       in the workspace before the execution begins.
         *    </li>
         *    <li>
         *       The preloadfile parameters allows the caller to load one or more
         *       files from the repository into the working directory before the
         *       execution begins.
         *    </li>
         *    <li>
         *       The preloadobject parameters allow the caller to load one or more
         *       binary R objects (.rData) from the repository into the workspace
         *       before the execution begins.
         *    </li>
         *    <li>
         *       The adopt parameters allow the caller to load a pre-existing
         *       project workspace, project working directory and/or project package
         *       dependencies before the execution begins.
         *    </li>
         * </ol>
         *
         * <strong>Post-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The storefile parameter allows the caller specify a comma-separated
         *       list of working directory files to be stored in the repository after
         *       the execution completes.
         *    </li>
         *    <li>
         *       The storeobject parameter allows the caller specify a comma-separated
         *       list of workspace objects to be stored in the repository after the
         *       execution completes.
         *    </li>
         *    <li>
         *       The storeworkspace parameter allows the caller to store the entire
         *       workspace in the repository after the execution completes.
         *    </li>
         *    <li>
         *       The storedirectory parameter allows the caller to specify a target
         *       repository directory for stored files and objects after the execution
         *       completes.
         *    </li>
         *    <li>
         *       The storenewversion parameter allows the caller to create new
         *       versions of each stored file in the repository after the execution
         *       completes. By default, stored files overwrite any pre-existing file
         *       by the same name.
         *    </li>
         *    <li>
         *       The storepublic parameter allows the caller to assign public access
         *       to each stored file in the repository after the execution completes.
         *    </li>
         *    <li>
         *       The storenoproject parameter allows the caller to skip the
         *       persistence-to-project step after the execution.
         *    </li>
         * </ol>
         *
         * @method jobSubmit
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>name</dt>
         *    <dd>job name</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) job description</dd>
         *
         *    <dt>code</dt>
         *    <dd>(optional) R code to execute on job</dd>
         *
         *      <dt>rscriptname</dt>
         *      <dd>(optional) comma-separated list of repository-managed script filenames</dd>
         *
         *    <dt>rscriptdirectory</dt>
         *    <dd>(optional) comma-separated list of repository-managed directories for scripts, defaults to root</dd>
         *
         *      <dt>rscriptauthor</dt>
         *      <dd>(optional) comma-separated list of authors, author-per-rscriptname</dd>
         *
         *      <dt>rscriptversion</dt>
         *      <dd>(optional) comma-separated list of versions, version-per-rscriptname</dd>
         *
         *      <dt>externalsource</dt>
         *      <dd>(optional) comma-separated list of URLs or file paths to external scripts</dd>
         *
         *      <dt>inputs</dt>
         *      <dd>(optional) RevoDeployR-encoded script inputs</dd>
         *
         *    <dt>csvinputs</dt>
         *    <dd>(optional) comma-separated list of primitive name/value inputs</dd>
         *
         *      <dt>preloadfilename</dt>
         *      <dd>(optional) comma-separated list of repository filenames</dd>
         *
         *      <dt>preloadfileauthor</dt>
         *      <dd>(optional) comma-separated list of authors, author-per-preloadfilename</dd>
         *
         *      <dt>preloadfileversion</dt>
         *      <dd>(optional) comma-separated list of versions, version-per-preloadfilename</dd>
         *
         *      <dt>preloadobjectname</dt>
         *      <dd>(optional) comma-separated list of repository object (.rData) filenames</dd>
         *
         *      <dt>preloadobjectauthor</dt>
         *      <dd>(optional) comma-separated list of authors, author-per-preloadobjectname</dd>
         *
         *      <dt>preloadobjectversion</dt>
         *      <dd>(optional) comma-separated list of versions, version-per-object-preloadobjectname</dd>
         *
         *      <dt>adoptworkspace</dt>
         *      <dd>(optional) identifies project from which workspace is to be adopted</dd>
         *
         *      <dt>adoptdirectory</dt>
         *      <dd>(optional) identifies project from which directory is to be adopted</dd>
         *
         *      <dt>adoptpackages</dt>
         *      <dd>(optional) identifies project from which package dependencies are to be adopted</dd>
         *
         *      <dt>priority</dt>
         *      <dd>(optional) specifies the scheduling priority for the job: low (default), medium or high</dd>
         *
         *      <dt>tag</dt>
         *      <dd>(optional) specifies a tag that labels the execution</dd>
         *
         *      <dt>echooff</dt>
         *      <dd>
         *       (optional) if true R commands will not appear in the console output
         *       saved on the project execution history for the job
         *    </dd>
         *
         *      <dt>graphics</dt>
         *      <dd>(optional) specifies preferred R graphics device for execution: png or svg</dd>
         *
         *      <dt>graphicswidth</dt>
         *      <dd>(optional) specifies preferred width for R graphics device images</dd>
         *
         *      <dt>graphicsheight</dt>
         *      <dd>(optional) specifies preferred height for R graphics device images</dd>
         *
         *      <dt>storefile</dt>
         *      <dd>(optional) comma-separated list of working directory filenames</dd>
         *
         *      <dt>storeobject</dt>
         *      <dd>(optional) comma-separated list of workspace object names</dd>
         *
         *      <dt>storeworkspace</dt>
         *      <dd>(optional) filename (.rData) where workspace contents will be saved in the repository</dd>
         *
         *      <dt>storenewversion</dt>
         *      <dd>(optional) if <code>true</code>, ensures each file stored in repository results in new version being created if needed</dd>
         *
         *      <dt>storepublic</dt>
         *      <dd>(optional) if <code>true</code>, publishes each file stored in the repository</dd>
         *
         *      <dt>storenoproject</dt>
         *      <dd>(optional) if <code>true</code>, no project persistence following job execution</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        jobSubmit: function(config, callback) {            
            return this.io('/r/job/submit', config, callback);
        },

        /**
         * This call schedules a job for background execution on behalf of the user.
         *
         * The schedstart parameter identifies the start time for the job. This
         * parameter value is specified as UTC in milliseconds. The schedrepeat
         * parameter indicates the number of times the job is to be repeated, and if
         * omitted the job is executed just once. The schedinterval parameter
         * indicates the interval, measured in milliseconds, between repeat
         * executions.
         *
         * To schedule the execution of an arbitrary block of R code the caller
         * must provide a value on the code parameter.
         *
         * To schedule the execution of a single repository-managed script the
         * caller must provide parameter values for rscriptname , rscriptauthor and
         * optionally rscriptversion . To schedule the execution of a chain of
         * repository-managed scripts the caller must provide a comma-separated list
         * of values on the rscriptname,, _rscriptauthor and optionally rscriptversion
         * parameters.
         *
         * To schedule the execution of a single external script the caller must
         * provide a valid URL or file path using the externalsource parameter. To
         * schedule the execution of a chain of external scripts the caller must
         * provide a comma-separated list of values on the externalsource parameter.
         * Note, to schedule the execution of an external script the caller must
         * have POWER_USER privileges.
         *
         * Note: A chained execution executes each of the scripts identified on the
         * call in a sequential fashion on the R session for the job, with
         * execution occuring in the order specified on the parameter list.
         *
         * Please not the following pre and post execution parameters:
         *
         * <strong>Pre-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The inputs parameter allows the caller to pass RevoDeployR-encoded
         *       R object values as inputs. These inputs are turned into R objects
         *       in the workspace before the execution begins.
         *    </li>
         *    <li>
         *       The preloadfile parameters allows the caller to load one or more
         *       files from the repository into the working directory before the
         *       execution begins.
         *    </li>
         *    <li>
         *       The preloadobject parameters allow the caller to load one or more
         *       binary R objects (.rData) from the repository into the workspace
         *       before the execution begins.
         *    </li>
         *    <li>
         *       The adopt parameters allow the caller to load a pre-existing
         *       project workspace, project working directory and/or project package
         *       dependencies before the execution begins.
         *    </li>
         * </ol>
         *
         * <strong>Post-execution parameters:</strong>
         *
         * <ol>
         *    <li>
         *       The storefile parameter allows the caller specify a comma-separated
         *       list of working directory files to be stored in the repository after
         *       the execution completes.
         *    </li>
         *    <li>
         *       The storeobject parameter allows the caller specify a comma-separated
         *       list of workspace objects to be stored in the repository after the
         *       execution completes.
         *    </li>
         *    <li>
         *       The storeworkspace parameter allows the caller to store the entire
         *       workspace in the repository after the execution completes.
         *    </li>
         *    <li>
         *       The storedirectory parameter allows the caller to specify a target
         *       repository directory for stored files and objects after the execution
         *       completes.
         *    </li>
         *    <li>
         *       The storenewversion parameter allows the caller to create new
         *       versions of each stored file in the repository after the execution
         *       completes. By default, stored files overwrite any pre-existing file
         *       by the same name.
         *    </li>
         *    <li>
         *       The storepublic parameter allows the caller to assign public access
         *       to each stored file in the repository after the execution completes.
         *    </li>
         *    <li>
         *       The storenoproject parameter allows the caller to skip the
         *       persistence-to-project step after the execution.
         *    </li>
         * </ol>
         *
         * @method jobSchedule
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>name</dt>
         *    <dd>job name</dd>
         *
         *    <dt>descr</dt>
         *    <dd>(optional) job description</dd>
         *
         *    <dt>schedstart</dt>
         *    <dd>(optional) specifies the start time for job</dd>
         *
         *    <dt>schedrepeat</dt>
         *    <dd>(optional) specifies the number of times job is to be repeated</dd>
         *
         *    <dt>schedinterval</dt>
         *    <dd>(optional) specifies the interval (ms) on which job is to be repeated</dd>
         *
         *    <dt>code</dt>
         *    <dd>(optional) R code to execute on job</dd>
         *
         *    <dt>rscriptname</dt>
         *    <dd>(optional) comma-separated list of repository-managed script filenames</dd>
         *
         *    <dt>rscriptdirectory</dt>
         *    <dd>(optional) comma-separated list of repository-managed directories for scripts, defaults to root</dd>
         *
         *    <dt>rscriptauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-rscriptname</dd>
         *
         *    <dt>rscriptversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-rscriptname</dd>
         *
         *    <dt>externalsource</dt>
         *    <dd>(optional) comma-separated list of URLs or file paths to external scripts</dd>
         *
         *    <dt>inputs</dt>
         *    <dd>(optional) RevoDeployR-encoded script inputs</dd>
         *
         *    <dt>csvinputs</dt>
         *    <dd>(optional) comma-separated list of primitive name/value inputs</dd>
         *
         *    <dt>preloadfilename</dt>
         *    <dd>(optional) comma-separated list of repository filenames</dd>
         *
         *    <dt>preloadfileauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadfilename</dd>
         *
         *    <dt>preloadfileversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-preloadfilename</dd>
         *
         *    <dt>preloadobjectname</dt>
         *    <dd>(optional) comma-separated list of repository object (.rData) filenames</dd>
         *
         *    <dt>preloadobjectauthor</dt>
         *    <dd>(optional) comma-separated list of authors, author-per-preloadobjectname</dd>
         *
         *    <dt>preloadobjectversion</dt>
         *    <dd>(optional) comma-separated list of versions, version-per-object-preloadobjectname</dd>
         *
         *    <dt>adoptworkspace</dt>
         *    <dd>(optional) identifies project from which workspace is to be adopted</dd>
         *
         *    <dt>adoptdirectory</dt>
         *    <dd>(optional) identifies project from which directory is to be adopted</dd>
         *
         *    <dt>adoptpackages</dt>
         *    <dd>(optional) identifies project from which package dependencies are to be adopted</dd>
         *
         *      <dt>priority</dt>
         *      <dd>(optional) specifies the scheduling priority for the job: low (default), medium or high</dd>
         *
         *    <dt>tag</dt>
         *    <dd>(optional) specifies a tag that labels the execution</dd>
         *
         *    <dt>echooff</dt>
         *    <dd>
         *       (optional) if true R commands will not appear in the console output
         *       saved on the project execution history for the job
         *    </dd>
         *
         *    <dt>consoleoff</dt>
         *    <dd>
         *       (optional) if true console output is not saved on the project
         *       execution history for the job
         *    </dd>
         *
         *    <dt>graphics</dt>
         *    <dd>(optional) specifies preferred R graphics device for execution: png or svg</dd>
         *
         *    <dt>graphicswidth</dt>
         *    <dd>(optional) specifies preferred width for R graphics device images</dd>
         *
         *    <dt>graphicsheight</dt>
         *    <dd>(optional) specifies preferred height for R graphics device images</dd>
         *
         *    <dt>storefile</dt>
         *    <dd>(optional) comma-separated list of working directory filenames</dd>
         *
         *    <dt>storeobject</dt>
         *    <dd>(optional) comma-separated list of workspace object names</dd>
         *
         *    <dt>storeworkspace</dt>
         *    <dd>(optional) filename (.rData) where workspace contents will be saved in the repository</dd>
         *
         *    <dt>storenewversion</dt>
         *    <dd>(optional) if <code>true</code>, ensures each file stored in repository results in new version being created if needed</dd>
         *
         *    <dt>storepublic</dt>
         *    <dd>(optional) if <code>true</code>, publishes each file stored in the repository</dd>
         *
         *    <dt>storenoproject</dt>
         *    <dd>(optional) if <code>true</code>, no project persistence following job execution</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        jobSchedule: function(config, callback) {           
            return this.io('/r/job/schedule', config, callback);
        },

        /**
         * This call queries the job status. The status property will indicate one of
         * the following values:
         *
         * Scheduled, Queued, Running, Completed, Cancelling, Cancelled, Interrupted,
         * Aborted, Failed.
         *
         * @method jobQuery
         * @static
         * @param {Object} config the call configuration. The configuration object
         * supports the following properties:
         * <dl>
         *    <dt>job</dt>
         *    <dd>specifies a comma-separated list of job identifiers</dd>
         *
         *    <dt>extended</dt>
         *    <dd>
         *       (optional) if true, only jobs in an extended-state are listed in the
         *       response markup
         *    </dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        jobQuery: function(config, callback) {
            return this.io('/r/job/query', config, callback);
        },

        /**
         * This call cancels the specified job.
         *
         * Only jobs in an open-state can be cancelled. The set of job open-states are
         * shown here:
         *
         * <ul>
         *    <li>Scheduled : job is scheduled but not yet queued for running.</li>
         *    <li>Queued : job is queued for running.</li>
         *    <li>Running : job is running.</li>
         * </ul>
         * @method jobCancel
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *    <dt>job</dt>
         *    <dd>specifies a comma-separated list of job identifiers</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        jobCancel: function(config, callback) {
            return this.io('/r/job/list', config, callback);
        },

        /**
         * This call deletes the specified job.
         *
         * Only jobs in one of the completed-states can be deleted. The set of job
         * compelted-states are shown here:
         *
         * <ul>
         *    <li>Completed : job execution has run to successful completion.</li>
         *    <li>Interrupted : job execution has been interrupted.</li>
         *    <li>Cancelled : job has been cancelled.</li>
         *    <li>Aborted : job execution has been aborted.</li>
         *    <li>Failed : job execution has resulted in failure.</li>
         * </ul>
         *
         * Jobs in an open-state must first run to completion or be cancelled before
         * they are eligible for deletion.
         *
         * <blockquote>
         *    Important! Deleting jobs will not delete the projects that resulted from
         *    those jobs.
         * </blockquote>
         *
         * @method jobDelete
         * @static
         * @param {Object} config the call configuration. The configuration object
         *        supports the following properties:
         * <dl>
         *  <dt>job</dt>
         *  <dd>specifies a comma-separated list of job identifiers</dd>
         * </dl>
         * @param {Object} callback the callback configuration.
         * @return {Object} the io transaction object.
         */
        jobDelete: function(config, callback) {
            return this.io('/r/job/delete', config, callback);
        }
    } // DeployR

};

module.exports = Deprecated;
},{"../package":38,"./lang":26,"./rinput":30,"./selfish":33}],23:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var Base = require('./selfish').Base;

function debug(msg) { }

module.exports = Base.extend({

  initialize: function() {
    this.events = {};
    this.scope  = null;
  },

  /**
   * Adds a listener.  Multiple can be added per name.  Aliased as `on`.
   *
   * @param {String} name The name of the event
   * @param {Function} handler A callback
   * @return {Emitter} `this` for chaining      
   */
  on: function(name, handler) {
    if (name in this.events === false) { this.events[name] = []; }        

    this.events[name].push(handler);
    debug('Emitter.on("' + name + '")');

    return this;
  },

  /**
   * Triggers all matching listeners.
   *
   * @param {String} name The name of the event
   * @return {Emitter} `this` for chaining   
   */
  emit: function(name) {
    if (name in this.events === false) { return this; }

    for (var i = 0; i < this.events[name].length; i++) {
      debug('Fired event: "' + name + '"');
      this.events[name][i].apply(this.scope || this, Array.prototype.slice.call(arguments, 1));       
    }

    return this;
  },

  /**
   * Removes all matching listeners.
   *
   * @param {String} name The name of the event
   * @return {Emitter} `this` for chaining
   */
  offAll: function(name) {
    if (!name) {
      for (var e in this.events) {
        delete this.events[e];
      }
    } else {
      if (name in this.events === false) { return this; }
      delete this.events[name];        
    }

    return this;
  },

  /**
   * Removes a listener based on an index.
   *
   * @private
   * @param {String} name The name of the event
   * @param {Number} index The index of the event 
   */
  offAt: function(name, index) {
    var array = this.events[name],
        rest  = array.slice(index + 1);

    array.length = index;
    array.push.apply(array, rest);
    this.events[name] = array;
  },

  /**
   * Removes a listener based on the handler function.
   *
   * @param {String} name The name of the event
   * @param {Function} handler The handler function to remove
   * @return {Emitter} `this` for chaining
   */
  off: function(name, handler) {
    if (name in this.events === false) { return this; }

    // remove all events handlers by this name
    if (!handler) {
      return this.offAll(name);
    } else { // remove all events handlers == 'handler' by this name
      for (var i = 0; i < this.events[name].length; i++) {
        if (this.events[name][i] == handler) {
          this.offAt(name, i);
          return this;
        }
      }
    } 

    return this;
  }

}); 
},{"./selfish":33}],24:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */
var Lang = require('./lang'),
    RTypes = require('./rtypes'),
    R = RTypes.r,
    DeployR = RTypes.deployr;

function formatDates(dates, type) {
    var formats = [];

    for (var i = 0; i < dates.length; i++) {
        formats.push(formatDate(dates[i], type));
    }

    return formats;
}

function formatDate(date, type) {    
   var year   = date.getFullYear(),
       month  = (date.getMonth() + 1),
       day    = date.getDate(),    
       hour   = date.getHours(),
       min    = date.getMinutes(),
       sec    = date.getSeconds(),
       zone   = date.getTimezoneOffset(),
       format = '';

       month  = (month < 10 ? '0' + month : month);
       hour   = (hour < 10 ? '0' + hour : hour);
       min    = (min < 10 ? '0' + min : min);
       sec    = (sec < 10 ? '0' + sec : sec);       
       format = year + '-' + month + '-' + day;

    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }
   
    if (type === DeployR.RPOSIX_DATE || type === DeployR.RPOSIX_DATE_VECTOR) {
        var time  = hour + ':' + min + ':' + sec,
            a = -zone,
            b = "+";

        if (a < 0) {
            a = -a;
            b = "-";
        }

        zone = b + leftZeroFill((a / 60), 2) + '' + leftZeroFill(a % 60, 2);
        format += (' ' + time + ' ' + zone);
    }

    return format;
}

function encodeEmbeddedDataframe(obj, rdf) {
    var dfValue = obj.value;
    for (var index = 0; index < dfValue.length; index++) {
        var dfObj = dfValue[index];
        if (dfObj.type === DeployR.RDATAFRAME) {
            rdf = encodeEmbeddedDataframe(dfObj, rdf);
        } else {
            // format dates
            if (RTypes.isDate(dfObj.type)) {
                if (Lang.isArray(dfObj.value)) {
                    dfObj.value = formatDates(dfObj.value, dfObj.type);
                } else {
                    dfObj.value = formatDate(dfObj.value, dfObj.type);
                }
            }

            dfObj.type = RTypes.deployrToR(dfObj.type);
            rdf.value.push(dfObj);            
        }

    }
    return rdf;
};

function encodeDataframe(obj) {
    var rdf = {
            type: R.DATAFRAME,
            value: [],
            name: obj.name
        },
        dfValue = obj.value;

    for (var index = 0; index < dfValue.length; index++) {
        var dfObj = dfValue[index];

        if (dfObj.type === DeployR.RDATAFRAME) {
            rdf = encodeEmbeddedDataframe(dfObj, rdf);
        } else {
            // format dates
            if (RTypes.isDate(dfObj.type)) {
                if (Lang.isArray(dfObj.value)) {
                    dfObj.value = formatDates(dfObj.value, dfObj.type);
                } else {
                    dfObj.value = formatDate(dfObj.value, dfObj.type);
                }
            }

            dfObj.type = RTypes.deployrToR(dfObj.type);
            rdf.value.push(dfObj);
        }

    }
    return rdf;
};

function encodeList(obj) {
    var rlist = {
            type: R.LIST,
            value: [],
            name: obj.name
        },
        dfValue = obj.value,
        r;

    for (var index = 0; index < dfValue.length; index++) {
        var dfObj = dfValue[index];

        switch (dfObj.type) {
            case DeployR.RDATAFRAME:
                r = encodeDataframe(dfObj);
                break;

            case DeployR.RLIST:
                r = encodeList(dfObj);
                break;

            case DeployR.RNUMERIC_MATRIX:
            case DeployR.RINTEGER_MATRIX:
            case DeployR.RBOOLEAN_MATRIX:
            case DeployR.RSTRING_MATRIX:
                r = {
                    name: dfObj.name,
                    type: R.MATRIX,
                    value: dfObj.value
                };
                break;

            case DeployR.RDATE:
            case DeployR.RPOSIX_DATE:
                r = {
                    name: dfObj.name,
                    type: R.DATE,
                    format: dfObj.format,
                    value: formatDate(dfObj.value, dfObj.type)
                };
                break;

            case DeployR.RFACTOR:
            case DeployR.RORDERED:
                r = {
                    name: dfObj.name,
                    type: R.FACTOR,
                    ordered: dfObj.ordered,
                    labels: dfObj.labels,
                    levels: dfObj.levels,
                    value: dfObj.value
                };
                break;

            case DeployR.RSTRING:
            case DeployR.RBOOLEAN:
            case DeployR.RNUMERIC:
            case DeployR.RINTEGER:
                r = {
                    name: dfObj.name,
                    type: R.PRIMITIVE,
                    value: dfObj.value
                };
                break;

            case DeployR.RNUMERIC_VECTOR:
            case DeployR.RINTEGER_VECTOR:
            case DeployR.RBOOLEAN_VECTOR:
            case DeployR.RSTRING_VECTOR:
                r = {
                    name: dfObj.name,
                    type: R.VECTOR,
                    value: dfObj.value
                };
                break;

            case DeployR.RDATE_VECTOR:
            case DeployR.RPOSIX_DATE_VECTOR:
                r = {
                    name: dfObj.name,
                    type: R.VECTOR,                    
                    value: formatDates(dfObj.value, dfObj.type),
                    format: dfObj.format
                };
                break;

            default:
                throw new Error('No RDataType found for "' + dfObj.type + '"');
                break;
        }

        rlist.value.push(r);
    }
    return rlist;
};

module.exports = {

    /**
     * Flattens a given <code>Revolution.RData</code> type into a JSON string
     * representing the
     * expected DeployR input format.
     *
     * @method parseInputs
     * @public
     * @param {Array} rdata An Array of RData Objects to be flattened.
     * @return {String} The flattend RData JSON string representing the DeployR
     *                  input format.
     */
    encode: function(rdata) {
        var r = {};

        for (var index = 0; index < rdata.length; index++) {
            var obj = rdata[index];

            switch (obj.type) { // -- DeployR Type -- //

                case DeployR.RDATAFRAME:
                    r[obj.name] = encodeDataframe(obj);
                    break;

                case DeployR.RLIST:
                    r[obj.name] = encodeList(obj);
                    break;

                case DeployR.RNUMERIC_MATRIX:
                case DeployR.RINTEGER_MATRIX:
                case DeployR.RBOOLEAN_MATRIX:
                case DeployR.RSTRING_MATRIX:
                    r[obj.name] = {
                        type: R.MATRIX,
                        value: obj.value
                    };
                    break;

                case DeployR.RDATE:
                case DeployR.RPOSIX_DATE:
                    r[obj.name] = {
                        type: R.DATE,
                        format: obj.format,                        
                        value: formatDate(obj.value, obj.type)
                    };
                    break;

                case DeployR.RFACTOR:
                case DeployR.RORDERED:                
                    r[obj.name] = {
                        type: R.FACTOR,
                        ordered: obj.ordered,
                        labels: obj.labels,
                        levels: obj.levels,
                        value: obj.value
                    };
                    break;

                case DeployR.RSTRING:
                case DeployR.RBOOLEAN:
                case DeployR.RNUMERIC:
                case DeployR.RINTEGER:
                    r[obj.name] = {
                        type: R.PRIMITIVE,
                        value: obj.value
                    };
                    break;

                case DeployR.RNUMERIC_VECTOR:
                case DeployR.RINTEGER_VECTOR:
                case DeployR.RBOOLEAN_VECTOR:
                case DeployR.RSTRING_VECTOR:
                    r[obj.name] = {
                        type: R.VECTOR,
                        value: obj.value
                    };
                    break;

                case DeployR.RDATE_VECTOR:
                case DeployR.RPOSIX_DATE_VECTOR:
                    r[obj.name] = {
                        type: R.VECTOR,            
                        value: formatDates(obj.value, obj.type),
                        format: obj.format
                    };
                    break;

                default:
                    throw new Error('No RDataType found for "' + obj.type + '"');
                    break;
            }
        }

        return (JSON.stringify(r));
    }
};
},{"./lang":26,"./rtypes":32}],25:[function(require,module,exports){
 var optional = require('./optional'),
     WS       = optional('ws'),
     Queue    = require('./queue'),     
     Emitter  = require('./emitter'),
     Base     = require('./selfish').Base,
     merge    = require('./utils').merge;

/**
 * Initialize a new `EventStream` with the given set of `options`.
 *
 * @param {Object} options
 * @api private
 */
var EventStream = Base.extend(Emitter, {   

  initialize: function initialize(host, options) {
    Emitter.initialize.call(this, {});

    this.host        = host;
    this.options     = options || {};
    this.options.log = this.options.log || this.LOG.error;
    this.ws          = null;
    this.q           = new Queue();
    this.channel     = {};     
  },  

  LOG: { 
    info: 'info', 
    debug: 'debug', 
    error: 'error' 
  },
  
  open: function(options) {    
    var self   = this,
        uri    = (this.host || '') + '/deployr/r/event/stream?',
        params = [];

    options = options || {};
    options.headers = options.headers || {};
    options = this.options = merge(options, this.channel);    

    this.cookies = !this.cookies ? options.headers.Cookie : this.cookies;

    // -- append option parameters --
    if (options.project) {
      params.push('project=' + options.project);
    } else {
      if (options.job) {
        params.push('job=' + options.job);
      }
    }

    if (options.management) {
      params.push('managementEventOnly=true');
    } else {
      if (options.httponly) {
        params.push('httpEventOnly=true');
      } else {
        if (options.revoonly) {
          params.push('revoEventOnly=true');
        }
      }
    }

    uri += params.join('&').substr(0);
    uri = uri.replace(/^http/,'ws');

    this.q.yield(true);
    this.q.add(function() {

      var headers = this.cookies ? { 'Cookie': this.cookies } : {};
      this.emit('es:connecting', { uri: uri, headers: headers });

      var ws = new WS(uri, 'http', { headers: headers });

      ws.onopen = function (message) {
        self.emit('es:open', message);
      };

      var _message = '';
      ws.onmessage = function (message) {
        try {          
          if (message.data.split('!|!')[1]) {
            _message = _message + message.data.split('!|!')[1];
            message = JSON.parse(_message);
            _message = '';
            var type = message.deployr.response.event.type;
            self.emit('es:' + type.replace('Event', ''), message);
          }
        } catch (e) {} 
      };

      ws.onerror = function (err) { self.emit('es:error', err); };
      ws.onclose = function (message) { self.emit('es:disconnect', message); };

      this.ws = ws;
    }, this);

    if (options.force) { this.flush(); }

    return this;    
  },

  close: function() {
    if (this.ws) { this.ws.close(); }

    return this;
  },

  error: function(fn) {
    this.on('es:error', fn);

    return this;
  },  

  all: function() {
    this.channel = { revoonly: true };  // revoEventOnly=true

    return this;
  },

  session: function() {
    this.channel = { httponly: true }; //httpEventOnly=true

    return this;
  },

  project: function(project) {
    this.channel = { project: project }; // project=12345

    return this;
  },

  job: function(job) {
    this.channel = { job: job }; //job=12345

    return this;
  },

  management: function() {
    this.channel = { management: true }; //managementEventOnly=true

    return this;
  },

  flush: function() {
    this.q.yield(false);
    this.q.flush();
  },

  share: function(cookies) {
    this.cookies = cookies;
  }

});

module.exports = EventStream;

},{"./emitter":23,"./optional":28,"./queue":29,"./selfish":33,"./utils":34}],26:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 *
 * This component is a DeployR port of yui-lang.js by Yahoo!
 *
 * Software License Agreement (BSD License)
 * Copyright (c) 2013, Yahoo! Inc. All rights reserved.
 *
 * Redistribution and use of this software in source and binary forms, with or 
 * without modification, are permitted provided that the following conditions 
 * are met:
 *
 * Redistributions of source code must retain the above copyright notice, this 
 * list of conditions and the following disclaimer. Redistributions in binary 
 * form must reproduce the above copyright notice, this list of conditions and 
 * the following disclaimer in the documentation and/or other materials provided 
 * with the distribution.
 *
 * Neither the name of Yahoo! Inc. nor the names of YUI's contributors may be 
 * used to endorse or promote products derived from this software without 
 * specific prior written permission of Yahoo! Inc.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  
 * POS SIBILITY OF SUCH DAMAGE.
 */

/**
 * Provides core language utilites and extensions used throughout DeployR.
 *
 * @class Lang
 * @static
 */
var L = {}, 
	TOSTRING = Object.prototype.toString, 
	TYPES = {	
		'undefined' : 'undefined',
		'number' : 'number',
		'boolean' : 'boolean',
		'string' : 'string',
		'[object Function]' : 'function',
		'[object RegExp]' : 'regexp',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object Error]' : 'error'
	}, unsafeNatives = false;

/**
 * Determines whether or not the provided item is null.
 * @method isNull
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is null.
 */
L.isNull = function(o) {
	return o === null;
};

/**
 * Determines whether or not the provided item is undefined.
 * @method isUndefined
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is undefined.
 */
L.isUndefined = function(o) {
	return typeof o === 'undefined';
};

/**
 * Determines whether or not the provided item is of type object
 * or function. Note that arrays are also objects, so
 * <code>Y.Lang.isObject([]) === true</code>.
 * @method isObject
 * @static
 * @param o The object to test.
 * @param failfn {boolean} fail if the input is a function.
 * @return {boolean} true if o is an object.
 * @see isPlainObject
 */
L.isObject = function(o, failfn) {
	var t = typeof o;
	return (o && (t === 'object' || (!failfn && (t === 'function' || L.isFunction(o))))) || false;
};
/**
 * Determines whether or not the provided item is an array.
 *
 * Returns `false` for array-like collections such as the function `arguments`
 * collection or `HTMLElement` collections.
 *
 * @method isArray
 * @param o The object to test.
 * @return {boolean} true if o is an array.
 * @static
 */
L.isArray = (!unsafeNatives && Array.isArray) ||
function(o) {
	return L.type(o) === 'array';
};

L.isFunction = function isFunctionA(o) {
	return (typeof(o) === "function");
};

/**
 * Determines whether or not the provided item is a boolean.
 * @method isBoolean
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is a boolean.
 */
L.isBoolean = function(o) {
	return typeof o === 'boolean';
};

/**
 * Determines whether or not the supplied item is a date instance.
 * @method isDate
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is a date.
 */
L.isDate = function(o) {
	return L.type(o) === 'date' && o.toString() !== 'Invalid Date' && !isNaN(o);
};

/**
 * Determines whether or not the provided item is a legal number.
 * @method isNumber
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is a number.
 */
L.isNumber = function(o) {
	return typeof o === 'number' && isFinite(o);
};

/**
 * Determines whether or not the provided item is a string.
 * @method isString
 * @static
 * @param o The object to test.
 * @return {boolean} true if o is a string.
 */
L.isString = function(o) {
	return typeof o === 'string';
};

/**
 * Returns a string representing the type of the item passed in.
 *
 * @method type
 * @param o the item to test.
 * @return {string} the detected type.
 * @static
 */
L.type = function(o) {
	return TYPES[ typeof o] || TYPES[TOSTRING.call(o)] || ( o ? 'object' : 'null');
};

module.exports = L;
},{}],27:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */
 
var Logger = {},
    loggerMap = {},
    globalLogger;

/**
 * Universal stdout|stderr printer
 */
function log(messages, context) {	
	if (!console) { return; }

	function sep(level) {
		var sep = '=========================================================' +
		          '=========================================================\n',
		    offset = 0;

		if (level === Logger.DEBUG || level === Logger.ERROR) offset = 8;
		else if (level === Logger.INFO || level === Logger.WARN) offset = 8;
		else offset = 7;

		return { start: sep.substring(offset), end: sep };
	}

	var hdlr,
	    args = Array.prototype.slice.call(messages, 0),
	    name = context.name,
	    error = context.level === Logger.ERROR,
  	    delim = sep(context.level);

  	if (context.level === Logger.WARN && console.warn) {
  		hdlr = 'warn';
  	} else if (context.level === Logger.ERROR && console.error) {
  		hdlr = 'error';
  	} else if (context.level === Logger.INFO && console.info) {
  		hdlr = 'info';
  	} else {
  		hdlr = 'log';
  	}

  	// -- custom format logging statement for deployr request/response/error --
  	args.unshift('[' + (error ? Logger.ERROR.name : name) + '] ' + delim.start);
  	args.push(delim.end);

  	console[hdlr](args[0], [args[1] + ' ---> ' + args[2]['call']]);

    for (var i = 2; i < args.length; i++) { console.log(args[i]); }  
}

/**
 * Logging category by id.
 */
function Category(id, level, fn) {
	this.id = id;
	this.context = level || Logger.DEBUG;
}

Category.prototype = {	
	log: function(level, msgArgs) {
		if (level.value >= this.context.value) {			
			log(msgArgs, { 
				level: level,
				name: this.context.name,
				value: this.context.value
			});		
		}
	},

	debug: function () {		
		this.log(Logger.DEBUG, arguments);
	},

	error: function () {
		this.log(Logger.ERROR, arguments);
	},

	info: function () {		
		this.log(Logger.INFO, arguments);
	},

	warn: function () {
		this.log(Logger.WARN, arguments);
	},

	setLevel: function(level) {
		if (level && 'value' in level) {
			this.context = level;
		}
	}
};

Logger.DEBUG = { value: 1, name: 'DEBUG' };
Logger.INFO  = { value: 2, name: 'INFO' };
Logger.WARN  = { value: 4, name: 'WARN' };
Logger.ERROR = { value: 8, name: 'ERROR' };
Logger.OFF   = { value: 99, name: 'OFF' };   		

Logger.setLevel = function(newLevel) {
	globalLogger.setLevel(newLevel);
};

Logger.debug = function () {
	globalLogger.debug.apply(globalLogger, arguments);
};

Logger.info = function () {
	globalLogger.info.apply(globalLogger, arguments);
};

Logger.warn = function () {
	globalLogger.warn.apply(globalLogger, arguments);
};

Logger.error = function () {
	globalLogger.error.apply(globalLogger, arguments);
};

Logger.get = function (id, level, fn) {	
	return (loggerMap[id] || (function() {
		loggerMap[id] = new Category(id, level, fn);
		return loggerMap[id];
	})());
};

// --- setup the global logger ---
globalLogger = Logger.get('global');

module.exports 	= Logger;

},{}],28:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */
 
module.exports = function(module) {
  try {
    return require(module);
  } catch (e) {}
};
},{}],29:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

function Queue() {
  this.emptyCallback = null;
  this.callbacks = [];
  this.yielded = false;
  this.response = null;
  this.responseChain = [];  
}

Queue.prototype = {

  add: function(fn, ctx, defer) {
    // currently not waiting and there is no defer delay just make call
    if (!this.yielded && !defer) {      
      fn.apply(ctx || this, [this.response]);
    } else { // add to queue
      this.callbacks.push({ fn: fn, ctx: ctx });
    }
  },

  size: function() {
    return this.callbacks.length;
  },

  isEmpty: function() {
    return this.callbacks.length === 0;
  },

  empty: function(fn, ctx) {
    this.emptyCallback = { fn: fn, ctx: ctx };
  },

  yield: function(yield) {
    this.yielded = yield;
  },

  take: function(response, error, args) { 
    var cb;

    if (response) {
      this.response = response;
      this.responseChain.push(response);
    }


    if (!this.yielded && this.callbacks[0]) {
      cb = this.callbacks.shift();
      cb.fn.apply(cb.ctx || this, [this.responseChain, error, args]);

      // notify that the queue is now empty   
      if (this.callbacks[0] && this.emptyCallback) {
        this.emptyCallback.fn.call(this.emptyCallback.ctx || this);         
      }
    }
  },
  
  flush: function(response, error, args) {        
    if (response) {
      this.response = response;
      this.responseChain.push(response);
    }

    // pop and call next inline
    while (this.callbacks[0]) {
      if (this.yielded) { break; }
      var cb = this.callbacks.shift();
      cb.fn.apply(cb.ctx || this, [this.responseChain, error, args]);

      // notify that the queue is now empty
      if (this.callbacks[0] && this.emptyCallback) {
        this.emptyCallback.fn.call(this.emptyCallback.ctx || this);         
      }
    }
  }
};

module.exports = Queue;
},{}],30:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var Base   = require('./selfish').Base,
    RTypes = require('./rtypes');

module.exports = Base.extend(RTypes, {
	initialize: function initialize(name, value, options) {  	
		this.name  = name;
		this.value = value;
		this.options = options || {};
	},

	numeric: function () {
		return this.assert({
			type: this.deployr.RNUMERIC,
			name: this.name, 
			value: this.value,
			toString: this.toString
		});
	},	

	integer: function () {
		return this.assert({ 
			type: this.deployr.RINTEGER,
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},
	
	logical: function () {
		return this.assert({ 
			type: this.deployr.RBOOLEAN, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},
	
	character: function () {
		return this.assert({ 
			type: this.deployr.RSTRING, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},
	
	date: function () {
		return this.assert({ 
			type: this.deployr.RDATE,
			name: this.name, 
			value: this.value,
			format: 'yyyy-MM-dd',
			toString: this.toString
		}); 
	},

	posixct: function () {
		return this.assert({ 
			type: this.deployr.RPOSIX_DATE, 
			name: this.name, 
			value: this.value,
			format: 'yyyy-MM-dd HH:mm:ss Z',
			toString: this.toString
		}); 
	},	
	
	numericVector: function () { 
		return this.assert({ 
			type: this.deployr.RNUMERIC_VECTOR,
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},
	
	integerVector: function () {
		return this.assert({ 
			type: this.deployr.RINTEGER_VECTOR, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},
	
	logicalVector: function () { 
		return this.assert({ 
			type: this.deployr.RBOOLEAN_VECTOR, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},
	
	characterVector: function () { 
		return this.assert({ 
			type: this.deployr.RSTRING_VECTOR, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},  
	
	dateVector: function () { 
		return this.assert({ 
			type: this.deployr.RDATE_VECTOR, 
			name: this.name, 
			value: this.value,
			format: 'yyyy-MM-dd',
			toString: this.toString
		}); 
	},	
	
	posixctVector: function () { 
		return this.assert({ 
			type: this.deployr.RPOSIX_DATE_VECTOR, 
			name: this.name, 
			value: this.value,
			format: 'yyyy-MM-dd HH:mm:ss Z',
			toString: this.toString
		}); 
	},
	
	list: function () {
		return this.assert({ 
			type: this.deployr.RLIST, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},
	
	dataframe: function () { 
		return this.assert({ 
			type: this.deployr.RDATAFRAME, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},

	factor: function () {
		var opts = this.options;

		return this.assert( { 
			type: this.deployr.RFACTOR, 
			name: this.name, 
			value: this.value,
			ordered: false,
			levels: opts.levels,
			labels: opts.labels,
			toString: this.toString
		}); 
	},

	ordered: function () {
		var opts = this.options;

		return this.assert( { 
			type: this.deployr.RORDERED, 
			name: this.name, 
			value: this.value,
			ordered: true,
			levels: opts.levels,
			labels: opts.labels,
			toString: this.toString
		}); 
	},		

	numericMatrix: function () { 
		return this.assert({ 
			type: this.deployr.RNUMERIC_MATRIX, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},

	integerMatrix: function () { 
		return this.assert({ 
			type: this.deployr.RINTEGER_MATRIX, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},

	logicalMatrix: function () { 
		return this.assert({ 
			type: this.deployr.RBOOLEAN_MATRIX, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},

	characterMatrix: function () {
		return this.assert({ 
			type: this.deployr.RSTRING_MATRIX, 
			name: this.name, 
			value: this.value,
			toString: this.toString
		}); 
	},

	toString: function() {
		var opts   = this.options || {},
		    levels = opts.levels ? '[ levels = ' + opts.levels + ']' : '',
		    labels = opts.labels ? '[ labels = ' + opts.labels + ']' : '';

		return '[ name = '  + this.name + ' ] ' +
		       '[ value = ' + this.value + ' ] ' +
		       '[ type = '  + this.type + ' ] ' +
		       levels + labels;		       
	}
});
},{"./rtypes":32,"./selfish":33}],31:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var Base   = require('./selfish').Base,
    RTypes = require('./rtypes'),
    Lang   = require('./lang'),
    RInput = require('./rinput'); 

function create(type, name, value, options) {
	var rinput;

	if (Lang.isObject(name)) {
		rinput = name;
		if (!rinput.type !== type) {
			throw new Error('IllegalArgumentError:' + 
				'Expecting "' + type + '" but found "' + rinput.type + '"');
		}
	} else {
	    rinput = RInput.new(name, value, options)[type]();
	} 

	return rinput;
}

module.exports = Base.extend(RTypes, {	
	numeric: function (name, value) {
		this.inputs.push(create(this.deployr.RNUMERIC, name, value));
		return this;
	},
	
	integer: function (name, value) {
		this.inputs.push(create(this.deployr.RINTEGER, name, value));
		return this; 
	},
	
	logical: function (name, value) {
		this.inputs.push(create(this.deployr.RBOOLEAN, name, value));
		return this; 
	},
	
	character: function (name, value) {
		this.inputs.push(create(this.deployr.RSTRING, name, value));
		return this; 
	},
	
	date: function (name, value) {
		this.inputs.push(create(this.deployr.RDATE, name, value));
		return this; 
	},

	posixct: function (name, value) {
		this.inputs.push(create(this.deployr.RPOSIX_DATE, name, value));
		return this; 
	},	
	
	numericVector: function (name, value) { 
		this.inputs.push(create(this.deployr.RNUMERIC_VECTOR, name, value));
		return this; 
	},
	
	integerVector: function (name, value) {
		this.inputs.push(create(this.deployr.RINTEGER_VECTOR, name, value));
		return this; 
	},
	
	logicalVector: function (name, value) { 
		this.inputs.push(create(this.deployr.RBOOLEAN_VECTOR, name, value));
		return this; 
	},
	
	characterVector: function (name, value) { 
		this.inputs.push(create(this.deployr.RSTRING_VECTOR, name, value));
		return this; 
	},  
	
	dateVector: function (name, value) { 
		this.inputs.push(create(this.deployr.RDATE_VECTOR, name, value));
		return this; 
	},	
	
	posixctVector: function (name, value) { 
		this.inputs.push(create(this.deployr.RPOSIX_DATE_VECTOR, name, value));
		return this; 
	},
	
	list: function (name, value) {
		this.inputs.push(create(this.deployr.RLIST, name, value));
		return this; 
	},
	
	dataframe: function (name, value) { 
		this.inputs.push(create(this.deployr.RDATAFRAME, name, value));
		return this; 
	},	

	factor: function (name, value, levels, labels) {
		var opts = { levels: levels, labels: labels };
		this.inputs.push(create(this.deployr.RFACTOR, name, value, opts));
		return this;
	},

	ordered: function (name, value, levels, labels) {
		var opts = { levels: levels, labels: labels };
		this.inputs.push(create(this.deployr.RORDERED, name, value, opts));
		return this;
	},		

	numericMatrix: function (name, value) { 
		this.inputs.push(create(this.deployr.RNUMERIC_MATRIX, name, value));
		return this; 
	},

	integerMatrix: function (name, value) { 
		this.inputs.push(create(this.deployr.RINTEGER_MATRIX, name, value));
		return this; 
	},

	logicalMatrix: function (name, value) { 
		this.inputs.push(create(this.deployr.RBOOLEAN_MATRIX, name, value));
		return this; 
	},

	characterMatrix: function (name, value) {
		this.inputs.push(create(this.deployr.RSTRING_MATRIX, name, value));
		return this;
	}
});
},{"./lang":26,"./rinput":30,"./rtypes":32,"./selfish":33}],32:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more 
 * details.
 */

var Base = require('./selfish').Base,
    Lang = require('./lang'),
    map  = {}; // deployr->To->R catalog

module.exports = Base.extend({
	r: {
		PRIMITIVE: 'primitive',
		DATAFRAME: 'dataframe',
		LIST: 'list',
		MATRIX: 'matrix',
		DATE: 'date',
		FACTOR: 'factor',
		VECTOR: 'vector'
	},

	deployr: {
		RBOOLEAN: 'logical',
		RNUMERIC: 'numeric',
		RINTEGER: 'integer',
		RSTRING: 'character',
		RDATE: 'date',
		RPOSIX_DATE: 'posixct',
		RBOOLEAN_VECTOR: 'logicalVector',
		RNUMERIC_VECTOR:'numericVector',
		RINTEGER_VECTOR: 'integerVector',	
		RSTRING_VECTOR: 'characterVector',
		RDATE_VECTOR: 'dateVector',
		RPOSIX_DATE_VECTOR: 'posixctVector',
		RLIST: 'list',
		RDATAFRAME: 'dataframe',
		RFACTOR: 'factor',
		RORDERED: 'ordered',		
		RBOOLEAN_MATRIX: 'logicalMatrix',
		RNUMERIC_MATRIX: 'numericMatrix',
		RINTEGER_MATRIX: 'integerMatrix',		
		RSTRING_MATRIX: 'characterMatrix'
	},

	isDate: function(type) {
		return (type === this.deployr.RDATE || 
		        type === this.deployr.RPOSIX_DATE || 
		        type === this.deployr.RDATE_VECTOR ||
		        type === this.deployr.RPOSIX_DATE_VECTOR ||
		        type === this.r.DATE);
	},

	deployrToR: function(type) {	
		var deployr = this.deployr,
		    r       = this.r;

		if (!map[type]) { // build catalog only once	
			map[deployr.RBOOLEAN]           = r.PRIMITIVE;
			map[deployr.RNUMERIC]           = r.PRIMITIVE;
			map[deployr.RINTEGER]           = r.PRIMITIVE;
			map[deployr.RSTRING]            = r.PRIMITIVE;
			map[deployr.RDATE]              = r.DATE;
			map[deployr.RPOSIX_DATE]        = r.DATE;
			map[deployr.RBOOLEAN_VECTOR]    = r.VECTOR;
			map[deployr.RNUMERIC_VECTOR]    = r.VECTOR;
			map[deployr.RINTEGER_VECTOR]    = r.VECTOR;
			map[deployr.RSTRING_VECTOR]     = r.VECTOR;
			map[deployr.RDATE_VECTOR]       = r.VECTOR;
			map[deployr.RPOSIX_DATE_VECTOR] = r.VECTOR;
			map[deployr.RLIST]              = r.LIST;
			map[deployr.RDATAFRAME]         = r.DATAFRAME;
			map[deployr.RFACTOR]            = r.FACTOR;
			map[deployr.RORDERED]           = r.FACTOR;
			map[deployr.RBOOLEAN_MATRIX]    = r.MATRIX;
			map[deployr.RNUMERIC_MATRIX]    = r.MATRIX;
			map[deployr.RINTEGER_MATRIX]    = r.MATRIX;
			map[deployr.RSTRING_MATRIX]     = r.MATRIX;
		}

		return map[type];		
	},

	/**
	 * Assert that the `rinput` value is the correct JavaScript Data Type.
	 */
	assert: function (rinput) {
		var deployr = this.deployr,
    		NOOP    = null,
		    values  = rinput.value,
		    fn;

		values = !Lang.isArray(values) ? [values] : values;

		for (var i = 0; i < values.length; i++) {
			var value = values[i];

			switch (rinput.type) {
				case deployr.RNUMERIC :
				case deployr.RNUMERIC_VECTOR :
				case deployr.RNUMERIC_VECTOR :
				fn = Lang.isNumber;
				// support string numbers
				var val = parseFloat(value);
			    value = isNaN(val) ? value : val; 
			    break;

			    case deployr.RINTEGER :
			    case deployr.RINTEGER_VECTOR :
			    fn = Lang.isNumber;
			    // support string numbers
			    var val = parseFloat(value);
			    value = isNaN(val) ? value : val; 
			    break;

			    case deployr.RBOOLEAN :
			    case deployr.RBOOLEAN_VECTOR :
			    fn = Lang.isBoolean;
			    break;
			    
			    case deployr.RSTRING :
			    case deployr.RSTRING_VECTOR :	
			    fn = Lang.isString;
			    break;

			    case deployr.RDATE :
			    case deployr.RPOSIX_DATE :
			    case deployr.RDATE_VECTOR :
			    case deployr.RPOSIX_DATE_VECTOR :
			    fn = Lang.isDate;
			    break;

			    case deployr.RFACTOR :
			    case deployr.RORDERED :			    
			    case deployr.RDATAFRAME :
			    case deployr.RINTEGER_MATRIX :
			    case deployr.RBOOLEAN_MATRIX :
			    case deployr.RSTRING_MATRIX :	    
			    fn = NOOP;
			    break
			}

			if (fn && !fn(value)) {
				throw new Error('RInputFormatError: ' + '"' + value + 
					'" is not a valid "' + rinput.type + '" type.');
			}
		}

		return rinput;
	}
});
},{"./lang":26,"./selfish":33}],33:[function(require,module,exports){
/*!
 * https://github.com/Gozala/selfish
 */

/* vim:set ts=2 sw=2 sts=2 expandtab */
/*jshint undef: true es5: true node: true devel: true evil: true
         forin: true latedef: false supernew: true */
/*global define: true */

!(typeof define !== "function" ? function($){ $(null, typeof exports !== 'undefined' ? exports : window); } : define)(function(require, exports) {

"use strict";

exports.Base = Object.freeze(Object.create(Object.prototype, {
  /**
   * Creates an object that inherits from `this` object (Analog of
   * `new Object()`).
   * @examples
   *
   *    var Dog = Base.extend({
   *      bark: function bark() {
   *        return 'Ruff! Ruff!'
   *      }
   *    });
   *    var dog = Dog.new();
   */
  'new': { value: function create() {
    var object = Object.create(this);
    object.initialize.apply(object, arguments);
    return object;
  }},
  /**
   * When new instance of the this prototype is created it's `initialize`
   * method is called with all the arguments passed to the `new`. You can
   * override `initialize` to set up an instance.
   */
  initialize: { value: function initialize() {
  }},
  /**
   * Merges all the properties of the passed objects into `this` instance (This
   * method can be used on instances only as prototype objects are frozen).
   *
   * If two or more argument objects have own properties with the same name,
   * the property is overridden, with precedence from right to left, implying,
   * that properties of the object on the left are overridden by a same named
   * property of the object on the right.
   *
   * @examples
   *
   *    var Pet = Dog.extend({
   *      initialize: function initialize(options) {
   *        // this.name = options.name -> would have thrown (frozen prototype)
   *        this.merge(options) // will override all properties.
   *      },
   *      call: function(name) {
   *        return this.name === name ? this.bark() : ''
   *      },
   *      name: null
   *    })
   *    var pet = Pet.new({ name: 'Benzy', breed: 'Labrador' })
   *    pet.call('Benzy')   // 'Ruff! Ruff!'
   */
  merge: { value: function merge() {
    var descriptor = {};
    Array.prototype.forEach.call(arguments, function (properties) {
      Object.getOwnPropertyNames(properties).forEach(function(name) {
        descriptor[name] = Object.getOwnPropertyDescriptor(properties, name);
      });
    });
    Object.defineProperties(this, descriptor);
    return this;
  }},
  /**
   * Takes any number of argument objects and returns frozen, composite object
   * that inherits from `this` object and combines all of the own properties of
   * the argument objects. (Objects returned by this function are frozen as
   * they are intended to be used as types).
   *
   * If two or more argument objects have own properties with the same name,
   * the property is overridden, with precedence from right to left, implying,
   * that properties of the object on the left are overridden by a same named
   * property of the object on the right.
   * @examples
   *
   *    // ## Object composition ##
   *
   *    var HEX = Base.extend({
   *      hex: function hex() {
   *        return '#' + this.color;
   *      }
   *    })
   *
   *    var RGB = Base.extend({
   *      red: function red() {
   *        return parseInt(this.color.substr(0, 2), 16);
   *      },
   *      green: function green() {
   *        return parseInt(this.color.substr(2, 2), 16);
   *      },
   *      blue: function blue() {
   *        return parseInt(this.color.substr(4, 2), 16);
   *      }
   *    })
   *
   *    var CMYK = Base.extend(RGB, {
   *      black: function black() {
   *        var color = Math.max(Math.max(this.red(), this.green()), this.blue());
   *        return (1 - color / 255).toFixed(4);
   *      },
   *      cyan: function cyan() {
   *        var K = this.black();
   *        return (((1 - this.red() / 255).toFixed(4) - K) / (1 - K)).toFixed(4);
   *      },
   *      magenta: function magenta() {
   *        var K = this.black();
   *        return (((1 - this.green() / 255).toFixed(4) - K) / (1 - K)).toFixed(4);
   *      },
   *      yellow: function yellow() {
   *        var K = this.black();
   *        return (((1 - this.blue() / 255).toFixed(4) - K) / (1 - K)).toFixed(4);
   *      }
   *    })
   *
   *    var Color = Base.extend(HEX, RGB, CMYK, {
   *      initialize: function Color(color) {
   *        this.color = color;
   *      }
   *    });
   *
   *    // ## Prototypal inheritance ##
   *
   *    var Pixel = Color.extend({
   *      initialize: function Pixel(x, y, hex) {
   *        Color.initialize.call(this, hex);
   *        this.x = x;
   *        this.y = y;
   *      },
   *      toString: function toString() {
   *        return this.x + ':' + this.y + '@' + this.hex();
   *      }
   *    });
   *
   *    var pixel = Pixel.new(11, 23, 'CC3399')
   *    pixel.toString(); // 11:23@#CC3399
   *
   *    pixel.red();      // 204
   *    pixel.green();    // 51
   *    pixel.blue();     // 153
   *
   *    pixel.cyan();     // 0.0000
   *    pixel.magenta();  // 0.7500
   *    pixel.yellow();   // 0.2500
   *
   */
   extend: { value: function extend() {
    return Object.freeze(this.merge.apply(Object.create(this), arguments));
  }}
}));

});
},{}],34:[function(require,module,exports){
/*!
 * Copyright (C) 2010-2014 by Revolution Analytics Inc.
 *
 * This program is licensed to you under the terms of Version 2.0 of the
 * Apache License. This program is distributed WITHOUT
 * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,
 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the
 * Apache License 2.0 (http://www.apache.org/licenses/LICENSE-2.0) for more
 * details.
 */

var Lang = require('./lang');

var get = exports.get = function(s, key) {
    function traverse(obj, fn, parent) {
        for (var i in obj) {
            var result = fn.apply(this, [i, obj[i], parent]);
            if (result) {
                return result;
            } else {
                if (obj[i] instanceof Object && !(obj[i] instanceof Array)) {                
                   traverse(obj[i], fn, i);
               }
            }
        }
    }

    function getProperty(obj, property) {
        var acc = {};
        traverse(obj, function(key, value, parent) {
            if (key === property) {  
                acc = value;
                return acc;
            } else {
                return null;
            }
        });
        return acc;
    }

    function empty(obj) {
        for (var prop in obj) { if (obj.hasOwnProperty(prop)) return obj; }
        return !Lang.isObject(obj) ? obj : null;
    }

    return empty(getProperty(s, key));
};

var inArray = exports.inArray = function(haystack, needle, key) {
    var i, max = haystack.length;

    for (i = 0; i < max; i++) {
        if (key) {
            if (haystack[i][key] === needle) { return haystack[i]; }
        } else {
            if (haystack[i] === needle) { return haystack[i]; }
        }   
    }
    return null;
};

exports.merge = function(to, from) {        
    if (!to || typeof(to) !== 'object') { to = {}; }
    if (!from || typeof(from) !== 'object') { from = {}; }

    for (var k in from) { to[k] = from[k]; }

    return to;
};

exports.workspace = function(obj, name) {
    var ws = get(obj, 'workspace');
    return (ws ? name ? inArray(ws.objects, name, 'name') : ws.objects || ws.object: null);
};

exports.signature = function() {
    var args   = Array.prototype.slice.call(arguments['0'], 0),
        len    = args.length,
        create = false,
        opts   = {},
        api;

    if (len === 1 && Lang.isObject(args[0])) {
        opts = args[0];
        api  = opts.project ? '/r/project/execute/script' :
            '/r/repository/script/execute';
    } else if (len === 1 && Lang.isString(args[0])) {
        args = args[0].split('\/');
        api  = '/r/repository/script/execute'
        opts = {
            author: args[1],
            directory: args[2],
            filename: args[3]
        };
    } else if (len === 2) {
        // ex: .script('/testuser/root/DeployR - Hello World.R', project)
        var project = args[1];
        api = project ? '/r/project/execute/script' : '/r/repository/script/execute';

        args = args[0].split('\/');
        opts = {
            project: project,
            author: args[1],
            directory: args[2],
            filename: args[3]
        };
    } else if (len > 2) {
        // ex: .script('DeployR - Hello World.R', 'testuser', 'root')
        opts = {
            author: args[2],
            directory: args[1],
            filename: args[0]
        };
    }

    // indicate a new project should be created
    if (opts.project && Lang.isBoolean(opts.project)) {
      delete opts['project'];
      create = true;
    }

    return {
        api: api,
        opts: opts,
        create: create
    };
};
},{"./lang":26}],35:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');

/**
 * Root reference for iframes.
 */

var root = 'undefined' == typeof window
  ? this
  : window;

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Determine XHR.
 */

function getXHR() {
  if (root.XMLHttpRequest
    && ('file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
}

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return obj === Object(obj);
}

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(obj[key]));
    }
  }
  return pairs.join('&');
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  this.text = this.req.method !='HEAD' 
     ? this.xhr.responseText 
     : null;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  return parse && str && str.length
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  var type = status / 100 | 0;

  // status / class
  this.status = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status || 1223 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  Emitter.call(this);
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {};
  this._header = {};
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self); 
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
    }

    self.callback(err, res);
  });
}

/**
 * Mixin `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Allow for extension
 */

Request.prototype.use = function(fn) {
  fn(this);
  return this;
}

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.timeout = function(ms){
  this._timeout = ms;
  return this;
};

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.clearTimeout = function(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set header `field` to `val`, or multiple fields with one object.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Get case-insensitive header `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api private
 */

Request.prototype.getHeader = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass){
  var str = btoa(user + ':' + pass);
  this.set('Authorization', 'Basic ' + str);
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.field = function(name, val){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(name, val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(field, file, filename);
  return this;
};

/**
 * Send `data`, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // querystring
 *       request.get('/search')
 *         .end(callback)
 *
 *       // multiple data "writes"
 *       request.get('/search')
 *         .send({ search: 'query' })
 *         .send({ range: '1..5' })
 *         .send({ order: 'desc' })
 *         .end(callback)
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"})
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this.getHeader('Content-Type');

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this.getHeader('Content-Type');
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  if (2 == fn.length) return fn(err, res);
  if (err) return this.emit('error', err);
  fn(res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
  err.crossDomain = true;
  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;
    if (0 == xhr.status) {
      if (self.aborted) return self.timeoutError();
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  if (xhr.upload) {
    xhr.upload.onprogress = function(e){
      e.percent = e.loaded / e.total * 100;
      self.emit('progress', e);
    };
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  xhr.open(this.method, this.url, true);

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var serialize = request.serialize[this.getHeader('Content-Type')];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  // send stuff
  this.emit('request', this);
  xhr.send(data);
  return this;
};

/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(method, url) {
  // callback
  if ('function' == typeof url) {
    return new Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new Request('GET', method);
  }

  return new Request(method, url);
}

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.del = function(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * Expose `request`.
 */

module.exports = request;

},{"emitter":36,"reduce":37}],36:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],37:[function(require,module,exports){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
},{}],38:[function(require,module,exports){
module.exports={
  "name": "deployr",
  "version": "7.4.1",
  "description": "Simplified JavaScript client library for making requests to DeployR.",
  "keywords": [
    "deployr",
    "deployr.io",
    "ajax",
    "R",
    "api",
    "simple"
  ],
  "author": {
    "name": "DeployR - Revolution Analytics Inc."
  },
  "contributors": [
    {
      "name": "Sean Wells"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/deployr/js-client-library.git"
  },
  "homepage": "http://deployr.revolutionanalytics.com/documents/dev/client-jsdoc",
  "scripts": {
    "start": "gulp start",
    "build": "gulp"
  },
  "devDependencies": {
    "browserify": "^9.0.3",
    "gulp": "^3.8.11",
    "gulp-connect": "^2.2.0",
    "gulp-header": "^1.2.2",
    "gulp-jshint": "^1.9.2",
    "gulp-livereload": "^3.8.0",
    "gulp-plumber": "^0.6.6",
    "gulp-uglifyjs": "^0.6.0",
    "gulp-util": "^3.0.4",
    "tape": "^3.5.0",
    "vinyl-source-stream": "^1.0.0"
  },
  "dependencies": {
    "d.js": "^0.6.0",
    "superagent": "^0.21.0",
    "ws": "^0.4.32"
  },
  "main": "deployr.js",
  "engines": {
    "node": ">= 0.10.0"
  },
  "license": "Apache 2.0 License",
  "bugs": {
    "url": "https://github.com/deployr/js-client-library/issues"
  },
  "directories": {
    "example": "examples",
    "test": "test"
  },
  "gitHead": "3c955e1898bedfaf562b0b751674c4ebf7d602f6",
  "_id": "deployr@7.4.1",
  "_shasum": "3cc53c6cea2366525e21898bb6005f42e979b4e3",
  "_from": "deployr@>=7.4.1 <8.0.0",
  "_npmVersion": "1.4.28",
  "_npmUser": {
    "name": "swells",
    "email": "sean.wells.sc@gmail.com"
  },
  "maintainers": [
    {
      "name": "swells",
      "email": "sean.wells.sc@gmail.com"
    }
  ],
  "dist": {
    "shasum": "3cc53c6cea2366525e21898bb6005f42e979b4e3",
    "tarball": "http://registry.npmjs.org/deployr/-/deployr-7.4.1.tgz"
  },
  "_resolved": "https://registry.npmjs.org/deployr/-/deployr-7.4.1.tgz",
  "readme": "ERROR: No README data found!"
}

},{}],39:[function(require,module,exports){
module.exports = require('./lib/enum');
},{"./lib/enum":40}],40:[function(require,module,exports){
(function (global){
(function (root, module, global, define) {

  "use strict";

  /**
   * Represents an Item of an Enum.
   * @param {String} key   The Enum key.
   * @param {Number} value The Enum value.
   */
  function EnumItem(key, value) {
    this.key = key;
    this.value = value;
  }

  EnumItem.prototype = {

    /*constructor reference so that, this.constructor===EnumItem//=>true */
    constructor: EnumItem,

    /**
     * Checks if the flagged EnumItem has the passing object.
     * @param  {EnumItem || String || Number} value The object to check with.
     * @return {Boolean}                            The check result.
     */
    has: function(value) {
      if (value instanceof EnumItem || (typeof(value) === 'object' && value.key !== undefined && value.value !== undefined)) {
        return (this.value & value.value) !== 0;
      } else if (typeof(value) === 'string') {
        return this.key.indexOf(value) >= 0;
      } else {
        return (this.value & value) !== 0;
      }
    },

    /**
     * Checks if the EnumItem is the same as the passing object.
     * @param  {EnumItem || String || Number} key The object to check with.
     * @return {Boolean}                          The check result.
     */
    is: function(key) {
      if (key instanceof EnumItem || (typeof(key) === 'object' && key.key !== undefined && key.value !== undefined)) {
        return this.key === key.key;
      } else if (typeof(key) === 'string') {
        return this.key === key;
      } else {
        return this.value === key;
      }
    },

    /**
     * Returns String representation of this EnumItem.
     * @return {String} String representation of this EnumItem.
     */
    toString: function() {
      return this.key;
    },

    /**
     * Returns JSON object representation of this EnumItem.
     * @return {String} JSON object representation of this EnumItem.
     */
    toJSON: function() {
      return this.key;
    },

    /**
     * Returns the value to compare with.
     * @return {String} The value to compare with.
     */
    valueOf: function() {
      return this.key;
    }

  };


  /**
   * Represents an Enum with enum items.
   * @param {Array || Object}  map     This are the enum items.
   * @param {String || Object} options This are options. [optional]
   */
  function Enum(map, options) {

    if (options && typeof(options) === 'string') {
      options = { name: options };
    }

    this._options = options || {};
    this._options.separator = this._options.separator || ' | ';

    this.enums = [];

    if (map.length) {
      var array = map;
      map = {};

      for (var i = 0; i < array.length; i++) {
        map[array[i]] = Math.pow(2, i);
      }
    }

    for (var member in map) {
      if ((this._options.name && member === 'name') || member === '_options' || member === 'get' || member === 'getKey' || member === 'getValue' || member === 'enums' || member === 'isFlaggable') {
        throw new Error('Enum key "' + member + '" is a reserved word!');
      }
      this[member] = new EnumItem(member, map[member]);
      this.enums.push(this[member]);
    }

    if (this._options.name) {
      this.name = this._options.name;
    }

    var self = this;

    function isFlaggable() {
      for (var i = 0, len = self.enums.length; i < len; i++) {
        var e = self.enums[i];

        if (!((e.value !== 0) && !(e.value & (e.value - 1)))) {
          return false;
        }
      }
      return true;
    }

    this.isFlaggable = isFlaggable();
    this.freezeEnums(); //this will make instances of Enum non-extensible
  }

  Enum.prototype = {

    /*constructor reference so that, this.constructor===Enum//=>true */
    constructor: Enum,

    /**
     * Returns the appropriate EnumItem key.
     * @param  {EnumItem || String || Number} key The object to get with.
     * @return {String}                           The get result.
     */
    getKey: function(value) {
      var item = this.get(value);
      if (item) {
        return item.key;
      } else {
        return 'Undefined';
      }
    },

    /**
     * Returns the appropriate EnumItem value.
     * @param  {EnumItem || String || Number} key The object to get with.
     * @return {Number}                           The get result.
     */
    getValue: function(key) {
      var item = this.get(key);
      if (item) {
        return item.value;
      } else {
        return null;
      }
    },

    /**
     * Returns the appropriate EnumItem.
     * @param  {EnumItem || String || Number} key The object to get with.
     * @return {EnumItem}                         The get result.
     */
    get: function(key) {
      if (key === null || key === undefined) return null;

      if (key instanceof EnumItem || (typeof(key) === 'object' && key.key !== undefined && key.value !== undefined)) {
        var foundIndex = this.enums.indexOf(key);
        if (foundIndex >= 0) {
          return key;
        }
        if (!this.isFlaggable || (this.isFlaggable && key.key.indexOf(this._options.separator) < 0)) {
          return null;
        }
        return this.get(key.key);
      } else if (typeof(key) === 'string') {
        if (key.indexOf(this._options.separator) > 0) {
          var parts = key.split(this._options.separator);

          var value = 0;
          for(var i = 0; i < parts.length; i++) {
            var part = parts[i];

            value |= this[part].value;
          }

          return new EnumItem(key, value);
        } else {
          return this[key];
        }
      } else {
        for (var m in this) {
          if (this.hasOwnProperty(m)) {
            if (this[m].value === key) {
              return this[m];
            }
          }
        }

        var result = null;

        if (this.isFlaggable) {
          for (var n in this) {
            if (this.hasOwnProperty(n)) {
              if ((key & this[n].value) !== 0) {
                if (result) {
                  result += this._options.separator;
                } else {
                  result = '';
                }
                result += n;
              }
            }
          }
        }

        return this.get(result || null);
      }
    },

    /**
     * Define freezeEnums() as a property of the prototype.
     * make enumerable items nonconfigurable and deep freeze the properties. Throw Error on property setter.
     */
    freezeEnums: function() {
      function freezer(o) {
        var props = Object.getOwnPropertyNames(o);
        props.forEach( function(p){
          if (!Object.getOwnPropertyDescriptor(o, p).configurable) {
            return;
          }

          Object.defineProperties(o, p, {writable:false, configurable:false});
        })
        return o;
      }

      function getPropertyValue(value) {
        return value;
      }

      function deepFreezeEnums(o) {
        if (typeof o !== 'object' || o === null || Object.isFrozen(o) || Object.isSealed(o) ){
          return;
        }
        for (var key in o) {
          if (o.hasOwnProperty(key)) {
            o.__defineGetter__(key, getPropertyValue.bind(null, o[key]));
            o.__defineSetter__(key, function throwPropertySetError(value){throw TypeError("Cannot redefine property; Enum Type is not extensible.")});
            deepFreezeEnums(o[key]);
          }
        }
        if (Object.freeze) {
          Object.freeze(o);
        } else {
          freezer(o);
        }
      }

      deepFreezeEnums(this);

      return this;
    },
  };


  if (module && module.exports) {
    module.exports = Enum;
  } else if (define) {
    define(function () {
      return Enum;
    });
  } else {
    root.Enum = Enum;
  }

  if (module && module.exports && global) {

    /**
     * Registers the Enum Type globally in node.js.
     * @param  {String} key Global variable. [optional]
     */
    Enum.register = function(key) {
      key = key || 'Enum';
      if (!global[key]) {
        global[key] = Enum;
      }
    };
  }

}(
  this,
  typeof(module) !== 'undefined' ? module : undefined,
  typeof(global) !== 'undefined' ? global : undefined,
  typeof(define) !== 'undefined' ? define : undefined
));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9lbnVtL2xpYi9lbnVtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKHJvb3QsIG1vZHVsZSwgZ2xvYmFsLCBkZWZpbmUpIHtcblxuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhbiBJdGVtIG9mIGFuIEVudW0uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgICBUaGUgRW51bSBrZXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgRW51bSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIEVudW1JdGVtKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBFbnVtSXRlbS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKmNvbnN0cnVjdG9yIHJlZmVyZW5jZSBzbyB0aGF0LCB0aGlzLmNvbnN0cnVjdG9yPT09RW51bUl0ZW0vLz0+dHJ1ZSAqL1xuICAgIGNvbnN0cnVjdG9yOiBFbnVtSXRlbSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZmxhZ2dlZCBFbnVtSXRlbSBoYXMgdGhlIHBhc3Npbmcgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0VudW1JdGVtIHx8IFN0cmluZyB8fCBOdW1iZXJ9IHZhbHVlIFRoZSBvYmplY3QgdG8gY2hlY2sgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgY2hlY2sgcmVzdWx0LlxuICAgICAqL1xuICAgIGhhczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVudW1JdGVtIHx8ICh0eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5rZXkgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiB2YWx1ZS52YWx1ZSkgIT09IDA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleS5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgdmFsdWUpICE9PSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIEVudW1JdGVtIGlzIHRoZSBzYW1lIGFzIHRoZSBwYXNzaW5nIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtFbnVtSXRlbSB8fCBTdHJpbmcgfHwgTnVtYmVyfSBrZXkgVGhlIG9iamVjdCB0byBjaGVjayB3aXRoLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgY2hlY2sgcmVzdWx0LlxuICAgICAqL1xuICAgIGlzOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBFbnVtSXRlbSB8fCAodHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleS5rZXkgIT09IHVuZGVmaW5lZCAmJiBrZXkudmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5ID09PSBrZXkua2V5O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Yoa2V5KSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5ID09PSBrZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0ga2V5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEVudW1JdGVtLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRW51bUl0ZW0uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEpTT04gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRW51bUl0ZW0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBKU09OIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEVudW1JdGVtLlxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIHRvIGNvbXBhcmUgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB2YWx1ZSB0byBjb21wYXJlIHdpdGguXG4gICAgICovXG4gICAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfVxuXG4gIH07XG5cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhbiBFbnVtIHdpdGggZW51bSBpdGVtcy5cbiAgICogQHBhcmFtIHtBcnJheSB8fCBPYmplY3R9ICBtYXAgICAgIFRoaXMgYXJlIHRoZSBlbnVtIGl0ZW1zLlxuICAgKiBAcGFyYW0ge1N0cmluZyB8fCBPYmplY3R9IG9wdGlvbnMgVGhpcyBhcmUgb3B0aW9ucy4gW29wdGlvbmFsXVxuICAgKi9cbiAgZnVuY3Rpb24gRW51bShtYXAsIG9wdGlvbnMpIHtcblxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZihvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgICB9XG5cbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9vcHRpb25zLnNlcGFyYXRvciA9IHRoaXMuX29wdGlvbnMuc2VwYXJhdG9yIHx8ICcgfCAnO1xuXG4gICAgdGhpcy5lbnVtcyA9IFtdO1xuXG4gICAgaWYgKG1hcC5sZW5ndGgpIHtcbiAgICAgIHZhciBhcnJheSA9IG1hcDtcbiAgICAgIG1hcCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFthcnJheVtpXV0gPSBNYXRoLnBvdygyLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBtZW1iZXIgaW4gbWFwKSB7XG4gICAgICBpZiAoKHRoaXMuX29wdGlvbnMubmFtZSAmJiBtZW1iZXIgPT09ICduYW1lJykgfHwgbWVtYmVyID09PSAnX29wdGlvbnMnIHx8IG1lbWJlciA9PT0gJ2dldCcgfHwgbWVtYmVyID09PSAnZ2V0S2V5JyB8fCBtZW1iZXIgPT09ICdnZXRWYWx1ZScgfHwgbWVtYmVyID09PSAnZW51bXMnIHx8IG1lbWJlciA9PT0gJ2lzRmxhZ2dhYmxlJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudW0ga2V5IFwiJyArIG1lbWJlciArICdcIiBpcyBhIHJlc2VydmVkIHdvcmQhJyk7XG4gICAgICB9XG4gICAgICB0aGlzW21lbWJlcl0gPSBuZXcgRW51bUl0ZW0obWVtYmVyLCBtYXBbbWVtYmVyXSk7XG4gICAgICB0aGlzLmVudW1zLnB1c2godGhpc1ttZW1iZXJdKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5uYW1lKSB7XG4gICAgICB0aGlzLm5hbWUgPSB0aGlzLl9vcHRpb25zLm5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gaXNGbGFnZ2FibGUoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5lbnVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZSA9IHNlbGYuZW51bXNbaV07XG5cbiAgICAgICAgaWYgKCEoKGUudmFsdWUgIT09IDApICYmICEoZS52YWx1ZSAmIChlLnZhbHVlIC0gMSkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc0ZsYWdnYWJsZSA9IGlzRmxhZ2dhYmxlKCk7XG4gICAgdGhpcy5mcmVlemVFbnVtcygpOyAvL3RoaXMgd2lsbCBtYWtlIGluc3RhbmNlcyBvZiBFbnVtIG5vbi1leHRlbnNpYmxlXG4gIH1cblxuICBFbnVtLnByb3RvdHlwZSA9IHtcblxuICAgIC8qY29uc3RydWN0b3IgcmVmZXJlbmNlIHNvIHRoYXQsIHRoaXMuY29uc3RydWN0b3I9PT1FbnVtLy89PnRydWUgKi9cbiAgICBjb25zdHJ1Y3RvcjogRW51bSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFwcHJvcHJpYXRlIEVudW1JdGVtIGtleS5cbiAgICAgKiBAcGFyYW0gIHtFbnVtSXRlbSB8fCBTdHJpbmcgfHwgTnVtYmVyfSBrZXkgVGhlIG9iamVjdCB0byBnZXQgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGdldCByZXN1bHQuXG4gICAgICovXG4gICAgZ2V0S2V5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ1VuZGVmaW5lZCc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFwcHJvcHJpYXRlIEVudW1JdGVtIHZhbHVlLlxuICAgICAqIEBwYXJhbSAge0VudW1JdGVtIHx8IFN0cmluZyB8fCBOdW1iZXJ9IGtleSBUaGUgb2JqZWN0IHRvIGdldCB3aXRoLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZ2V0IHJlc3VsdC5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICBpZiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBFbnVtSXRlbS5cbiAgICAgKiBAcGFyYW0gIHtFbnVtSXRlbSB8fCBTdHJpbmcgfHwgTnVtYmVyfSBrZXkgVGhlIG9iamVjdCB0byBnZXQgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtFbnVtSXRlbX0gICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGdldCByZXN1bHQuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoa2V5IGluc3RhbmNlb2YgRW51bUl0ZW0gfHwgKHR5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkua2V5ICE9PSB1bmRlZmluZWQgJiYga2V5LnZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHZhciBmb3VuZEluZGV4ID0gdGhpcy5lbnVtcy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID49IDApIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc0ZsYWdnYWJsZSB8fCAodGhpcy5pc0ZsYWdnYWJsZSAmJiBrZXkua2V5LmluZGV4T2YodGhpcy5fb3B0aW9ucy5zZXBhcmF0b3IpIDwgMCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5LmtleSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZihrZXkpID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoa2V5LmluZGV4T2YodGhpcy5fb3B0aW9ucy5zZXBhcmF0b3IpID4gMCkge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IGtleS5zcGxpdCh0aGlzLl9vcHRpb25zLnNlcGFyYXRvcik7XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpc1twYXJ0XS52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IEVudW1JdGVtKGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIG0gaW4gdGhpcykge1xuICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KG0pKSB7XG4gICAgICAgICAgICBpZiAodGhpc1ttXS52YWx1ZSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzW21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRmxhZ2dhYmxlKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShuKSkge1xuICAgICAgICAgICAgICBpZiAoKGtleSAmIHRoaXNbbl0udmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuX29wdGlvbnMuc2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5nZXQocmVzdWx0IHx8IG51bGwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmUgZnJlZXplRW51bXMoKSBhcyBhIHByb3BlcnR5IG9mIHRoZSBwcm90b3R5cGUuXG4gICAgICogbWFrZSBlbnVtZXJhYmxlIGl0ZW1zIG5vbmNvbmZpZ3VyYWJsZSBhbmQgZGVlcCBmcmVlemUgdGhlIHByb3BlcnRpZXMuIFRocm93IEVycm9yIG9uIHByb3BlcnR5IHNldHRlci5cbiAgICAgKi9cbiAgICBmcmVlemVFbnVtczogZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBmcmVlemVyKG8pIHtcbiAgICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobyk7XG4gICAgICAgIHByb3BzLmZvckVhY2goIGZ1bmN0aW9uKHApe1xuICAgICAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCBwKS5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvLCBwLCB7d3JpdGFibGU6ZmFsc2UsIGNvbmZpZ3VyYWJsZTpmYWxzZX0pO1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlZXBGcmVlemVFbnVtcyhvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbyAhPT0gJ29iamVjdCcgfHwgbyA9PT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4obykgfHwgT2JqZWN0LmlzU2VhbGVkKG8pICl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgby5fX2RlZmluZUdldHRlcl9fKGtleSwgZ2V0UHJvcGVydHlWYWx1ZS5iaW5kKG51bGwsIG9ba2V5XSkpO1xuICAgICAgICAgICAgby5fX2RlZmluZVNldHRlcl9fKGtleSwgZnVuY3Rpb24gdGhyb3dQcm9wZXJ0eVNldEVycm9yKHZhbHVlKXt0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVkZWZpbmUgcHJvcGVydHk7IEVudW0gVHlwZSBpcyBub3QgZXh0ZW5zaWJsZS5cIil9KTtcbiAgICAgICAgICAgIGRlZXBGcmVlemVFbnVtcyhvW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgIE9iamVjdC5mcmVlemUobyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJlZXplcihvKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWVwRnJlZXplRW51bXModGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIH07XG5cblxuICBpZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFbnVtO1xuICB9IGVsc2UgaWYgKGRlZmluZSkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gRW51bTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByb290LkVudW0gPSBFbnVtO1xuICB9XG5cbiAgaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyAmJiBnbG9iYWwpIHtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgRW51bSBUeXBlIGdsb2JhbGx5IGluIG5vZGUuanMuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBrZXkgR2xvYmFsIHZhcmlhYmxlLiBbb3B0aW9uYWxdXG4gICAgICovXG4gICAgRW51bS5yZWdpc3RlciA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAga2V5ID0ga2V5IHx8ICdFbnVtJztcbiAgICAgIGlmICghZ2xvYmFsW2tleV0pIHtcbiAgICAgICAgZ2xvYmFsW2tleV0gPSBFbnVtO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxufShcbiAgdGhpcyxcbiAgdHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlIDogdW5kZWZpbmVkLFxuICB0eXBlb2YoZ2xvYmFsKSAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB1bmRlZmluZWQsXG4gIHR5cGVvZihkZWZpbmUpICE9PSAndW5kZWZpbmVkJyA/IGRlZmluZSA6IHVuZGVmaW5lZFxuKSk7XG4iXX0=
},{}],41:[function(require,module,exports){
/*!
 * @name JavaScript/NodeJS Merge v1.2.0
 * @author yeikos
 * @repository https://github.com/yeikos/js.merge

 * Copyright 2014 yeikos - MIT license
 * https://raw.github.com/yeikos/js.merge/master/LICENSE
 */

;(function(isNode) {

	/**
	 * Merge one or more objects 
	 * @param bool? clone
	 * @param mixed,... arguments
	 * @return object
	 */

	var Public = function(clone) {

		return merge(clone === true, false, arguments);

	}, publicName = 'merge';

	/**
	 * Merge two or more objects recursively 
	 * @param bool? clone
	 * @param mixed,... arguments
	 * @return object
	 */

	Public.recursive = function(clone) {

		return merge(clone === true, true, arguments);

	};

	/**
	 * Clone the input removing any reference
	 * @param mixed input
	 * @return mixed
	 */

	Public.clone = function(input) {

		var output = input,
			type = typeOf(input),
			index, size;

		if (type === 'array') {

			output = [];
			size = input.length;

			for (index=0;index<size;++index)

				output[index] = Public.clone(input[index]);

		} else if (type === 'object') {

			output = {};

			for (index in input)

				output[index] = Public.clone(input[index]);

		}

		return output;

	};

	/**
	 * Merge two objects recursively
	 * @param mixed input
	 * @param mixed extend
	 * @return mixed
	 */

	function merge_recursive(base, extend) {

		if (typeOf(base) !== 'object')

			return extend;

		for (var key in extend) {

			if (typeOf(base[key]) === 'object' && typeOf(extend[key]) === 'object') {

				base[key] = merge_recursive(base[key], extend[key]);

			} else {

				base[key] = extend[key];

			}

		}

		return base;

	}

	/**
	 * Merge two or more objects
	 * @param bool clone
	 * @param bool recursive
	 * @param array argv
	 * @return object
	 */

	function merge(clone, recursive, argv) {

		var result = argv[0],
			size = argv.length;

		if (clone || typeOf(result) !== 'object')

			result = {};

		for (var index=0;index<size;++index) {

			var item = argv[index],

				type = typeOf(item);

			if (type !== 'object') continue;

			for (var key in item) {

				var sitem = clone ? Public.clone(item[key]) : item[key];

				if (recursive) {

					result[key] = merge_recursive(result[key], sitem);

				} else {

					result[key] = sitem;

				}

			}

		}

		return result;

	}

	/**
	 * Get type of variable
	 * @param mixed input
	 * @return string
	 *
	 * @see http://jsperf.com/typeofvar
	 */

	function typeOf(input) {

		return ({}).toString.call(input).slice(8, -1).toLowerCase();

	}

	if (isNode) {

		module.exports = Public;

	} else {

		window[publicName] = Public;

	}

})(typeof module === 'object' && module && typeof module.exports === 'object' && module.exports);
},{}],42:[function(require,module,exports){
/* vim:set ts=2 sw=2 sts=2 expandtab */
/*jshint undef: true es5: true node: true devel: true evil: true
         forin: true latedef: false supernew: true */
/*global define: true */

!(typeof define !== "function" ? function(_, $){ $(null, typeof exports !== 'undefined' ? exports : window); } : define)('selfish', function(require, exports) {

"use strict";

exports.Base = Object.freeze(Object.create(Object.prototype, {
  /**
   * Creates an object that inherits from `this` object (Analog of
   * `new Object()`).
   * @examples
   *
   *    var Dog = Base.extend({
   *      bark: function bark() {
   *        return 'Ruff! Ruff!'
   *      }
   *    });
   *    var dog = Dog.new();
   */
  'new': { value: function create() {
    var object = Object.create(this);
    object.initialize.apply(object, arguments);
    return object;
  }},
  /**
   * When new instance of the this prototype is created it's `initialize`
   * method is called with all the arguments passed to the `new`. You can
   * override `initialize` to set up an instance.
   */
  initialize: { value: function initialize() {
  }},
  /**
   * Merges all the properties of the passed objects into `this` instance (This
   * method can be used on instances only as prototype objects are frozen).
   *
   * If two or more argument objects have own properties with the same name,
   * the property is overridden, with precedence from right to left, implying,
   * that properties of the object on the left are overridden by a same named
   * property of the object on the right.
   *
   * @examples
   *
   *    var Pet = Dog.extend({
   *      initialize: function initialize(options) {
   *        // this.name = options.name -> would have thrown (frozen prototype)
   *        this.merge(options) // will override all properties.
   *      },
   *      call: function(name) {
   *        return this.name === name ? this.bark() : ''
   *      },
   *      name: null
   *    })
   *    var pet = Pet.new({ name: 'Benzy', breed: 'Labrador' })
   *    pet.call('Benzy')   // 'Ruff! Ruff!'
   */
  merge: { value: function merge() {
    var descriptor = {};
    Array.prototype.forEach.call(arguments, function (properties) {
      Object.getOwnPropertyNames(properties).forEach(function(name) {
        descriptor[name] = Object.getOwnPropertyDescriptor(properties, name);
      });
    });
    Object.defineProperties(this, descriptor);
    return this;
  }},
  /**
   * Takes any number of argument objects and returns frozen, composite object
   * that inherits from `this` object and combines all of the own properties of
   * the argument objects. (Objects returned by this function are frozen as
   * they are intended to be used as types).
   *
   * If two or more argument objects have own properties with the same name,
   * the property is overridden, with precedence from right to left, implying,
   * that properties of the object on the left are overridden by a same named
   * property of the object on the right.
   * @examples
   *
   *    // ## Object composition ##
   *
   *    var HEX = Base.extend({
   *      hex: function hex() {
   *        return '#' + this.color;
   *      }
   *    })
   *
   *    var RGB = Base.extend({
   *      red: function red() {
   *        return parseInt(this.color.substr(0, 2), 16);
   *      },
   *      green: function green() {
   *        return parseInt(this.color.substr(2, 2), 16);
   *      },
   *      blue: function blue() {
   *        return parseInt(this.color.substr(4, 2), 16);
   *      }
   *    })
   *
   *    var CMYK = Base.extend(RGB, {
   *      black: function black() {
   *        var color = Math.max(Math.max(this.red(), this.green()), this.blue());
   *        return (1 - color / 255).toFixed(4);
   *      },
   *      cyan: function cyan() {
   *        var K = this.black();
   *        return (((1 - this.red() / 255).toFixed(4) - K) / (1 - K)).toFixed(4);
   *      },
   *      magenta: function magenta() {
   *        var K = this.black();
   *        return (((1 - this.green() / 255).toFixed(4) - K) / (1 - K)).toFixed(4);
   *      },
   *      yellow: function yellow() {
   *        var K = this.black();
   *        return (((1 - this.blue() / 255).toFixed(4) - K) / (1 - K)).toFixed(4);
   *      }
   *    })
   *
   *    var Color = Base.extend(HEX, RGB, CMYK, {
   *      initialize: function Color(color) {
   *        this.color = color;
   *      }
   *    });
   *
   *    // ## Prototypal inheritance ##
   *
   *    var Pixel = Color.extend({
   *      initialize: function Pixel(x, y, hex) {
   *        Color.initialize.call(this, hex);
   *        this.x = x;
   *        this.y = y;
   *      },
   *      toString: function toString() {
   *        return this.x + ':' + this.y + '@' + this.hex();
   *      }
   *    });
   *
   *    var pixel = Pixel.new(11, 23, 'CC3399')
   *    pixel.toString(); // 11:23@#CC3399
   *
   *    pixel.red();      // 204
   *    pixel.green();    // 51
   *    pixel.blue();     // 153
   *
   *    pixel.cyan();     // 0.0000
   *    pixel.magenta();  // 0.7500
   *    pixel.yellow();   // 0.2500
   *
   */
   extend: { value: function extend() {
    return Object.freeze(this.merge.apply(Object.create(this), arguments));
  }}
}));

});

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJyYnJva2VyLmpzIiwibGliL2VuZ2luZS9iYWNrZ3JvdW5kLXRhc2stYnJva2VyLmpzIiwibGliL2VuZ2luZS9kaXNjcmV0ZS10YXNrLWJyb2tlci5qcyIsImxpYi9lbmdpbmUvcG9vbGVkLXRhc2stYnJva2VyLmpzIiwibGliL2VuZ2luZS9yYnJva2VyLWVuZ2luZS5qcyIsImxpYi9ydGFzay10b2tlbi5qcyIsImxpYi9ydGFzay10eXBlLmpzIiwibGliL3Rhc2svYmFja2dyb3VuZC10YXNrLmpzIiwibGliL3Rhc2svZGlzY3JlYXRlLXRhc2suanMiLCJsaWIvdGFzay9wb29sZWQtdGFzay5qcyIsImxpYi90YXNrL3J0YXNrLmpzIiwibGliL3V0aWwvcnRhc2stcXVldWUuanMiLCJsaWIvd29ya2VyL2JhY2tncm91bmQtdGFzay13b3JrZXIuanMiLCJsaWIvd29ya2VyL2Rpc2NyZXRlLXRhc2std29ya2VyLmpzIiwibGliL3dvcmtlci9wb29sZWQtdGFzay13b3JrZXIuanMiLCJsaWIvd29ya2VyL3Jicm9rZXItd29ya2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZC5qcy9saWIvRC5qcyIsIm5vZGVfbW9kdWxlcy9kZXBsb3lyL2FwaXMuanNvbiIsIm5vZGVfbW9kdWxlcy9kZXBsb3lyL2RlcGxveXIuanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9saWIvZGVwcmVjYXRlZC5qcyIsIm5vZGVfbW9kdWxlcy9kZXBsb3lyL2xpYi9lbWl0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2RlcGxveXIvbGliL2VuY29kZXIuanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9saWIvZXMuanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9saWIvbGFuZy5qcyIsIm5vZGVfbW9kdWxlcy9kZXBsb3lyL2xpYi9sb2dnZXIuanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9saWIvb3B0aW9uYWwuanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9saWIvcXVldWUuanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9saWIvcmlucHV0LmpzIiwibm9kZV9tb2R1bGVzL2RlcGxveXIvbGliL3JpbnB1dHMuanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9saWIvcnR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL2RlcGxveXIvbGliL3NlbGZpc2guanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL2RlcGxveXIvbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RlcGxveXIvbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbm9kZV9tb2R1bGVzL3JlZHVjZS1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVwbG95ci9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvZW51bS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9lbnVtL2xpYi9lbnVtLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlL21lcmdlLmpzIiwibm9kZV9tb2R1bGVzL3NlbGZpc2gvc2VsZmlzaC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3R5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDempDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiFcbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IGJ5IFJldm9sdXRpb24gQW5hbHl0aWNzIEluYy5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSB0ZXJtcyBvZiBWZXJzaW9uIDIuMCBvZiB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlLiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5UWSwgSU5DTFVESU5HIFRIT1NFIE9GIE5PTi1JTkZSSU5HRU1FTlQsXG4gKiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFBsZWFzZSByZWZlciB0byB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlIDIuMCAoaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wKSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqL1xuXG52YXIgRGlzY3JldGVUYXNrICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi90YXNrL2Rpc2NyZWF0ZS10YXNrJyksXG4gICAgUG9vbGVkVGFzayAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi90YXNrL3Bvb2xlZC10YXNrJyksXG4gICAgQmFja2dyb3VuZFRhc2sgICAgICAgPSByZXF1aXJlKCcuL2xpYi90YXNrL2JhY2tncm91bmQtdGFzaycpLFxuICAgIERpc2NyZXRlVGFza0Jyb2tlciAgID0gcmVxdWlyZSgnLi9saWIvZW5naW5lL2Rpc2NyZXRlLXRhc2stYnJva2VyJyksXG4gICAgUG9vbGVkVGFza0Jyb2tlciAgICAgPSByZXF1aXJlKCcuL2xpYi9lbmdpbmUvcG9vbGVkLXRhc2stYnJva2VyJyksXG4gICAgQmFja2dyb3VuZFRhc2tCcm9rZXIgPSByZXF1aXJlKCcuL2xpYi9lbmdpbmUvYmFja2dyb3VuZC10YXNrLWJyb2tlcicpO1xuXG4vLyAtLSBleHBvc2UgYGRlcGxveXJgIGludG8gdGhlIGdsb2JhbCBuYW1lc3BhY2UgZm9yIGJyb3dzZXIgY29udmVuaWVuY2UgLS1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LmRlcGxveXIpIHtcbiAgICB3aW5kb3cuZGVwbG95ciA9IHJlcXVpcmUoJ2RlcGxveXInKTtcbn1cblxuLyoqXG4gKiBUaGUgYHJicm9rZXJgIGdsb2JhbCBuYW1lc3BhY2Ugb2JqZWN0LiBUaGlzIGlzIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGZvciB0aGVcbiAqIERlcGxveVIgYFJCcm9rZXJgLiBJdCBpcyB1c2VkIGFzIGEgZmFjdG9yeSB0byBzaW1wbGlmeSB0aGUgY3JlYXRpb24gb2YgbmV3XG4gKiBpbnN0YW5jZXMgb2Y6XG4gKlxuICogLSBEaXNjcmV0ZVRhc2tCcm9rZXJcbiAqIC0gUG9vbGVkVGFza0Jyb2tlclxuICogLSBCYWNrZ3JvdW5kVGFza0Jyb2tlclxuICogLSBEaXNjcmV0ZVRhc2tcbiAqIC0gUG9vbGVkVGFza1xuICogLSBCYWNrZ3JvdW5kVGFza1xuICpcbiAqIEBtb2R1bGUgcmJyb2tlclxuICogQGZvciByYnJva2VyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGFuIGBEaXNjcmV0ZVRhc2tCcm9rZXJgIHRvIG1hbmFnZSB0aGUgZXhlY3V0aW9uIG9mXG4gICAgICogYSBgRGlzY3JldGVUYXNrYC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGlzY3JldGVUYXNrQnJva2VyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm4ge1JCcm9rZXJ9IEEgbmV3IGluc3RhbmNlIG9mIGEgYERpc2NyZXRlVGFza0Jyb2tlcmAuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBkaXNjcmV0ZVRhc2tCcm9rZXI6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gRGlzY3JldGVUYXNrQnJva2VyLm5ldyhjb25maWcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gYFBvb2xlZFRhc2tCcm9rZXJgIHRvIG1hbmFnZSB0aGUgZXhlY3V0aW9uIG9mXG4gICAgICogYSBgUG9vbGVkVGFza2AuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHBvb2xlZFRhc2tCcm9rZXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7UkJyb2tlcn0gQSBuZXcgaW5zdGFuY2Ugb2YgYSBgUG9vbGVkVGFza0Jyb2tlcmAuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBwb29sZWRUYXNrQnJva2VyOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIFBvb2xlZFRhc2tCcm9rZXIubmV3KGNvbmZpZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhbiBgQmFja2dyb3VuZFRhc2tCcm9rZXJgIHRvIG1hbmFnZSB0aGUgZXhlY3V0aW9uIG9mXG4gICAgICogYSBgQmFja2dyb3VuZFRhc2tgLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBiYWNrZ3JvdW5kVGFza0Jyb2tlclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtSQnJva2VyfSBBIG5ldyBpbnN0YW5jZSBvZiBhIGBCYWNrZ3JvdW5kVGFza0Jyb2tlcmAuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kVGFza0Jyb2tlcjogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBCYWNrZ3JvdW5kVGFza0Jyb2tlci5uZXcoY29uZmlnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgYERpc2NyZXRlVGFza2AgZm9yIGFuIGFuYWx5dGljcyBXZWIgc2VydmljZSBiYXNlZFxuICAgICAqIG9uIGVpdGhlcjpcbiAgICAgKlxuICAgICAqICAxLiBSZXBvc2l0b3J5LW1hbmFnZWQgUiBzY3JpcHRcbiAgICAgKlxuICAgICAqICAgIGBgYFxuICAgICAqICAgIHZhciBydGFzayA9IHJicm9rZXIuZGlzY3JldGVUYXNrKHtcbiAgICAgKiAgICAgICBmaWxlbmFtZTogJ3JlZ3Jlc3Npb24nLFxuICAgICAqICAgICAgIGRpcmVjdG9yeTogJ2RlbW8nLFxuICAgICAqICAgICAgIGF1dGhvcjogJ2dlb3JnZScsXG4gICAgICogICAgICAgdmVyc2lvbjogdmVyc2lvblxuICAgICAqICAgICAgIC8vIEFkZGl0aW9uYWwgRGlzY3JldGUgVGFzayBPcHRpb25zLi4uXG4gICAgICogICAgfSk7XG4gICAgICogICAgYGBgXG4gICAgICpcbiAgICAgKiAyLiBVUkwtYWRkcmVzc2FibGUgUiBzY3JpcHRcbiAgICAgKlxuICAgICAqICAgIGBgYFxuICAgICAqICAgIHZhciBydGFzayA9IHJicm9rZXIuZGlzY3JldGVUYXNrKCB7XG4gICAgICogICAgICAgICBleHRlcm5hbHNvdXJjZTogcmVncmVzc2lvblVSTFxuICAgICAqICAgICAgICAgLy8gQWRkaXRpb25hbCBEaXNjcmV0ZSBUYXNrIE9wdGlvbnMuLi5cbiAgICAgKiAgICB9KTtcbiAgICAgKiAgICBgYGBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGlzY3JldGVUYXNrXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm4ge1JUYXNrfSBBIG5ldyBpbnN0YW5jZSBvZiBhIGBEaXNjcmV0ZVRhc2tgLlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZGlzY3JldGVUYXNrOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIERpc2NyZXRlVGFzay5uZXcoY29uZmlnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgYFBvb2xlZFRhc2tgIGZvciBhbiBhbmFseXRpY3MgV2ViIHNlcnZpY2UgYmFzZWRcbiAgICAgKiBvbiBlaXRoZXI6XG4gICAgICpcbiAgICAgKiAgMS4gUmVwb3NpdG9yeS1tYW5hZ2VkIFIgc2NyaXB0XG4gICAgICpcbiAgICAgKiAgICBgYGBcbiAgICAgKiAgICB2YXIgcnRhc2sgPSByYnJva2VyLnBvb2xlZFRhc2soe1xuICAgICAqICAgICAgIGZpbGVuYW1lOiAncmVncmVzc2lvbicsXG4gICAgICogICAgICAgZGlyZWN0b3J5OiAnZGVtbycsXG4gICAgICogICAgICAgYXV0aG9yOiAnZ2VvcmdlJyxcbiAgICAgKiAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uXG4gICAgICogICAgICAgLy8gQWRkaXRpb25hbCBQb29sZWQgVGFzayBPcHRpb25zLi4uXG4gICAgICogICAgfSk7XG4gICAgICogICAgYGBgXG4gICAgICpcbiAgICAgKiAyLiBBcmJpdHJhcnkgYmxvY2sgb2YgUiBjb2RlXG4gICAgICpcbiAgICAgKiAgICBgYGBcbiAgICAgKiAgICB2YXIgcnRhc2sgPSByYnJva2VyLnBvb2xlZFRhc2soe1xuICAgICAqICAgICAgICAgY29kZTogY29kZUJsb2NrXG4gICAgICogICAgICAgICAvLyBBZGRpdGlvbmFsIFBvb2xlZCBUYXNrIE9wdGlvbnMuLi5cbiAgICAgKiAgICB9KTtcbiAgICAgKiAgICBgYGBcbiAgICAgKlxuICAgICAqIDMuIFVSTC1hZGRyZXNzYWJsZSBSIHNjcmlwdFxuICAgICAqXG4gICAgICogICAgYGBgXG4gICAgICogICAgdmFyIHJ0YXNrID0gcmJyb2tlci5wb29sZWRUYXNrKCB7XG4gICAgICogICAgICAgICBleHRlcm5hbHNvdXJjZTogcmVncmVzc2lvblVSTFxuICAgICAqICAgICAgICAgLy8gQWRkaXRpb25hbCBQb29sZWQgVGFzayBPcHRpb25zLi4uXG4gICAgICogICAgfSk7XG4gICAgICogICAgYGBgXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHBvb2xlZFRhc2tcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7UlRhc2t9IEEgbmV3IGluc3RhbmNlIG9mIGEgYFBvb2xlZFRhc2tgLlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgcG9vbGVkVGFzazogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBQb29sZWRUYXNrLm5ldyhjb25maWcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgYEJhY2tncm91bmRUYXNrYCBmb3IgYW4gYW5hbHl0aWNzIFdlYiBzZXJ2aWNlXG4gICAgICogYmFzZWQgb24gZWl0aGVyOlxuICAgICAqXG4gICAgICogIDEuIFJlcG9zaXRvcnktbWFuYWdlZCBSIHNjcmlwdFxuICAgICAqXG4gICAgICogICAgYGBgXG4gICAgICogICAgdmFyIHJUYXNrID0gcmJyb2tlci5iYWNrZ3JvdW5kVGFzayh7XG4gICAgICogICAgICAgbmFtZTogJ1NhbXBsZSBUYXNrJyxcbiAgICAgKiAgICAgICBkZXNjcjogJ1NhbXBsZSBkZXNjcmlwdGlvbicsXG4gICAgICogICAgICAgcnNjcmlwdG5hbWU6ICdyZWdyZXNzaW9uJyxcbiAgICAgKiAgICAgICByc2NyaXB0ZGlyZWN0b3J5OiAnZGVtbycsXG4gICAgICogICAgICAgcnNjcmlwdGF1dGhvcjogJ2dlb3JnZScsXG4gICAgICogICAgICAgcnNjcmlwdHZlcnNpb246IHZlcnNpb25cbiAgICAgKiAgICAgICAvLyBBZGRpdGlvbmFsIEJhY2tncm91bmQgVGFzayBPcHRpb25zLi4uXG4gICAgICogICAgfSk7XG4gICAgICogICAgYGBgXG4gICAgICpcbiAgICAgKiAyLiBBcmJpdHJhcnkgYmxvY2sgb2YgUiBjb2RlXG4gICAgICpcbiAgICAgKiAgICBgYGBcbiAgICAgKiAgICB2YXIgcnRhc2sgPSByYnJva2VyLmJhY2tncm91bmRUYXNrKHtcbiAgICAgKiAgICAgICAgIG5hbWU6ICdTYW1wbGUgVGFzaycsXG4gICAgICogICAgICAgZGVzY3I6ICdTYW1wbGUgZGVzY3JpcHRpb24nLFxuICAgICAqICAgICAgICAgY29kZTogY29kZUJsb2NrXG4gICAgICogICAgICAgICAvLyBBZGRpdGlvbmFsIEJhY2tncm91bmQgVGFzayBPcHRpb25zLi4uXG4gICAgICogICAgfSk7XG4gICAgICogICAgYGBgXG4gICAgICpcbiAgICAgKiAzLiBVUkwtYWRkcmVzc2FibGUgUiBzY3JpcHRcbiAgICAgKlxuICAgICAqICAgIGBgYFxuICAgICAqICAgIHZhciBydGFzayA9IHJicm9rZXIuYmFja2dyb3VuZFRhc2soIHtcbiAgICAgKiAgICAgICAgIG5hbWU6ICdTYW1wbGUgVGFzaycsXG4gICAgICogICAgICAgZGVzY3I6ICdTYW1wbGUgZGVzY3JpcHRpb24nLFxuICAgICAqICAgICAgICAgZXh0ZXJuYWxzb3VyY2U6IHJlZ3Jlc3Npb25VUkxcbiAgICAgKiAgICAgICAgIC8vIEFkZGl0aW9uYWwgQmFja2dyb3VuZCBUYXNrIE9wdGlvbnMuLi5cbiAgICAgKiAgICB9KTtcbiAgICAgKiAgICBgYGBcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYmFja2dyb3VuZFRhc2tcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7UlRhc2t9IEEgbmV3IGluc3RhbmNlIG9mIGFuIGBCYWNrZ3JvdW5kVGFza2AuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kVGFzazogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBCYWNrZ3JvdW5kVGFzay5uZXcoY29uZmlnKTtcbiAgICB9XG59O1xuIiwiLyohXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBieSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgdGVybXMgb2YgVmVyc2lvbiAyLjAgb2YgdGhlXG4gKiBBcGFjaGUgTGljZW5zZS4gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIFdJVEhPVVRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVFksIElOQ0xVRElORyBUSE9TRSBPRiBOT04tSU5GUklOR0VNRU5ULFxuICogTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBQbGVhc2UgcmVmZXIgdG8gdGhlXG4gKiBBcGFjaGUgTGljZW5zZSAyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCkgZm9yIG1vcmUgXG4gKiBkZXRhaWxzLlxuICovXG5cbnZhciBtZXJnZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ21lcmdlJyksICAgIFxuICAgIFJCcm9rZXJFbmdpbmUgICAgICAgID0gcmVxdWlyZSgnLi9yYnJva2VyLWVuZ2luZScpLFxuICAgIEJhY2tncm91bmRUYXNrV29ya2VyID0gcmVxdWlyZSgnLi4vd29ya2VyL2JhY2tncm91bmQtdGFzay13b3JrZXInKTtcblxuLyoqXG4gKiBUaGUgQmFja2dyb3VuZCBUYXNrIFJ1bnRpbWUgYWNxdWlyZXMgRGVwbG95UiBncmlkIHJlc291cmNlcyBwZXIgYFJUYXNrYCBcbiAqIGJhc2VkIG9uIHRoZSBzZXJ2ZXItc2lkZSBtYW5hZ2VtZW50IG9mIGFzeW5jaHJvbm91cyBncmlkIHJlc291cmNlcy4gXG4gKlxuICogQG1vZHVsZSBicmFja2dyb3VuZC1icm9rZXJcbiAqIEBmb3IgcmJyb2tlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJCcm9rZXJFbmdpbmUuZXh0ZW5kKHsgIFxuICAvKipcbiAgICogVGhlIEJhY2tncm91bmQgVGFzayBSdW50aW1lIGFjcXVpcmVzIERlcGxveVIgZ3JpZCByZXNvdXJjZXMgcGVyIGBSVGFza2AgXG4gICAqIGJhc2VkIG9uIHRoZSBzZXJ2ZXItc2lkZSBtYW5hZ2VtZW50IG9mIGFzeW5jaHJvbm91cyBncmlkIHJlc291cmNlcy4gXG4gICAqXG4gICAqIEBjbGFzcyBcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zLiAgICBcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAvKlxuICAgICAqIFRoaXMgbGltaXQgaXMgc2V0IHNpbXBseSB0byBlbnN1cmUgdGhlIEJhY2tncm91bmRUYXNrQnJva2VyIGRvZXMgbm90IFxuICAgICAqIHN3YW1wIHRoZSBzZXJ2ZXIgd2hpY2ggdG9vIG1hbnkgY29uY3VycmVudCBIVFRQIHJlcXVlc3RzIHdoZW4gc3VibWl0dGluZyBcbiAgICAgKiBSVGFzay4gVGhlIHJlYWwgcXVldWVpbmcgb2YgUlRhc2sgaXMgaGFuZGxlZCBieSB0aGUgc2VydmVyLCB0aGlzIGJyb2tlciBcbiAgICAgKiBzaW1wbHkgcHVzaGVkIHRoZSBSVGFzayBpbnRvIHRoZSBzZXJ2ZXItbWFuYWdlZCBxdWV1ZS5cbiAgICAgKi9cbiAgICB2YXIgUEFSQUxMRUxfVEFTS19MSU1JVCA9IDEwO1xuXG4gICAgUkJyb2tlckVuZ2luZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWVyZ2UoY29uZmlnLCB7XG4gICAgICBtYXhDb25jdXJyZW50VGFza0xpbWl0OiBQQVJBTExFTF9UQVNLX0xJTUlUXG4gICAgfSkpOyAgICBcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc291cmNlVG9rZW5Qb29sIHdpdGggSW50ZWdlciBiYXNlZCByZXNvdXJjZVRva2Vucy5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXJhbGxlbFRhc2tMaW1pdDsgaSsrKSB7XG4gICAgICB0aGlzLnJlc291cmNlVG9rZW5Qb29sLm9mZmVyKGkpO1xuICAgIH1cbiAgXG4gICAgdGhpcy5ydXNlciA9IHRoaXMudmFsaWRhdGVFbmRwb2ludCgpLmlvKCcvci91c2VyL2xvZ2luJylcbiAgICAgIC5kYXRhKGNvbmZpZy5jcmVkZW50aWFscylcbiAgICAgIC5jdHgodGhpcykgICAgICBcbiAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKSB7IHRoaXMuZW1pdCgncmVhZHknKTsgfSk7XG4gIH0sIFxuXG4gIC8qKlxuICAgKiBOb3Qgc3VwcG9ydGVkLiBTdXBwb3J0IGZvciBgcmVmcmVzaGAgaXMgb25seSBhdmFpbGFibGUgb24gdGhlIFxuICAgKiBgUG9vbGVkVGFza0Jyb2tlcmAgcnVudGltZS5cbiAgICpcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpIHB1YmxpYyAgIFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFja2dyb3VuZFRhc2tCcm9rZXIgcmVmcmVzaCBub3Qgc3VwcG9ydGVkLicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIGFsbCBjbGllbnQtc2lkZSBhbmQgc2VydmVyLXNpZGUgcmVzb3VyY2VzIG1haW50YWluZWQgYnkgb3Igb24gXG4gICAqIGJlaGFsZiBvZiBhbiBpbnN0YW5jZSBvZiBgUkJyb2tlcmAuXG4gICAqXG4gICAqIEBtZXRob2Qgc2h1dGRvd25cbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB3cmFwcGluZyB0aGUgcmVzb2x1dGlvbiBvZiBlaXRoZXIgXCJyZXNvbHZlXCIgb3IgXG4gICAqIFwicmVqZWN0XCIgY2FsbGJhY2suXG4gICAqIEBhcGkgcHVibGljXG4gICAqLyBcbiAgc2h1dGRvd246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZsdXNoKCk7XG5cbiAgICByZXR1cm4gdGhpcy5ydXNlci5yZWxlYXNlKCk7ICAgIFxuICB9LCAgXG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZVdvcmtlcjogZnVuY3Rpb24gKHRhc2spIHtcbiAgICByZXR1cm4gQmFja2dyb3VuZFRhc2tXb3JrZXIubmV3KHRhc2ssIHRoaXMucnVzZXIpO1xuICB9XG59KTtcbiIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlXG4gKiBkZXRhaWxzLlxuICovXG52YXIgRCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnZC5qcycpLFxuICAgIFJCcm9rZXJFbmdpbmUgICAgICA9IHJlcXVpcmUoJy4vcmJyb2tlci1lbmdpbmUnKSxcbiAgICBEaXNjcmV0ZVRhc2tXb3JrZXIgPSByZXF1aXJlKCcuLi93b3JrZXIvZGlzY3JldGUtdGFzay13b3JrZXInKTtcblxuLyoqXG4gKiBUaGUgRGlzY3JldGUgVGFzayBSdW50aW1lIGFjcXVpcmVzIERlcGxveVIgZ3JpZCByZXNvdXJjZXMgcGVyIGBSVGFza2AgXG4gKiBvbi1kZW1hbmQuXG4gKlxuICogQG1vZHVsZSBkaXNjcmV0ZS1icm9rZXJcbiAqIEBmb3IgcmJyb2tlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFJCcm9rZXJFbmdpbmUuZXh0ZW5kKHtcbiAgLyoqXG4gICAqIFRoZSBEaXNjcmV0ZSBUYXNrIFJ1bnRpbWUgYWNxdWlyZXMgRGVwbG95UiBncmlkIHJlc291cmNlcyBwZXIgYFJUYXNrYCBcbiAgICogb24tZGVtYW5kLlxuICAgKlxuICAgKiBAY2xhc3MgXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9ucy4gICAgXG4gICAqLyAgIFxuICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgUkJyb2tlckVuZ2luZS5pbml0aWFsaXplLmNhbGwodGhpcywgY29uZmlnKTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVzb3VyY2VUb2tlblBvb2wgd2l0aCBJbnRlZ2VyIGJhc2VkIHJlc291cmNlVG9rZW5zLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcmFsbGVsVGFza0xpbWl0OyBpKyspIHtcbiAgICAgICAgIHRoaXMucmVzb3VyY2VUb2tlblBvb2wub2ZmZXIoaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgIHRoaXMucnVzZXIgPSB0aGlzLnZhbGlkYXRlRW5kcG9pbnQoKS5pbygnL3IvdXNlci9sb2dpbicpICAgICAgICAgXG4gICAgICAgICAgICAuZGF0YShjb25maWcuY3JlZGVudGlhbHMpXG4gICAgICAgICAgICAuY3R4KHRoaXMpICAgICAgICAgICAgXG4gICAgICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcykgeyB0aGlzLmVtaXQoJ3JlYWR5Jyk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHRoaXMudmFsaWRhdGVFbmRwb2ludChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucnVzZXIgPSBudWxsOyAgXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgIH0sXG5cbiAgLyoqXG4gICAqIE5vdCBzdXBwb3J0ZWQuIFN1cHBvcnQgZm9yIGByZWZyZXNoYCBpcyBvbmx5IGF2YWlsYWJsZSBvbiB0aGUgXG4gICAqIGBQb29sZWRUYXNrQnJva2VyYCBydW50aW1lLlxuICAgKlxuICAgKiBAbWV0aG9kIHJlZnJlc2hcbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGkgcHVibGljICAgXG4gICAqL1xuICAgcmVmcmVzaDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaXNjcmV0ZVRhc2tCcm9rZXIgcmVmcmVzaCBub3Qgc3VwcG9ydGVkLicpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBAT3ZlcnJpZGVcbiAgICAqL1xuICAgY3JlYXRlV29ya2VyOiBmdW5jdGlvbiAodGFzaykge1xuICAgICAgcmV0dXJuIERpc2NyZXRlVGFza1dvcmtlci5uZXcodGFzaywgdGhpcy5ydXNlcik7XG4gICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIGFsbCBjbGllbnQtc2lkZSBhbmQgc2VydmVyLXNpZGUgcmVzb3VyY2VzIG1haW50YWluZWQgYnkgb3Igb24gXG4gICAqIGJlaGFsZiBvZiBhbiBpbnN0YW5jZSBvZiBgUkJyb2tlcmAuXG4gICAqXG4gICAqIEBtZXRob2Qgc2h1dGRvd25cbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB3cmFwcGluZyB0aGUgcmVzb2x1dGlvbiBvZiBlaXRoZXIgXCJyZXNvbHZlXCIgb3IgXG4gICAqIFwicmVqZWN0XCIgY2FsbGJhY2suXG4gICAqIEBhcGkgcHVibGljXG4gICAqLyBcbiAgIHNodXRkb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1c2VyID8gdGhpcy5ydXNlci5yZWxlYXNlKCkgOiBELnByb21pc2lmeSh0cnVlKTtcbiAgIH0gICBcbn0pOyIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlIFxuICogZGV0YWlscy5cbiAqL1xuXG52YXIgZGVwbG95ciA9IHJlcXVpcmUoJ2RlcGxveXInKTtcblxudmFyIEQgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdkLmpzJyksXG4gICAgbWVyZ2UgICAgICAgICAgICA9IHJlcXVpcmUoJ21lcmdlJyksXG4gICAgUkJyb2tlckVuZ2luZSAgICA9IHJlcXVpcmUoJy4vcmJyb2tlci1lbmdpbmUnKSxcbiAgICBQb29sZWRUYXNrV29ya2VyID0gcmVxdWlyZSgnLi4vd29ya2VyL3Bvb2xlZC10YXNrLXdvcmtlcicpOyAgICBcblxuLyoqXG4gKiBUaGUgUG9vbGVkIFRhc2sgUnVudGltZSBhY3F1aXJlcyBhIGRlZGljYXRlZCBwb29sIG9mIERlcGxveVIgZ3JpZCByZXNvdXJjZXMgXG4gKiBhdCBzdGFydHVwLlxuICpcbiAqIEBtb2R1bGUgcG9vbGVkLXRhc2stYnJva2VyXG4gKiBAZm9yIHJicm9rZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSQnJva2VyRW5naW5lLmV4dGVuZCh7ICBcbiAgLyoqXG4gICAqIFRoZSBQb29sZWQgVGFzayBSdW50aW1lIGFjcXVpcmVzIGEgZGVkaWNhdGVkIHBvb2wgb2YgRGVwbG95UiBncmlkIHJlc291cmNlcyBcbiAgICogYXQgc3RhcnR1cC5cbiAgICpcbiAgICogQGNsYXNzIFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnMuICAgIFxuICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgUkJyb2tlckVuZ2luZS5pbml0aWFsaXplLmNhbGwodGhpcywgY29uZmlnKTsgIFxuXG4gICAgaWYgKCFjb25maWcuY3JlZGVudGlhbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJva2VyIGZhaWxlZCB0byBpbml0aWFsaXplLCB1c2VyIGNyZWRlbnRpYWxzIHJlcXVpcmVkLicpO1xuICAgIH1cblxuICAgIHZhciBzZWxmICAgICA9IHRoaXMsXG4gICAgICAgIHBvb2xTaXplID0gdGhpcy5wYXJhbGxlbFRhc2tMaW1pdCxcbiAgICAgICAgcG9vbCAgICAgPSBtZXJnZSh7IHBvb2xzaXplOiBwb29sU2l6ZSB9LCBjb25maWcucG9vbCB8fCB7fSk7XG5cbiAgICAvKlxuICAgICAqIFByZXZlbnRzIGF1dGhlbnRpY2F0ZWQgSFRUUCBzZXNzaW9uIGZyb20gdGltaW5nIG91dCBkdWUgdG8gaW5hY3Rpdml0eSB0byBcbiAgICAgKiBlbnN1cmUgcG9vbCBvZiBSUHJvamVjdCByZW1haW4gbGl2ZSBhbmQgYXZhaWxhYmxlIHRvIFBvb2xlZFRhc2tCcm9rZXIuXG4gICAgICovXG4gICAgdGhpcy5odHRwS2VlcEFsaXZlID0ge1xuICAgICAgaWQ6IG51bGwsXG4gICAgICBQSU5HX0lOVEVSVkFMOiA2MDAwMCxcblxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uKHJ1c2VyKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLmlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7IFxuICAgICAgICAgIGRlcGxveXIuaW8oJy9yL3VzZXIvYWJvdXQnKS5zaGFyZShydXNlci5nZXRDb29raWVzKCkpLmVuZCgpO1xuICAgICAgICB9LCB0aGlzLlBJTkdfSU5URVJWQUwpO1xuICAgICAgfSxcblxuICAgICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pZCk7XG4gICAgICB9XG4gICAgfTsgICAgXG5cbiAgICAvKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHJlc291cmNlVG9rZW5Qb29sIHdpdGggUlByb2plY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZChyZXMpIHtcbiAgICAgIHZhciBwcm9qZWN0cyA9IHJlcy5nZXQoJ3Byb2plY3RzJyk7XG4gICAgICBcbiAgICAgIGlmIChwcm9qZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGluZm9ybSBjYWxsZXIgb2YgYW55IGBHcmlkIE5vdGlmaWNhdGlvbmAgZXJyb3JzIHVzY2ggYXM6XG4gICAgICAgIC8vICdDb25jdXJyZW50IGF1dGhlbnRpY2F0ZWQgcHJvamVjdCBsaW1pdCAoMTApIHJlYWNoZWQgZm9yIHVzZXIgWFlaLidcbiAgICAgICAgLy8gVGhlc2UgJ2Vycm9ycycgYXJlIG1vcmUgbGlrZSB3YXJuaW5ncyB0aGFuIHJ1bnRpbWUgdGhyb3dhYmxlIGVycm9ycy5cbiAgICAgICAgdmFyIHdhcm4gPSByZXMuZ2V0KCdlcnJvcicpOyAgICAgICAgXG4gICAgICAgIGlmICh3YXJuKSB7IHNlbGYuZW1pdCgnd2FybmluZycsIHdhcm4pOyB9XG5cbiAgICAgICAgcHJvamVjdHMuZm9yRWFjaChmdW5jdGlvbihwcm9qZWN0KSB7XG4gICAgICAgICAgc2VsZi5yZXNvdXJjZVRva2VuUG9vbC5vZmZlcihwcm9qZWN0LnByb2plY3QpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzZWxmLnBhcmFsbGVsVGFza0xpbWl0ID0gc2VsZi5yZXNvdXJjZVRva2VuUG9vbC5zaXplKCk7XG4gICAgICAgIHNlbGYuaHR0cEtlZXBBbGl2ZS5zdGFydChzZWxmLnJ1c2VyKTsgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHNlbGYuZW1pdCgncmVhZHknKTtcbiAgICAgIH0gZWxzZSB7IC8vIE5vIHByb2plY3RzIHdlcmUgY3JlYXRlZCAocHJvamVjdHMubGVuZ3RoID09IDApXG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCByZXMuZ2V0KCdlcnJvcicpKTtcbiAgICAgIH1cbiAgICB9XG4gICBcbiAgICAvL1xuICAgIC8vIFZhbGlkYXRlIERlcGxveVIgc2VydmVyIGBlbmRwb2ludGAgYW5kIGF1dGhlbnRpY2F0ZS5cbiAgICAvL1xuICAgIHRoaXMucnVzZXIgPSB0aGlzLnZhbGlkYXRlRW5kcG9pbnQoKS5pbygnL3IvdXNlci9sb2dpbicpXG4gICAgICAuZGF0YShjb25maWcuY3JlZGVudGlhbHMpXG4gICAgICAuY3R4KHRoaXMpXG4gICAgICAuZW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBcbiAgICAgICAgLy8gQnVpbGQgdGhlIHByb2plY3QgcG9vbC5cbiAgICAgICAgLy8gICAgICAgIFxuICAgICAgICBpZiAoY29uZmlnLnJlbGVhc2VHcmlkUmVzb3VyY2VzKSB7XG4gICAgICAgICAgdGhpcy5ydXNlci5pbygnL3IvdXNlci9yZWxlYXNlJylcbiAgICAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAgICAuaW8oJy9yL3Byb2plY3QvcG9vbCcpXG4gICAgICAgICAgICAgLmRhdGEocG9vbClcbiAgICAgICAgICAgICAuZW5kKGxvYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucnVzZXIuaW8oJy9yL3Byb2plY3QvcG9vbCcpLmRhdGEocG9vbCkuZW5kKGxvYWQpOyAgICAgICAgICAgICBcbiAgICAgICAgfSAgXG4gICAgICB9KTtcbiAgfSwgXG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGBQb29sZWRUYXNrUkJyb2tlcmAuXG4gICAqXG4gICAqIEEgcmVmcmVzaCBjYXVzZXMgYWxsIHdvcmtzcGFjZSBvYmplY3RzIGFuZCBkaXJlY3RvcnkgZmlsZXMgaW4gdGhlIFxuICAgKiB1bmRlcmx5aW5nIFIgc2Vzc2lvbnMgd2l0aGluIHRoZSBwb29sIHRvIGJlIGNsZWFyZWQgYmVmb3JlIG5ldyB3b3Jrc3BhY2UgXG4gICAqIG9iamVjdHMgYW5kL29yIGRpcmVjdG9yeSBmaWxlcyBhcmUgbG9hZGVkIHBlciB0aGUgbmV3IGNvbmZpZyBvcHRpb25zLlxuICAgKlxuICAgKiBPbmx5IGFuIGlkbGUgUkJyb2tlciBpbnN0YW5jZSBjYW4gYmUgcmVmcmVzaGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIHJlZnJlc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IFN0YXJ0dXAgb3B0aW9ucyBmb3IgYSBgUG9vbGVkVGFza1JCcm9rZXJgLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHdyYXBwaW5nIHRoZSByZXNvbHV0aW9uIG9mIGVpdGhlciBcInJlc29sdmVcIiBvciBcbiAgICogXCJyZWplY3RcIiBjYWxsYmFjay5cbiAgICogQGFwaSBwdWJsaWMgICBcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICB2YXIgY2FsbHMgPSBbXSwgXG4gICAgICAgIGRhdGEgID0ge30sXG4gICAgICAgIHJ1c2VyID0gdGhpcy5ydXNlcjtcblxuICAgIGlmKCF0aGlzLmlzSWRsZSgpKSB7XG4gICAgICAvL3ZhciBkZWZlciA9IHdoZW4uZGVmZXIoKTtcbiAgICAgIC8vZGVmZXIucmVqZWN0KG5ldyBFcnJvcignUkJyb2tlciBpcyBub3QgaWRsZSwgIHJlZnJlc2ggbm90IHBlcm1pdHRlZC4nKSk7XG4gICAgICAvL3JldHVybiBkZWZlci5wcm9taXNlO1xuICAgICAgcmV0dXJuIEQucmVqZWN0ZWQobmV3IEVycm9yKCdSQnJva2VyIGlzIG5vdCBpZGxlLCByZWZyZXNoIG5vdCBwZXJtaXR0ZWQuJykpO1xuICAgIH1cblxuICAgIC8vIGFzc2VydCBvbmx5IHRoZSBwcm9wZXIgcGFyYW1ldGVycyBhcmUgb24gdGhlIGNhbGwgXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIGRhdGEgPSB7XG4gICAgICBjb2RlOiAnIyBSZWZyZXNoIHByb2plY3Qgb24gUG9vbGVkVGFza0Jyb2tlci4nLFxuICAgICAgcHJlbG9hZGZpbGVuYW1lOiBjb25maWcucHJlbG9hZGZpbGVuYW1lLFxuICAgICAgcHJlbG9hZGRpcmVjdG9yeTogY29uZmlnLnByZWxvYWRkaXJlY3RvcnksXG4gICAgICBwcmVsb2FkZmlsZWF1dGhvcjogY29uZmlnLnByZWxvYWRmaWxlYXV0aG9yLFxuICAgICAgcHJlbG9hZGZpbGV2ZXJzaW9uOiBjb25maWcucHJlbG9hZGZpbGV2ZXJzaW9uXG4gICAgfTsgICAgXG5cbiAgICAvLyBleGUgd2lsbCBmdWxmaWxsIG9ubHkgb25jZSBhbGwgdGhlIGlucHV0cyBoYXZlIGZ1bGZpbGxlZCAgICAgXG4gICAgdGhpcy5yZXNvdXJjZVRva2VuUG9vbC5xLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdCkge1xuICAgICAgY2FsbHMucHVzaChcbiAgICAgICAgZGVwbG95ci5pbygnL3IvcHJvamVjdC9yZWN5Y2xlJylcbiAgICAgICAgLnNoYXJlKHJ1c2VyLmdldENvb2tpZXMoKSlcbiAgICAgICAgLmRlbGF5KClcbiAgICAgICAgLmRhdGEoIHsgcHJvamVjdDogcHJvamVjdCB9KVxuICAgICAgICAuZW5kKClcbiAgICAgICAgLmlvKCcvci9wcm9qZWN0L2V4ZWN1dGUvY29kZScpXG4gICAgICAgIC5zaGFyZShydXNlci5nZXRDb29raWVzKCkpXG4gICAgICAgIC5kZWxheSgpXG4gICAgICAgIC5kYXRhKG1lcmdlKGRhdGEsIHsgcHJvamVjdDogcHJvamVjdCB9KSlcbiAgICAgICAgLmVuZCgpICk7XG4gICAgfSk7XG5cbiAgICAvLyBleGVjdXRlIGEgc2VyaWVzIG9mIHNlcXVlbnRpYWxseSBjaGFpbmVkIHRhc2tzIGluIHNlcXVlbmNlIGJhdGNoZXMgXG4gICAgLy8gd2l0aG91dCBvdmVybGFwLiBXb3JrcyBpbiBjb25qdW5jdGlvbiB3aXRoIC5kZWxheSgpICsgLmVuZCgpIG9yIGlmIG5vXG4gICAgLy8gLmVuZCgpIGlzIHVzZWRcbiAgICByZXR1cm4gZGVwbG95ci5waXBlbGluZShjYWxscyk7ICAgICAgXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2UgYWxsIGNsaWVudC1zaWRlIGFuZCBzZXJ2ZXItc2lkZSByZXNvdXJjZXMgbWFpbnRhaW5lZCBieSBvciBvbiBcbiAgICogYmVoYWxmIG9mIGFuIGluc3RhbmNlIG9mIGBSQnJva2VyYC5cbiAgICpcbiAgICogQG1ldGhvZCBzaHV0ZG93blxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHdyYXBwaW5nIHRoZSByZXNvbHV0aW9uIG9mIGVpdGhlciBcInJlc29sdmVcIiBvciBcbiAgICogXCJyZWplY3RcIiBjYWxsYmFjay5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovICAgXG4gIHNodXRkb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb2plY3RzID0gdGhpcy5yZXNvdXJjZVRva2VuUG9vbC5xLnNsaWNlKCk7XG5cbiAgICB0aGlzLnJlc291cmNlVG9rZW5Qb29sLnEgPSBbXTtcbiAgICB0aGlzLmh0dHBLZWVwQWxpdmUuc3RvcCgpO1xuICAgIHRoaXMuZmx1c2goKTsgICAgICBcblxuICAgIHJldHVybiB0aGlzLnJ1c2VyLnJlbGVhc2UocHJvamVjdHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVXb3JrZXI6IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgcmV0dXJuIFBvb2xlZFRhc2tXb3JrZXIubmV3KHRhc2ssIHRoaXMucnVzZXIpO1xuICB9ICBcbn0pO1xuIiwiLyohXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBieSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgdGVybXMgb2YgVmVyc2lvbiAyLjAgb2YgdGhlXG4gKiBBcGFjaGUgTGljZW5zZS4gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIFdJVEhPVVRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVFksIElOQ0xVRElORyBUSE9TRSBPRiBOT04tSU5GUklOR0VNRU5ULFxuICogTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBQbGVhc2UgcmVmZXIgdG8gdGhlXG4gKiBBcGFjaGUgTGljZW5zZSAyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCkgZm9yIG1vcmVcbiAqIGRldGFpbHMuXG4gKi9cbnZhciBkZXBsb3lyICAgICAgICAgICAgID0gcmVxdWlyZSgnZGVwbG95cicpLFxuICAgIG1lcmdlICAgICAgICAgICAgICAgPSByZXF1aXJlKCdtZXJnZScpLFxuICAgIEJhc2UgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdzZWxmaXNoJykuQmFzZSxcbiAgICBFdmVudEVtaXR0ZXIgICAgICAgID0gcmVxdWlyZSgnZGVwbG95ci9saWIvZW1pdHRlcicpLFxuICAgIFJUYXNrVG9rZW4gICAgICAgICAgPSByZXF1aXJlKCcuLi9ydGFzay10b2tlbicpLFxuICAgIFJUYXNrUXVldWUgICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlsL3J0YXNrLXF1ZXVlJyksXG4gICAgTUFYX1RBU0tfUVVFVUVfU0laRSA9IDk5OTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgaGlnaC1sZXZlbCBwcm9ncmFtbWluZyBtb2RlbCBmb3IgYnVpbGRpbmcgRGVwbG95Ui1lbmFibGVkIFxuICogY2xpZW50IGFwcGxpY2F0aW9ucy4gQnkgdXNpbmcgUkJyb2tlciBhbiBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgY2FuIGZvY3VzIFxuICogZW50aXJlbHkgb24gaW50ZWdyYXRpbmcgUiBBbmFseXRpY3MsIHdoaWxlIG9mZmxvYWRpbmcgdGhlIGNvbXBsZXhpdHkgb2YgXG4gKiBtYW5hZ2luZyBjbGllbnQtc2lkZSBBUEkgdGFzayBxdWV1ZXMgYW5kIHNlcnZlci1zaWRlIFIgc2Vzc2lvbiBsaWZlY3ljbGVzLlxuICpcbiAqIFRoZSBiYXNpYyBwcm9ncmFtbWluZyBtb2RlbCBmb3Igd29ya2luZyB3aXRoIFJCcm9rZXIgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAxLiBEZWNpZGUgaWYgdGhlIFIgQW5hbHl0aWNzIHRhc2tzIGZvciB5b3VyIGFwcGxpY2F0aW9uIHNob3VsZCBleGVjdXRlIGFzOlxuICogICAgLSBEaXNjcmV0ZSB0YXNrczogYXV0aGVudGljYXRpb24gb3B0aW9uYWwsIGdyaWQgcmVzb3VyY2VzIGFsbG9jYXRlZCBhdCBcbiAqICAgICAgcnVudGltZSwgcmVzdWx0cyByZXR1cm5lZCBpbW1lZGlhdGVseSwgbm8gcGVyc2lzdGVuY2UuIEdvb2QgZm9yIFxuICogICAgICBwcm90b3R5cGluZyBhbmQgcHVibGljIGZhY2luZyBwcm9kdWN0aW9uIGRlcGxveW1lbnRzLlxuICogICAgLSBQb29sZWQgdGFza3M6IGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkLCBncmlkIHJlc291cmNlcyBwcmUtYWxsb2NhdGVkLCBcbiAqICAgICAgcmVzdWx0cyByZXR1cm5lZCBpbW1lZGlhdGVseSwgb3B0aW9uYWwgcGVyc2lzdGVuY2UgdG8gcmVwb3NpdG9yeS4gR29vZCBcbiAqICAgICAgZm9yIGVudGVycHJpc2UgcHJvZHVjdGlvbiBkZXBsb3ltZW50cywgY29uc2lzdGVudCBydW50aW1lLCBcbiAqICAgICAgaGlnaC10aHJvdWdocHV0IGVudmlyb25tZW50cy5cbiAqICAgIC0gQmFja2dyb3VuZCB0YXNrczogYXV0aGVudGljYXRpb24gcmVxdWlyZWQsIGdyaWQgcmVzb3VyY2VzIGFsbG9jYXRlZCBhdCBcbiAqICAgICAgcnVudGltZSwgcmVzdWx0cyBwZXJzaXN0ZWQgZm9yIGxhdGVyIHJldHJpZXZhbC4gR29vZCBmb3IgcGVyaW9kaWMsIFxuICogICAgICBzY2hlZHVsZWQgb3IgYmF0Y2ggcHJvY2Vzc2luZy5cbiAqIDIuIFVzZSB0aGUgZmFjdG9yaWVzIGRlZmluZWQgaW4gcmJyb2tlciB0byBjcmVhdGUgYW4gYXBwcm9wcmlhdGUgaW5zdGFuY2Ugb2YgXG4gKiAgICBgUkJyb2tlYHIuXG4gKiAzLiBEZWZpbmUgdGhlIFIgQW5hbHl0aWNzIHRhc2tzIGZvciB5b3VyIGFwcGxpY2F0aW9uIGFzIG9uZSBvciBtb3JlIGBSVGFza2AuXG4gKiA0LiBTdWJtaXQgeW91ciBgUlRhc2tgIHRvIGBSQnJva2VyYCBmb3IgZXhlY3V0aW9uLlxuICogNS4gSW50ZWdyYXRlIHRoZSByZXN1bHRzIG9mIHlvdXIgYFJUYXNrYCBmb3VuZCB3aXRoaW4gYC5jb21wbGV0ZSgpYFxuICpcbiAqIEBtb2R1bGUgcmJyb2tlci1lbmdpbmVcbiAqIEBmb3IgcmJyb2tlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKEV2ZW50RW1pdHRlciwge1xuXG4gICAvKipcbiAgICAqIFJlcHJlc2VudHMgYSBoaWdoLWxldmVsIHByb2dyYW1taW5nIG1vZGVsIGZvciBidWlsZGluZyBEZXBsb3lSLWVuYWJsZWRcbiAgICAqIGNsaWVudCBhcHBsaWNhdGlvbnMuXG4gICAgKlxuICAgICogQGNsYXNzIFxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9ucy4gICAgXG4gICAgKi9cbiAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIEV2ZW50RW1pdHRlci5pbml0aWFsaXplLmNhbGwodGhpcyk7XG5cbiAgICAgIHZhciBzZWxmICAgICAgICAgICAgICAgPSB0aGlzO1xuICAgICAgdGhpcy5jb25maWcgICAgICAgICAgICA9IGNvbmZpZztcbiAgICAgIHRoaXMuc2NvcGUgICAgICAgICAgICAgPSB0aGlzLmNvbmZpZy5jdHggfHwgdGhpczsgLy8gRXZlbnRFbWl0dGVyIGNvbnRleHRcbiAgICAgIHRoaXMuZW5naW5lU3RhcnRlZCAgICAgPSBmYWxzZTtcbiAgICAgIHRoaXMucGFyYWxsZWxUYXNrTGltaXQgPSB0aGlzLmNvbmZpZy5tYXhDb25jdXJyZW50VGFza0xpbWl0IHx8IDE7XG4gICAgICB0aGlzLnBlbmRpbmdMb3cgICAgICAgID0gUlRhc2tRdWV1ZS5uZXcoTUFYX1RBU0tfUVVFVUVfU0laRSk7XG4gICAgICB0aGlzLnBlbmRpbmdIaWdoICAgICAgID0gUlRhc2tRdWV1ZS5uZXcoTUFYX1RBU0tfUVVFVUVfU0laRSk7XG4gICAgICB0aGlzLnJlc291cmNlVG9rZW5Qb29sID0gUlRhc2tRdWV1ZS5uZXcoTUFYX1RBU0tfUVVFVUVfU0laRSk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBDb25maWd1cmUgYGRlcGxveXJgIGNsaWVudCB3aXRoIHN1cHBsaWVkIHJ1bnRpbWUgc2V0dGluZ3MgYW5kIGNhdGNoIFxuICAgICAgLy8gYWxsIGBpb2AgaW50ZXJuYWwgZXJyb3JzLlxuICAgICAgLy8gICAgICBcbiAgICAgIGRlcGxveXIuY29uZmlndXJlKCB7IFxuICAgICAgICBob3N0OiBjb25maWcuaG9zdCwgXG4gICAgICAgIGNvcnM6IGNvbmZpZy5jb3JzLFxuICAgICAgICBsb2dnaW5nOiBjb25maWcubG9nZ2luZyxcbiAgICAgICAgYWxsb3dTZWxmU2lnbmVkU1NMQ2VydDogY29uZmlnLmFsbG93U2VsZlNpZ25lZFNTTENlcnQsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihhcGksIHJlcykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHJlcyk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvKipcbiAgICAgICAqIENvcnJlbGF0ZSB0aGUgcnVubmluZyB0YXNrIGNvdW50ZXIgYW5kIG90aGVyIHJ1bnRpbWUgc3RhdGlzdGljcy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICB0aGlzLnJ1bnRpbWUgPSB7XG4gICAgICAgICBydW5uaW5nVGFza3M6IDAsXG5cbiAgICAgICAgIHRvdGFsczogeyBzdWNjZXNzOiAwLCBmYWlsdXJlOiAwIH0sXG5cbiAgICAgICAgIHN0YXRzOiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogc2VsZi5tYXhDb25jdXJyZW5jeSgpLFxuICAgICAgICAgICAgICAgdG90YWxUYXNrc1J1bjogdGhpcy50b3RhbHMuc3VjY2VzcyArIHRoaXMudG90YWxzLmZhaWx1cmUsXG4gICAgICAgICAgICAgICB0b3RhbFRhc2tzUnVuVG9TdWNjZXNzOiB0aGlzLnRvdGFscy5zdWNjZXNzLFxuICAgICAgICAgICAgICAgdG90YWxUYXNrc1J1blRvRmFpbHVyZTogdGhpcy50b3RhbHMuZmFpbHVyZSxcbiAgICAgICAgICAgICAgIHRvdGFsVGltZVRhc2tzT25Db2RlOiByZXMucmVzdWx0LnRpbWVPbkNvZGUsXG4gICAgICAgICAgICAgICB0b3RhbFRpbWVUYXNrc09uU2VydmVyOiByZXMucmVzdWx0LnRpbWVPblNlcnZlcixcbiAgICAgICAgICAgICAgIHRvdGFsVGltZVRhc2tzT25DYWxsOiByZXMucmVzdWx0LnRpbWVPbkNhbGwsXG4gICAgICAgICAgICAgICB0YXNrOiByZXMudGFza1xuICAgICAgICAgICAgfTtcbiAgICAgICAgIH0sXG5cbiAgICAgICAgIGNhbGlicmF0ZTogZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmdUYXNrcyA9IHRoaXMucnVubmluZ1Rhc2tzICsgZGlyZWN0aW9uO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5ydW5uaW5nVGFza3MgPCAwKSB7XG4gICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmdUYXNrcyA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmdUYXNrcztcbiAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIC0tIGVtaXR0ZWQgYnkgc3ViY2xhc3NlcyBpbmRpY2F0aW5nIHdvcmtlcnMgY2FuIGJlZ2luIHdvcmsgLS1cbiAgICAgIHRoaXMub24oJ3JlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICB0aGlzLmVuZ2luZVN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAvLyBGbHVzaCB0aGUgcXVldWVzIHRvIGZvcmNlIHdvcmsuXG4gICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFyYWxsZWxUYXNrTGltaXQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSWRsZSgpKSB7XG4gICAgICAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfSk7ICAgICAgXG4gICB9LFxuICAgXG4gICAvKipcbiAgICAqIFRlc3QgdGhlIGAvci9zZXJ2ZXIvaW5mb2AgZW5kcG9pbnQsIGV4cGVjdCBIVFRQIDIwMCBvdGh3cmlzZVxuICAgICpcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFRoZSBvcHRpb25hbCBjYWxsYmFja1xuICAgICogQGFwaSBwdWJsaWMgICAgXG4gICAgKi9cbiAgIHZhbGlkYXRlRW5kcG9pbnQ6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gZGVwbG95ci5pbygnL3Ivc2VydmVyL2luZm8nKVxuICAgICAgICAgICAgIC5jdHgodGhpcylcbiAgICAgICAgICAgICAudGltZW91dCgxMDAwICogMTApIFxuICAgICAgICAgICAgIC5lbmQoY2IpO1xuICAgfSxcblxuICAgb3duZXI6IGZ1bmN0aW9uKCkge1xuICAgICByZXR1cm4gdGhpcy5ydXNlcjtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogTGF1bmNoIGFuIGBSVGFza0FwcFNpbXVsYXRvcmAgc2ltdWxhdGlvbi4gVGhlIGBSVGFza2AgZGVmaW5lZCBieSB5b3VyIFxuICAgICogc2ltdWxhdGlvbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZXhlY3V0ZWQgYnkgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgXG4gICAgKiBgUkJyb2tlcmAuXG4gICAgKlxuICAgICogTWFrZSBzdXJlIHRvIHJlZ2lzdGVyIHlvdXIgYC5jb21wbGV0ZSgpYCwgYC5lcnJvcigpYCwgYC5pZGxlKClgLCBhbmRcbiAgICAqIGAucHJvZ3Jlc3MoKWAgbGlzdGVuZXJzIGJlZm9yZSBzdGFydGluZyB5b3VyIHNpbXVsYXRpb24gaW4gb3JkZXIgdG8gXG4gICAgKiByZWNlaXZlIGFzeW5jaHJvbm91cyBjYWxsYmFja3MgaW4geW91ciBhcHBsaWNhdGlvbiB3aGVuIGBSVGFza2AgY29tcGxldGUgXG4gICAgKiBhbmQvb3IgdG8gcmVjZWl2ZSBydW50aW1lIHN1bW1hcnkgc3RhdGlzdGljcyBmcm9tIGBSQnJva2VyYCBhcyB0aGUgXG4gICAgKiBzaW11bGF0aW9uIHByb2NlZWRzLlxuICAgICpcbiAgICAqIEBtZXRob2Qgc2ltdWxhdGVBcHBcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgQXBwbGljYXRpb24gU2ltdWxhdG9yIHRoYXQgaW1wbGVtZW50cyB0aGVcbiAgICAqIGBzaW11bGF0ZUFwcChSQnJva2VyKWAgbWV0aG9kLlxuICAgICogQGFwaSBwdWJsaWNcbiAgICAqL1xuICAgc2ltdWxhdGVBcHA6IGZ1bmN0aW9uKGFwcFNpbXVsYXRvcikge1xuICAgICAgaWYgKGFwcFNpbXVsYXRvcikge1xuICAgICAgICAgaWYgKHR5cGVvZiBhcHBTaW11bGF0b3Iuc2ltdWxhdGVBcHAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFwcFNpbXVsYXRvci5zaW11bGF0ZUFwcCh0aGlzKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZUVycm9yOiBcInNpbXVsYXRlQXBwXCIgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH0sXG5cbiAgIC8qKlxuICAgICogU3VibWl0IGFuIGBSVGFza2AgZm9yIGV4ZWN1dGlvbiB1bmRlciB0aGUgY29udHJvbCBvZiBgUkJyb2tlcmAuIElmIFxuICAgICogcHJpb3JpdHkgaXMgaW5kaWNhdGVkLCBwcmlvcml0eSB0YXNrcyBhcmUgYXV0b21hdGljYWxseSBtb3ZlZCB0byB0aGUgZnJvbnRcbiAgICAqIG9mIHRoZSBxdWV1ZSwgYWhlYWQgb2YgYWxsIHN0YW5kYXJkIHRhc2tzIHRoYXQgYXJlIGFscmVhZHkgcGVuZGluZyBcbiAgICAqIGV4ZWN1dGlvbiBieSB0aGUgYnJva2VyLlxuICAgICpcbiAgICAqIEBtZXRob2Qgc3VibWl0ICAgXG4gICAgKiBAcGFyYW0ge1JUYXNrfSBUaGUgYFJUYXNrYCBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdWJtaXNzaW9uLlxuICAgICogQHBhcmFtIHtCb29sZWFufSAob3B0aW9uYWwpIE1hcmsgdGhpcyB0YXNrIGFzIGhhdmluZyBwcmlvcml0eS5cbiAgICAqIEByZXR1cm4ge1JUYXNrVG9rZW59IFRoZSBoYW5kbGUgdG8gYW4gYFJUYXNrYCBsaXZlIG9uIGFuIGBSQnJva2VyYC5cbiAgICAqIEBhcGkgcHVibGljXG4gICAgKi9cbiAgIHN1Ym1pdDogZnVuY3Rpb24odGFzaywgcHJpb3JpdHkpIHtcbiAgICAgIC8vIGB3b3JrZXJgIGlzIGEgZGVmcmVkIG9iamVjdC4gSXQgaXMgZWl0aGVyIGN1cnJlbnRseSB3b3JraW5nIG9yIHF1ZXVlZCBcbiAgICAgIC8vIHVwIHdpdGggYW4gYXBwb2ludG1lbnQgdG8gd29yayBpbiB0aGUgZnV0dXJlIG9uY2UgYHJ1bigpYCBpcyBjYWxsZWQgICBcbiAgICAgIHZhciB3b3JrZXIgICAgPSB0aGlzLmNyZWF0ZVdvcmtlcih0YXNrKSxcbiAgICAgICAgICB0YXNrVG9rZW4gPSBSVGFza1Rva2VuLm5ldyh3b3JrZXIpO1xuXG4gICAgICBpZiAocHJpb3JpdHkpIHtcbiAgICAgICAgIHRoaXMucGVuZGluZ0hpZ2gub2ZmZXIod29ya2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICB0aGlzLnBlbmRpbmdMb3cub2ZmZXIod29ya2VyKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhcnQgdGhlIHRhc2sgd29yayAgICAgIFxuICAgICAgdGhpcy5ydW4oKTtcblxuICAgICAgcmV0dXJuIHRhc2tUb2tlbjtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgdGFzayBleGVjdXRpb24gY29uY3VycmVuY3kgbGV2ZWxzIGVuZm9yY2VkIGZvciB0aGlzIGluc3RhbmNlIFxuICAgICogb2YgYFJCcm9rZXJgLlxuICAgICpcbiAgICAqIEBtZXRob2QgbWF4Q29uY3VycmVuY3lcbiAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIHRhc2sgZXhlY3V0aW9uIGNvbmN1cnJlbmN5IGxldmVscy5cbiAgICAqIEBhcGkgcHVibGljXG4gICAgKi9cbiAgIG1heENvbmN1cnJlbmN5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFsbGVsVGFza0xpbWl0O1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBGbHVzaGVzIGFsbCBwZW5kaW5nIGBSVGFza2AgZnJvbSBxdWV1ZXMgbWFpbnRhaW5lZCBieSBgUkJyb2tlcmAuIEZsdXNoaW5nIFxuICAgICogYFJUYXNrYCBxdWV1ZXMgZW5zdXJlcyB0aGF0IHF1ZXVlZCB0YXNrcyB3aWxsIG5vdCBiZSBleGVjdXRlZCBieSBcbiAgICAqIGBSQnJva2VyYC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIGZsdXNoXG4gICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBsaXRlcmFsIGNvbnRhaW5pbmcgYFJCcm9rZXJgIHN0YXR1cyBpbmRpY2F0aW5nIFxuICAgICogdGhlIG51bWJlciBvZiBjdXJyZW50bHkgcXVldWVkIGFuZCBleGVjdXRpbmcgYFJUYXNrYC5cbiAgICAqIEBhcGkgcHVibGljXG4gICAgKi9cbiAgIGZsdXNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucGVuZGluZ0hpZ2guY2xlYXIoKTtcbiAgICAgIHRoaXMucGVuZGluZ0xvdy5jbGVhcigpO1xuXG4gICAgICByZXR1cm4gdGhpcy5zdGF0dXMoKTtcbiAgIH0sXG4gICBcbiAgIC8qKlxuICAgICogSW5kaWNhdGVzIGlmIGN1cnJlbnQgYFJCcm9rZXJgIGluc3RhbmNlIGlzIHN0aWxsIGNvbm5lY3RlZCB0byB0aGUgRGVwbG95UiBcbiAgICAqIHNlcnZlci4gQSBjb25uZWN0aW9uIG1heSBiZSBsb3N0IGZvciBhIG51bWJlciBvZiByZWFzb25zLCBmb3IgZXhhbXBsZSwgZHVlIFxuICAgICogdG8gYSBkcm9wcGVlZCBuZXR3b3JrIGNvbm5lY3Rpb24gYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlciBvciBpZiB0aGUgXG4gICAgKiBEZXBsb3lSIHNlcnZlciBpdHNlbGYgZ29lcyBkb3duLlxuICAgICpcbiAgICAqIEBtZXRob2QgaXNDb25uZWN0ZWRcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB3aXRoIGEgYEJvb2xlYW5gIHZhbHVlIGNvbm5lY3Rpb24gc3RhdHVzLiAgICBcbiAgICAqIEBhcGkgcHVibGljXG4gICAgKi9cbiAgIGlzQ29ubmVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ZXN0ID0gdGhpcy5ydXNlciA/IHRoaXMucnVzZXIuaW8oJy9yL3VzZXIvYWJvdXQnKSA6XG4gICAgICAgICAgICAgICAgICAgZGVwbG95ci5pbygnL3Ivc2VydmVyL2luZm8nKVxuXG4gICAgICAvL1xuICAgICAgLy8gKGF1dGhlbnRpY2F0ZWQgfCBhbm9ueW1vdXMpIGNoZWNrc1xuICAgICAgLy8gYXV0aGVudGljYXRlZCAgLSBUZXN0IGNvbm5lY3Rpb24gdG8gYXV0aGVudGljYXRlZCBIVFRQIHNlc3Npb25cbiAgICAgIC8vIGFub255bW91cyAtIFRlc3QgdGhlIHRoYXQgdGhlIHNlcnZlciBpcyB1cC5cbiAgICAgIC8vIFxuICAgICAgcmV0dXJuIHRlc3RcbiAgICAgICAgICAgICAgICAuZ2xvYmFsKGZhbHNlKSAvLyBzdXByZXNzIGdsb2JhbCBlcnJvciBldmVudHMgZm9yIHRoaXMgYGlvYFxuICAgICAgICAgICAgICAgIC5wcm9taXNlKClcbiAgICAgICAgICAgICAgICAuc3VjY2VzcyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5lcnJvcihmdW5jdGlvbigpIHsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIFJldHVybnMgc3RhdHVzIGluZGljYXRpbmcgY3VycmVudCBgUlRhc2tgIGFjdGl2aXR5IG9uIGBSQnJva2VyYC5cbiAgICAqXG4gICAgKlxuICAgICogQG1ldGhvZCBzdGF0dXNcbiAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyBgUkJyb2tlcmAgc3RhdHVzIGluZGljYXRpbmcgdGhlIFxuICAgICogbnVtYmVyIG9mIGN1cnJlbnRseSBxdWV1ZWQgYW5kIGV4ZWN1dGluZyBgUlRhc2tgLlxuICAgICogQGFwaSBwdWJsaWNcbiAgICAqL1xuICAgc3RhdHVzOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFBlbmRpbmcgdGFza3MgaW5jbHVkZSBhbGwgdGFza3Mgb24gaGlnaCBhbmQgbG93IHByaW9yaXR5IHF1ZXVlcy5cbiAgICAgIHZhciBwZW5kaW5nICA9IHRoaXMucGVuZGluZ0hpZ2guc2l6ZSgpICsgdGhpcy5wZW5kaW5nTG93LnNpemUoKSxcbiAgICAgICAgIGV4ZWN1dGluZyA9IHRoaXMucGFyYWxsZWxUYXNrTGltaXQgLSB0aGlzLnJ1bnRpbWUucnVubmluZ1Rhc2tzLFxuICAgICAgICAgaWRsZSAgICAgID0gdGhpcy5pc0lkbGUoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIHBlbmRpbmc6IHBlbmRpbmcsXG4gICAgICAgICBleGVjdXRpbmc6IGV4ZWN1dGluZyxcbiAgICAgICAgIGlkbGU6IGlkbGUsXG4gICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcblJCcm9rZXJTdGF0dXM6IFsgcGVuZGluZyA9IFwiJyArIHBlbmRpbmcgKyAnXCIgXSAnICtcbiAgICAgICAgICAgICAgICdbIGV4ZWN1dGluZyA9IFwiJyArIGV4ZWN1dGluZyArICdcIiBdICcgK1xuICAgICAgICAgICAgICAgJ1sgaWRsZSA9IFwiJyArIGlkbGUgKyAnXCIgXVxcbic7XG4gICAgICAgICB9XG4gICAgICB9O1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBVc2VkIHRvIGRldGVybWluZSBpZiBhbiBgUkJyb2tlcmAgaW5zdGFuY2UgaXMgaWRsZSB3aGljaCBjYW4gYmUgXG4gICAgKiBwYXJ0aWN1bGFybHkgdXNlZnVsIGFoZWFkIG9mIGNhbGxzIHRvIGBzaHV0ZG93bigpYC4gQW5vdGhlciBvcHRpb25zIGlzIHRvXG4gICAgKiBiaW5kIGEgbGlzdGVuZXIgdG8gdGhlIGAuaXNJZGxlKClgIG1ldGhvZC5cbiAgICAqIFxuICAgICogQG1ldGhvZCBpc0lkbGVcbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBgUkJyb2tlcmAgaW5zdGFuY2UgaXMgaWRsZS5cbiAgICAqIEBhcGkgcHVibGljXG4gICAgKi9cbiAgIGlzSWRsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKHRoaXMucnVudGltZS5ydW5uaW5nVGFza3MgPT09IDAgJiZcbiAgICAgICAgIHRoaXMucGVuZGluZ0xvdy5pc0VtcHR5KCkgJiYgdGhpcy5wZW5kaW5nSGlnaC5pc0VtcHR5KCkpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBBbiBpbml0aWFsaXphdGlvbiBsaWZlY3ljbGUgbGlzdGVuZXIgZmlyZWQgZHVyaW5nIGNvbnN0cnVjdGlvbi4gXG4gICAgKlxuICAgICogQG1ldGhvZCBlcnJvclxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLiAgICBcbiAgICAqIEByZXR1cm4ge1JCcm9rZXJ9IFRoZSByZWZyZW5jZSB0byBgdGhpc2AgYFJCcm9rZXJgIHVzZWQgZm9yIGNoYWluaW5nLlxuICAgICogQGFwaSBwdWJsaWNcbiAgICAqL1xuICAgcmVhZHk6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICB0aGlzLm9uKCdyZWFkeScsIGZuKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LCAgICAgIFxuXG4gICAvKipcbiAgICAqIEEgZmFpbHVyZSBsaXN0ZW5lciBmb3IgYWxsIHRhc2tzIHN1Ym1pdHRlZCBvbiBiZWhhbGYgb2YgYHRoaXNgIGBSQnJva2VyYC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIGVycm9yXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uICAgIFxuICAgICogQHJldHVybiB7UkJyb2tlcn0gVGhlIHJlZnJlbmNlIHRvIGB0aGlzYCBgUkJyb2tlcmAgdXNlZCBmb3IgY2hhaW5pbmcuXG4gICAgKiBAYXBpIHB1YmxpY1xuICAgICovXG4gICBlcnJvcjogZnVuY3Rpb24oZm4pIHtcbiAgICAgIHRoaXMub24oJ2Vycm9yJywgZm4pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogQSBub3RpZmljYXRpb24gbGlzdGVuZXIgaW5kaWNhdGluZyB3YXJuaW5ncyBhYm91dCBkdWJpb3VzIHJ1bnRpbWUgYmVoYXZpb3JcbiAgICAqIHN1Ym1pdHRlZCBvbiBiZWhhbGYgb2YgYHRoaXNgIGBSQnJva2VyYC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIHdhcm5pbmdcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFRoZSBjYWxsYmFjayBmdW5jdGlvbi4gICAgXG4gICAgKiBAcmV0dXJuIHtSQnJva2VyfSBUaGUgcmVmcmVuY2UgdG8gYHRoaXNgIGBSQnJva2VyYCB1c2VkIGZvciBjaGFpbmluZy5cbiAgICAqIEBhcGkgcHVibGljXG4gICAgKi9cbiAgIHdhcm5pbmc6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICB0aGlzLm9uKCd3YXJuaW5nJywgZm4pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sICAgXG5cbiAgIC8qKlxuICAgICogQSBjb21wbGV0aW9uIGxpc3RlbmVyIGZvciBhbGwgdGFza3Mgc3VibWl0dGVkIG9uIGJlaGFsZiBvZiBgdGhpc2AgXG4gICAgKiBgUkJyb2tlcmAuXG4gICAgKlxuICAgICogQG1ldGhvZCBjb21wbGV0ZVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLiAgICBcbiAgICAqIEByZXR1cm4ge1JCcm9rZXJ9IFRoZSByZWZyZW5jZSB0byBgdGhpc2AgYFJCcm9rZXJgIHVzZWQgZm9yIGNoYWluaW5nLlxuICAgICogQGFwaSBwdWJsaWNcbiAgICAqL1xuICAgY29tcGxldGU6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICB0aGlzLm9uKCdjb21wbGV0ZScsIGZuKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIEEgbm90aWZpY2F0aW9uIGxpc3RlbmVyIGluZGljYXRpbmcgdGhhdCBgdGhpc2AgYFJicm9rZXJgIGlzIHN0aWxsIGFjdGl2ZSBcbiAgICAqIGFuZCB0aGVyZSBhcmUgY3VycmVudGx5IG5vIGBSVGFza3NgIHJ1bm5pbmcgb3IgaW4gdGhlIHdhaXQgcXVldWUuXG4gICAgKlxuICAgICogQG1ldGhvZCBpZGxlXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uICAgIFxuICAgICogQHJldHVybiB7UkJyb2tlcn0gVGhlIHJlZnJlbmNlIHRvIGB0aGlzYCBgUkJyb2tlcmAgdXNlZCBmb3IgY2hhaW5pbmcuXG4gICAgKiBAYXBpIHB1YmxpY1xuICAgICovXG4gICBpZGxlOiBmdW5jdGlvbihmbikge1xuICAgICAgdGhpcy5vbignaWRsZScsIGZuKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIEEgbm90aWZpY2F0aW9uIGxpc3RlbmVyIGZvciBgUkJyb2tlcmAgcnVudGltZSBzdGF0aXN0aWNzIG9mIGEgYFJUYXNrYC5cbiAgICAqXG4gICAgKiBAbWV0aG9kIHByb2dyZXNzXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgKiBAcmV0dXJuIHtSQnJva2VyfSBUaGUgcmVmcmVuY2UgdG8gYHRoaXNgIGBSQnJva2VyYCB1c2VkIGZvciBjaGFpbmluZy5cbiAgICAqIEBhcGkgcHVibGljXG4gICAgKi9cbiAgIHByb2dyZXNzOiBmdW5jdGlvbihmbikge1xuICAgICAgdGhpcy5vbigncHJvZ3Jlc3MnLCBmbik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBBIG5vdGlmaWNhdGlvbiBsaXN0ZW5lciBmb3IgYFJCcm9rZXJgIHJ1bnRpbWUgc3RhdGlzdGljcyBvZiBhIGBSVGFza2AuXG4gICAgKlxuICAgICogQG1ldGhvZCBwcm9ncmVzc1xuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICogQHJldHVybiB7UkJyb2tlcn0gVGhlIHJlZnJlbmNlIHRvIGB0aGlzYCBgUkJyb2tlcmAgdXNlZCBmb3IgY2hhaW5pbmcuXG4gICAgKiBAYXBpIHB1YmxpY1xuICAgICovXG4gICBzdGFydDogZnVuY3Rpb24oZm4pIHtcbiAgICAgIHRoaXMub24oJ3N0YXJ0JywgZm4pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgIH0sICAgXG5cbiAgIC8qKlxuICAgICogRG8gdGhlIHRhc2sgd29yay5cbiAgICAqXG4gICAgKiBAYXBpIHByaXZhdGVcbiAgICAqL1xuICAgcnVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcywgbmV4dFdvcmtlciwgcmVzb3VyY2VUb2tlbjtcblxuICAgICAgaWYgKHRoaXMuZW5naW5lU3RhcnRlZCAmJlxuICAgICAgICAgIXRoaXMucmVzb3VyY2VUb2tlblBvb2wuaXNFbXB0eSgpICYmXG4gICAgICAgICAoIXRoaXMucGVuZGluZ0xvdy5pc0VtcHR5KCkgfHwgIXRoaXMucGVuZGluZ0hpZ2guaXNFbXB0eSgpKSkge1xuXG4gICAgICAgICBuZXh0V29ya2VyID0gdGhpcy5wZW5kaW5nSGlnaC50YWtlKCkgfHwgdGhpcy5wZW5kaW5nTG93LnRha2UoKTtcblxuICAgICAgICAgdGhpcy5ydW50aW1lLmNhbGlicmF0ZSgrMSk7XG5cbiAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCBuZXh0V29ya2VyLnRhc2spO1xuICAgICAgICAgXG4gICAgICAgICBuZXh0V29ya2VyLndvcmsodGhpcy5yZXNvdXJjZVRva2VuUG9vbC50YWtlKCkpIC8vIHN0YXJ0IHdvcmtpbmcuLi4uIFxuICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICBzZWxmLnJ1bnRpbWUudG90YWxzLnN1Y2Nlc3MrKztcbiAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIHNlbGYucnVudGltZS5zdGF0cyhyZXMpKTtcbiAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdjb21wbGV0ZScsIHJlcy50YXNrLCByZXMucmVzdWx0KTtcblxuICAgICAgICAgICAgICAgICAvLyAtLSBpbmRpdmlkdWFsIFJUYXNrIG5vdGlmaWNhdGlvbnMgLS0gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICB9LmJpbmQobmV4dFdvcmtlciksIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgdGFzazogdGhpcy50YXNrLFxuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7IC8vIHRhc2sgZXJyb3IgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy50YXNrLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9uQ29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lT25TZXJ2ZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9uQ2FsbDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBlcnJcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICBzZWxmLnJ1bnRpbWUudG90YWxzLmZhaWx1cmUrKztcbiAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIHNlbGYucnVudGltZS5zdGF0cyhyZXMpKTsgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG1lcmdlKGVyciwgeyB0YXNrOiB0aGlzLnRhc2sgfSkpO1xuICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ2NvbXBsZXRlJywgcmVzLnRhc2ssIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgLy8gLS0gaW5kaXZpZHVhbCBSVGFzayBub3RpZmljYXRpb25zIC0tXG4gICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KG1lcmdlKGVyciwgeyB0YXNrOiB0aGlzLnRhc2sgfSkpO1xuICAgICAgICAgICAgIH0uYmluZChuZXh0V29ya2VyKSlcbiAgICAgICAgICAgICAuZW5zdXJlKGZ1bmN0aW9uKHYpIHsgLy8gZmluYWxseVxuICAgICAgICAgICAgICAgICBzZWxmLnJ1bnRpbWUuY2FsaWJyYXRlKC0xKTtcbiAgICAgICAgICAgICAgICAgc2VsZi5yZXNvdXJjZVRva2VuUG9vbC5vZmZlcih0aGlzLnJlc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICBzZWxmLnJ1bigpO1xuXG4gICAgICAgICAgICAgICAgIC8vIC0tIG5vdGlmeSBhbGwgdGFza3Mgc3VibWl0dGVkIGhhdmUgY2FtZSB0byBjb21wbGV0aW9uIC0tICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNJZGxlKCkpIHsgc2VsZi5lbWl0KCdpZGxlJyk7IH1cbiAgICAgICAgICAgICB9LmJpbmQobmV4dFdvcmtlcikpO1xuICAgICAgfVxuICAgfVxufSk7IiwiLyohXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNSBieSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgdGVybXMgb2YgVmVyc2lvbiAyLjAgb2YgdGhlXG4gKiBBcGFjaGUgTGljZW5zZS4gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIFdJVEhPVVRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVFksIElOQ0xVRElORyBUSE9TRSBPRiBOT04tSU5GUklOR0VNRU5ULFxuICogTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBQbGVhc2UgcmVmZXIgdG8gdGhlXG4gKiBBcGFjaGUgTGljZW5zZSAyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCkgZm9yIG1vcmVcbiAqIGRldGFpbHMuXG4gKi9cbnZhciBCYXNlID0gcmVxdWlyZSgnc2VsZmlzaCcpLkJhc2U7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGhhbmRsZSB0byBhbiBgUlRhc2tgIGxpdmUgb24gYW4gYFJCcm9rZXJgLlxuICpcbiAqIEBtb2R1bGUgcnRhc2stdG9rZW5cbiAqIEBmb3IgcmJyb2tlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBoYW5kbGUgdG8gYW4gYFJUYXNrYCBsaXZlIG9uIGFuIGBSQnJva2VyYC5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1JUYXNrfSBUaGUgdGFzayB3b3JrZXIuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSh3b3JrZXIpIHtcbiAgICAgICAgdGhpcy53b3JrZXIgICAgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKiAgICBcbiAgICAgKiBUZXJtaW5hdGVzIGB0aGlzYCBydW5uaW5nIHRhc2suXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNhbmNlbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gUGVybWlzc2lvbiB0byBpbnRlcnJ1cHQgdGFzayBpZiBpdCBpcyBydW5uaW5nLlxuICAgICAqIEByZXR1cm4ge1JUYXNrVG9rZW59IGZvciBjaGFpbmluZy5cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGNhbmNlbDogZnVuY3Rpb24oaW50ZXJydXB0KSB7XG4gICAgICAgIC8vIFJUYXNrIGNvbXBsZXRlZCAocmVzb2x2ZWR8cmVqZWN0ZWQpLCBjYW4gbm90IGJlIGNhbmNlbGxlZC5cbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0aGlzLndvcmtlci50ZXJtaW5hdGUoaW50ZXJydXB0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsbGVkO1xuICAgIH0sXG5cbiAgICAvKiogICAgXG4gICAgICogUmV0dXJucyB0aGUgYFJUYXNrYCBhc3NvY2lhdGVkIHdpdGggdGhpcyBgUlRhc2tUb2tlbmAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFRhc2tcbiAgICAgKiBAcmV0dXJuIHtSVGFza1Rva2VufSBmb3IgY2hhaW5pbmcuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXRUYXNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2VyLnRhc2s7XG4gICAgfSxcblxuICAgIC8qKiAgICBcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHRhc2sgY29tcGxldGVkLiBDb21wbGV0aW9uIG1heSBiZSBkdWUgdG8gbm9ybWFsIFxuICAgICAqIHRlcm1pbmF0aW9uLCBhbiBleGNlcHRpb24sIG9yIGNhbmNlbGxhdGlvbiAtLSBpbiBhbGwgb2YgdGhlc2UgY2FzZXMsIFxuICAgICAqIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkICBcbiAgICAgKiBAbWV0aG9kIGlzRG9uZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IElmIGB0aGlzYCB0YXNrIGlzIGNvbXBsZXRlZC5cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGlzRG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc1BlbmRpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqICAgIFxuICAgICAqIFJldHVybnMgYGZhbHNlYCBpZiB0aGlzIHRhc2sgY29tcGxldGVkLiBDb21wbGV0aW9uIG1heSBiZSBkdWUgdG8gbm9ybWFsIFxuICAgICAqIHRlcm1pbmF0aW9uLCBhbiBleGNlcHRpb24sIG9yIGNhbmNlbGxhdGlvbiAtLSBpbiBhbGwgb2YgdGhlc2UgY2FzZXMsIFxuICAgICAqIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNQZW5kaW5nXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoaXMgdGFzayBoYXMgbm90IHlldCBiZWVuIGNvbXBsZXRlZC5cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGlzUGVuZGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtlci5pc1BlbmRpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqICAgIFxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdGFzayB3YXMgY2FuY2VsbGVkIGJlZm9yZSBpdCBjb21wbGV0ZWQgbm9ybWFsbHkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGlzQ2FuY2VsbGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoaXMgdGFzayB3YXMgY2FuY2VsbGVkIGJlZm9yZSBpdCBjb21wbGV0ZWQuXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBpc0NhbmNlbGxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbGxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGAucHJvbWlzZSgpYCBtZXRob2QgcmV0dXJucyBhIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBQcm9taXNlIHRoYXQgaXMgXG4gICAgICogcmVzb2x2ZWQgb25jZSB0aGlzIHRhc2sgaGFzIGNvbXBsZXRlZC5cbiAgICAgKiAgIFxuICAgICAqIEBtZXRob2QgcHJvbWlzZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB3cmFwcGluZyB0aGUgcmVzb2x1dGlvbiBvZiBlaXRoZXIgXCJyZXNvbHZlXCIgXG4gICAgICogb3IgXCJyZWplY3RcIiBjYWxsYmFjay5cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIHByb21pc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53b3JrZXIuZGVmZXIucHJvbWlzZTtcbiAgICB9XG59KTsiLCIvKiFcbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IGJ5IFJldm9sdXRpb24gQW5hbHl0aWNzIEluYy5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSB0ZXJtcyBvZiBWZXJzaW9uIDIuMCBvZiB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlLiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5UWSwgSU5DTFVESU5HIFRIT1NFIE9GIE5PTi1JTkZSSU5HRU1FTlQsXG4gKiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFBsZWFzZSByZWZlciB0byB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlIDIuMCAoaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wKSBmb3IgbW9yZSBcbiAqIGRldGFpbHMuXG4gKi9cblxudmFyIEJhc2UgICAgID0gcmVxdWlyZSgnc2VsZmlzaCcpLkJhc2UsXG4gICAgRW51bSAgICAgPSByZXF1aXJlKCdlbnVtJyksXG4gICAgdGFza0VudW0gPSBuZXcgRW51bShbJ0RJU0NSRVRFJywgJ1BPT0xFRCcsICdCQUNLR1JPVU5EJ10sICdSVGFza1R5cGUnKTtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBjdXJyZW50bHkgc3VwcG9ydGVkIHNldCBvZiBgUlRhc2tgLlxuICpcbiAqIEBtb2R1bGUgcnRhc2stdHlwZVxuICogQGZvciByYnJva2VyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIERpc2NyZXRlIHRhc2suXG4gICAgICovXG4gICAgRElTQ1JFVEU6IHRhc2tFbnVtLkRJU0NSRVRFLFxuXG4gICAgLyoqXG4gICAgICogUG9vbGVkIHRhc2suXG4gICAgICovXG4gICAgUE9PTEVEOiB0YXNrRW51bS5QT09MRUQsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIHRhc2suXG4gICAgICovXG4gICAgQkFDS0dST1VORDogdGFza0VudW0uQkFDS0dST1VORFxufSk7IiwiLyohXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBieSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgdGVybXMgb2YgVmVyc2lvbiAyLjAgb2YgdGhlXG4gKiBBcGFjaGUgTGljZW5zZS4gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIFdJVEhPVVRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVFksIElOQ0xVRElORyBUSE9TRSBPRiBOT04tSU5GUklOR0VNRU5ULFxuICogTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBQbGVhc2UgcmVmZXIgdG8gdGhlXG4gKiBBcGFjaGUgTGljZW5zZSAyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCkgZm9yIG1vcmVcbiAqIGRldGFpbHMuXG4gKi9cblxudmFyIEJhc2UgICAgICA9IHJlcXVpcmUoJ3NlbGZpc2gnKS5CYXNlLFxuICAgIFJUYXNrVHlwZSA9IHJlcXVpcmUoJy4uL3J0YXNrLXR5cGUnKSxcbiAgICBSVGFzayAgICAgPSByZXF1aXJlKCcuL3J0YXNrJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoUlRhc2ssIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgIFJUYXNrLmluaXRpYWxpemUuY2FsbCh0aGlzLCBwcm9wcywgUlRhc2tUeXBlLkJBQ0tHUk9VTkQpO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnQmFja2dyb3VuZFRhc2s6ICcgKyBSVGFzay50b1N0cmluZy5jYWxsKHRoaXMpO1xuICAgIH1cbn0pOyIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlXG4gKiBkZXRhaWxzLlxuICovXG5cbnZhciBCYXNlICAgICAgPSByZXF1aXJlKCdzZWxmaXNoJykuQmFzZSxcbiAgICBSVGFza1R5cGUgPSByZXF1aXJlKCcuLi9ydGFzay10eXBlJyksXG4gICAgUlRhc2sgICAgID0gcmVxdWlyZSgnLi9ydGFzaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKFJUYXNrLCB7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICBSVGFzay5pbml0aWFsaXplLmNhbGwodGhpcywgcHJvcHMsIFJUYXNrVHlwZS5ESVNDUkVURSk7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdEaXNjcmV0ZVRhc2s6ICcgKyBSVGFzay50b1N0cmluZy5jYWxsKHRoaXMpO1xuICAgIH1cbn0pO1xuIiwiLyohXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBieSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgdGVybXMgb2YgVmVyc2lvbiAyLjAgb2YgdGhlXG4gKiBBcGFjaGUgTGljZW5zZS4gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIFdJVEhPVVRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVFksIElOQ0xVRElORyBUSE9TRSBPRiBOT04tSU5GUklOR0VNRU5ULFxuICogTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBQbGVhc2UgcmVmZXIgdG8gdGhlXG4gKiBBcGFjaGUgTGljZW5zZSAyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCkgZm9yIG1vcmVcbiAqIGRldGFpbHMuXG4gKi9cblxudmFyIEJhc2UgICAgICA9IHJlcXVpcmUoJ3NlbGZpc2gnKS5CYXNlLFxuICAgIFJUYXNrVHlwZSA9IHJlcXVpcmUoJy4uL3J0YXNrLXR5cGUnKSxcbiAgICBSVGFzayAgICAgPSByZXF1aXJlKCcuL3J0YXNrJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoUlRhc2ssIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgIFJUYXNrLmluaXRpYWxpemUuY2FsbCh0aGlzLCBwcm9wcywgUlRhc2tUeXBlLlBPT0xFRCk7XG4gICAgfSwgICAgICAgIFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ1Bvb2xlZFRhc2s6ICcgKyBSVGFzay50b1N0cmluZy5jYWxsKHRoaXMpO1xuICAgIH1cbn0pOyIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlXG4gKiBkZXRhaWxzLlxuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnc2VsZmlzaCcpLkJhc2U7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbnkgUiBBbmFseXRpY3MgdGFzayBmb3IgZXhlY3V0aW9uIG9uIGFuIGBSQnJva2VyYC5cbiAqXG4gKiBAbW9kdWxlIHJ0YXNrXG4gKiBAZm9yIHJicm9rZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBCYXNlLmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFueSBSIEFuYWx5dGljcyB0YXNrIGZvciBleGVjdXRpb24gb24gYW4gYFJCcm9rZXJgLlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICogQGNvbnN0cnVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBUaGUgdGFzayBwcm9wZXJ0aWVzIG9iamVjdCBoYXNoLlxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUocHJvcHMsIHR5cGUpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5wcm9wS2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9wcykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgaSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pKGkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgY29weSBvZiB0aGUgYFJUYXNrYCBwcm9wZXJ0aWVzIGFzIGEgZmxhdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIGNvcHkgb2YgdGhlIGBSVGFza2AgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IHRoaXMucHJvcEtleXMsIGwgPSBrZXlzLmxlbmd0aDsgbDsgLS1sKSB7XG4gICAgICAgICAgICBjbG9uZVtrZXlzW2wgLSAxXV0gPSB0aGlzW2tleXNbbCAtIDFdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3V0ID0gJycsXG4gICAgICAgICAgICBrZXlzID0gdGhpcy5wcm9wS2V5cztcblxuICAgICAgICBmb3IgKHZhciBvIGluIGtleXMpIHtcbiAgICAgICAgICAgIG91dCArPSAnIFsgJyArIGtleXNbb10gKyAnID0gXCInICsgdGhpc1trZXlzW29dXSArICdcIiBdJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBbIHRva2VuID0gXCInICsgdGhpcy50b2tlbiArICdcIiBdJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufSk7XG4iLCIvKiFcbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IGJ5IFJldm9sdXRpb24gQW5hbHl0aWNzIEluYy5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSB0ZXJtcyBvZiBWZXJzaW9uIDIuMCBvZiB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlLiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5UWSwgSU5DTFVESU5HIFRIT1NFIE9GIE5PTi1JTkZSSU5HRU1FTlQsXG4gKiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFBsZWFzZSByZWZlciB0byB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlIDIuMCAoaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wKSBmb3IgbW9yZSBcbiAqIGRldGFpbHMuXG4gKi9cbiBcbnZhciBCYXNlID0gcmVxdWlyZSgnc2VsZmlzaCcpLkJhc2U7XG5cbnZhciBSVGFza1F1ZXVlID0gQmFzZS5leHRlbmQoe1xuICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGNhcGFjaXR5KSB7XG4gICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICB0aGlzLnEgICAgICAgID0gW107XG4gICB9LCBcblxuICAgLyoqXG4gICAgKiBJbnNlcnRzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBhdCB0aGUgdGFpbCBvZiB0aGlzIHF1ZXVlIGlmIGl0IGlzIHBvc3NpYmxlIFxuICAgICogdG8gZG8gc28gaW1tZWRpYXRlbHkgd2l0aG91dCBleGNlZWRpbmcgdGhlIHF1ZXVlJ3MgY2FwYWNpdHksIHJldHVybmluZyBcbiAgICAqIGBgYHRydWVgYGAgdXBvbiBzdWNjZXNzIGFuZCBgYGBmYWxzZWBgYCBpZiB0aGlzIHF1ZXVlIGlzIGZ1bGwuXG4gICAgKi9cbiAgIG9mZmVyOiBmdW5jdGlvbiAocnRhc2spIHtcbiAgICAgIHZhciBhY2NlcHRpbmcgPSB0aGlzLnNpemUoKSA8IHRoaXMuY2FwYWNpdHk7XG5cbiAgICAgIGlmIChhY2NlcHRpbmcpIHsgICAgICAgIFxuICAgICAgICB0aGlzLnEucHVzaChydGFzayk7ICAgICAgXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2NlcHRpbmc7IC8vIFRydWUgaWYgYWRkZWQgRmFsc2Ugb3RoZXJ3aXNlXG4gICB9LFxuXG4gICAvKipcbiAgICAqIFJldHJpZXZlcyBhbmQgcmVtb3ZlcyB0aGUgaGVhZCBvZiB0aGlzIHF1ZXVlLlxuICAgICovXG4gICB0YWtlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucS5zaGlmdCgpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBSZXRyaWV2ZXMsIGJ1dCBkb2VzIG5vdCByZW1vdmUsIHRoZSBoZWFkIG9mIHRoaXMgcXVldWUsIG9yIHJldHVybnMgYFxuICAgICogYGBudWxsYGAgaWYgdGhpcyBxdWV1ZSBpcyBlbXB0eS5cbiAgICAqL1xuICAgcGVlazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnFbMF07XG4gICB9LFxuXG4gICAvKipcbiAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGlzIHF1ZXVlLlxuICAgICovXG4gICBzaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5xLmxlbmd0aDtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogUmV0dXJucyBgYGB0cnVlYGBgIGlmIHRoaXMgY29sbGVjdGlvbiBjb250YWlucyBubyBlbGVtZW50cy5cbiAgICAqIFRoaXMgaW1wbGVtZW50YXRpb24gcmV0dXJucyBzaXplKCkgPT09IDAuXG4gICAgKi9cbiAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcbiAgIH0sXG5cbiAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnEubGVuZ3RoID0gMDtcbiAgIH0sXG5cbiAgIGl0ZXI6IGZ1bmN0aW9uIChmbikge1xuICAgICAgdGhpcy5xLmZvckVhY2goZm4pO1xuICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUlRhc2tRdWV1ZTsiLCIvKiFcbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IGJ5IFJldm9sdXRpb24gQW5hbHl0aWNzIEluYy5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSB0ZXJtcyBvZiBWZXJzaW9uIDIuMCBvZiB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlLiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5UWSwgSU5DTFVESU5HIFRIT1NFIE9GIE5PTi1JTkZSSU5HRU1FTlQsXG4gKiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFBsZWFzZSByZWZlciB0byB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlIDIuMCAoaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wKSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqL1xuXG52YXIgQmFzZSAgICAgICAgICA9IHJlcXVpcmUoJ3NlbGZpc2gnKS5CYXNlLFxuICAgIGRlcGxveXIgICAgICAgPSByZXF1aXJlKCdkZXBsb3lyJyksXG4gICAgRCAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QuanMnKSwgICAgXG4gICAgUlRhc2tUeXBlICAgICA9IHJlcXVpcmUoJy4uL3J0YXNrLXR5cGUnKSxcbiAgICBSQnJva2VyV29ya2VyID0gcmVxdWlyZSgnLi9yYnJva2VyLXdvcmtlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJCcm9rZXJXb3JrZXIuZXh0ZW5kKHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICh0YXNrLCBydXNlcikge1xuICAgICAgICBSQnJva2VyV29ya2VyLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0YXNrKTtcbiAgICAgICAgdGhpcy5ydXNlciA9IHJ1c2VyO1xuICAgICAgICB0aGlzLmpvYiAgID0gbnVsbDtcbiAgICB9LFxuXG4gICAgd29yazogZnVuY3Rpb24ocmVzb3VyY2VUb2tlbikge1xuICAgICAgICB2YXIgc2VsZiAgICAgID0gdGhpcywgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgZGF0YSAgICAgID0gdGhpcy50YXNrLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgcmlucHV0cyAgID0gZGF0YS5yaW5wdXRzIHx8IFtdLFxuICAgICAgICAgICAgcm91dHB1dHMgID0gZGF0YS5yb3V0cHV0cyB8fCBbXTtcblxuICAgICAgICBkZWxldGUgZGF0YS5yaW5wdXRzO1xuICAgICAgICBkZWxldGUgZGF0YS5yb3V0cHV0cztcblxuICAgICAgICB0aGlzLnJlc291cmNlVG9rZW4gPSByZXNvdXJjZVRva2VuOyAgICAgICAgXG5cbiAgICAgICAgcmV0dXJuIGRlcGxveXIuaW8oJy9yL2pvYi9zdWJtaXQnKVxuICAgICAgICAgICAgLnNoYXJlKHRoaXMucnVzZXIuZ2V0Q29va2llcygpKVxuICAgICAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgICAgIC5nbG9iYWwoZmFsc2UpIC8vIHN1cHJlc3MgZ2xvYmFsIGVycm9yIGV2ZW50cyBmb3IgdGhpcyBgaW9gXG4gICAgICAgICAgICAucmlucHV0cyhyaW5wdXRzKVxuICAgICAgICAgICAgLnJvdXRwdXRzKHJvdXRwdXRzKVxuICAgICAgICAgICAgLnByb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFib3V0ID0gcmVzLmdldCgnam9iJyk7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmpvYiA9IGFib3V0LmpvYjsgLy8gam9iLWlkICAgICBcblxuICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgdGhlIHByb21pc2Ugd2hpY2gga2lja3Mtb2ZmIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2s6IHNlbGYudGFzayxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogYWJvdXQuam9iLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUlRhc2tUeXBlLkJBQ0tHUk9VTkQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lT25Db2RlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9uU2VydmVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9uQ2FsbDogKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24oaW50ZXJydXB0KSB7XG4gICAgICAgIGlmIChpbnRlcnJ1cHQgJiYgdGhpcy5qb2IpIHtcbiAgICAgICAgICB0aGlzLnJ1c2VyLmlvKCcvci9qb2IvY2FuY2VsJylcbiAgICAgICAgICAgIC5kYXRhKHsgam9iOiB0aGlzLmpvYiB9KVxuICAgICAgICAgICAgLmVuZCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBSVGFzayBzdGlsbCBwZW5kaW5nIGNvbmZpcm1hdGlvbiBmcm9tIFJCcm9rZXIgaWYgdGhlcmUgaXMgbm9cbiAgICAgICAgICAgIC8vIGByZXNvdXJjZVRva2VuYCBoZW5jZSBjYW4gbm90IGJlIGludGVycnVwdGVkIFtvcl0gdGhlIHRhc2sgaXNcbiAgICAgICAgICAgIC8vIGJlaW5nIHdvcmtlZCBvbiBhbmQgYSBmb3JjZWQgYGludGVycnVwdGAgd2FzIG5vdCBnaXZlblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiLyohXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBieSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgdGVybXMgb2YgVmVyc2lvbiAyLjAgb2YgdGhlXG4gKiBBcGFjaGUgTGljZW5zZS4gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIFdJVEhPVVRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVFksIElOQ0xVRElORyBUSE9TRSBPRiBOT04tSU5GUklOR0VNRU5ULFxuICogTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBQbGVhc2UgcmVmZXIgdG8gdGhlXG4gKiBBcGFjaGUgTGljZW5zZSAyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCkgZm9yIG1vcmVcbiAqIGRldGFpbHMuXG4gKi9cblxudmFyIEJhc2UgICAgICAgICAgPSByZXF1aXJlKCdzZWxmaXNoJykuQmFzZSxcbiAgICBkZXBsb3lyICAgICAgID0gcmVxdWlyZSgnZGVwbG95cicpLFxuICAgIEQgICAgICAgICAgICAgPSByZXF1aXJlKCdkLmpzJyksICAgIFxuICAgIFJUYXNrVHlwZSAgICAgPSByZXF1aXJlKCcuLi9ydGFzay10eXBlJyksXG4gICAgUkJyb2tlcldvcmtlciA9IHJlcXVpcmUoJy4vcmJyb2tlci13b3JrZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSQnJva2VyV29ya2VyLmV4dGVuZCh7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih0YXNrLCBydXNlcikge1xuICAgICAgICBSQnJva2VyV29ya2VyLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0YXNrKTtcbiAgICAgICAgdGhpcy5ydXNlciA9IHJ1c2VyO1xuICAgICAgICB0aGlzLmlvICAgID0gbnVsbDsgLy8gYGlvYCByZXF1ZXN0IGZvciAndGVybWluYXRpb24nIGlmIGNhbGxlZFxuICAgIH0sXG5cbiAgICB3b3JrOiBmdW5jdGlvbihyZXNvdXJjZVRva2VuKSB7XG4gICAgICAgIHZhciB0YXNrICAgICAgPSB0aGlzLnRhc2ssXG4gICAgICAgICAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGRhdGEgICAgICA9IHRoaXMudGFzay5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgIHJpbnB1dHMgICA9IGRhdGEucmlucHV0cyB8fCBbXSxcbiAgICAgICAgICAgIHJvdXRwdXRzICA9IGRhdGEucm91dHB1dHMgfHwgW107XG5cbiAgICAgICAgZGVsZXRlIGRhdGEucmlucHV0cztcbiAgICAgICAgZGVsZXRlIGRhdGEucm91dHB1dHM7XG5cbiAgICAgICAgdGhpcy5yZXNvdXJjZVRva2VuID0gcmVzb3VyY2VUb2tlbjtcblxuICAgICAgICAvLyBzYXZlIGBpb2AgcmVxdWVzdCBmb3IgJ3Rlcm1pbmF0aW9uJyBwdXJwb3Nlc1xuICAgICAgICB0aGlzLmlvID0gZGVwbG95ci5pbygnL3IvcmVwb3NpdG9yeS9zY3JpcHQvZXhlY3V0ZScpXG4gICAgICAgICAgICAvLyBtYWtlIHBhcmFsbGVsIGh0dHAgcmVxLiB1c2luZyB0aGUgc2FtZSBzZXNzaW9uXG4gICAgICAgICAgICAuc2hhcmUodGhpcy5ydXNlciA/IHRoaXMucnVzZXIuZ2V0Q29va2llcygpIDogbnVsbClcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgICAgICAucmlucHV0cyhyaW5wdXRzKVxuICAgICAgICAgICAgLnJvdXRwdXRzKHJvdXRwdXRzKSAgICAgICAgICAgIFxuICAgICAgICAgICAgLmdsb2JhbChmYWxzZSk7IC8vIHN1cHJlc3MgZ2xvYmFsIGVycm9yIGV2ZW50cyBmb3IgdGhpcyBgaW9gXG5cbiAgICAgICAgLy8gc2VuZCB0aGUgc2NyaXB0IGV4ZWN1dGlvbiByZXF1ZXN0IGFuZCByZXR1cm4gYSBwcm9taXNlXG4gICAgICAgIHJldHVybiB0aGlzLmlvLnByb21pc2UoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmRlcGxveXIucmVzcG9uc2U7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGltZU9uU2VydmVyICAgICA9IHJlcy5leGVjdXRpb24udGltZVRvdGFsLFxuICAgICAgICAgICAgICAgICAgICBpZCAgICAgICAgICAgICAgID0gcmVzLnByb2plY3QucHJvamVjdCxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkQ29uc29sZSA9IHJlcy5leGVjdXRpb24uY29uc29sZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkUGxvdHMgICA9IHJlcy5leGVjdXRpb24ucmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkRmlsZXMgICA9IHJlcy5leGVjdXRpb24uYXJ0aWZhY3RzLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRPYmplY3RzID0gcmVzLndvcmtzcGFjZS5vYmplY3RzLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZWRGaWxlcyAgICAgID0gcmVzLnJlcG9zaXRvcnkuZmlsZXM7XG5cbiAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHRoZSBwcm9taXNlIHdoaWNoIGtpY2tzLW9mZiB0aGUgY2FsbGJhY2sgdmFsdWVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSVGFza1R5cGUuRElTQ1JFVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9uQ29kZTogcmVzLmV4ZWN1dGlvbi50aW1lQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPblNlcnZlcjogdGltZU9uU2VydmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9uQ2FsbDogKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnJ1cHRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRDb25zb2xlOiBnZW5lcmF0ZWRDb25zb2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkUGxvdHM6IGdlbmVyYXRlZFBsb3RzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkRmlsZXM6IGdlbmVyYXRlZEZpbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkT2JqZWN0czogZ2VuZXJhdGVkT2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZEZpbGVzOiBzdG9yZWRGaWxlc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0ZXJtaW5hdGU6IGZ1bmN0aW9uKGludGVycnVwdCkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBATk9URTpcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIG9idGFpbiBEZXBsb3lSIHJlZmVyZW5jZSwgc3VjaCBhcyBhIHByb2plY3RJZCwgZm9yXG4gICAgICAgIC8vIGFuIHN0YXRlbGVzcyBleGVjdXRpb24gaW4tcHJvZ3Jlc3MsIHNvIGFib3J0aW5nIHRoZSBjdXJyZW50IFJUYXNrIFxuICAgICAgICAvLyBvcGVyYXRpb24gaXMgbm90IHBvc3NpYmxlLiBBdCBiZXN0IHdlIGNhbiBkbyBoZXJlIGlzIGZyZWUtdXAgdGhlIFxuICAgICAgICAvLyBjbGllbnQgY29ubmVjdGlvbiBhbmQgYWJvcnQuXG4gICAgICAgIC8vICAgICAgICBcbiAgICAgICAgaWYgKGludGVycnVwdCAmJiB0aGlzLmlvICYmIHRoaXMuaXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW8uYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuaW8uZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbyA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFJUYXNrIHN0aWxsIHBlbmRpbmcgY29uZmlybWF0aW9uIGZyb20gUkJyb2tlciBpZiB0aGVyZSBpcyBub1xuICAgICAgICAgICAgLy8gYHJlc291cmNlVG9rZW5gIGhlbmNlIGNhbiBub3QgYmUgaW50ZXJydXB0ZWQgW29yXSB0aGUgdGFzayBpc1xuICAgICAgICAgICAgLy8gYmVpbmcgd29ya2VkIG9uIGFuZCBhIGZvcmNlZCBgaW50ZXJydXB0YCB3YXMgbm90IGdpdmVuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIvKiFcbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IGJ5IFJldm9sdXRpb24gQW5hbHl0aWNzIEluYy5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSB0ZXJtcyBvZiBWZXJzaW9uIDIuMCBvZiB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlLiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5UWSwgSU5DTFVESU5HIFRIT1NFIE9GIE5PTi1JTkZSSU5HRU1FTlQsXG4gKiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFBsZWFzZSByZWZlciB0byB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlIDIuMCAoaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wKSBmb3IgbW9yZSBcbiAqIGRldGFpbHMuXG4gKi9cblxudmFyIEJhc2UgICAgICAgICAgPSByZXF1aXJlKCdzZWxmaXNoJykuQmFzZSxcbiAgICBEICAgICAgICAgICAgID0gcmVxdWlyZSgnZC5qcycpLFxuICAgIG1lcmdlICAgICAgICAgPSByZXF1aXJlKCdtZXJnZScpLFxuICAgIGRlcGxveXIgICAgICAgPSByZXF1aXJlKCdkZXBsb3lyJyksXG4gICAgUlRhc2tUeXBlICAgICA9IHJlcXVpcmUoJy4uL3J0YXNrLXR5cGUnKSxcbiAgICBSQnJva2VyV29ya2VyID0gcmVxdWlyZSgnLi9yYnJva2VyLXdvcmtlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJCcm9rZXJXb3JrZXIuZXh0ZW5kKHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICh0YXNrLCBydXNlcikge1xuICAgICAgICBSQnJva2VyV29ya2VyLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0YXNrKTtcbiAgICAgICAgdGhpcy5ydXNlciA9IHJ1c2VyO1xuICAgIH0sXG5cbiAgICB3b3JrOiBmdW5jdGlvbihyZXNvdXJjZVRva2VuKSB7XG4gICAgICAgIHZhciB0YXNrID0gdGhpcy50YXNrLCBcbiAgICAgICAgICAgIGRhdGEgPSBtZXJnZSh7XG4gICAgICAgICAgICAgICAgcHJvamVjdDogcmVzb3VyY2VUb2tlbixcbiAgICAgICAgICAgICAgICBwaGFudG9tOiB0cnVlXG4gICAgICAgICAgICB9LCB0aGlzLnRhc2suc2VyaWFsaXplKCkpLFxuICAgICAgICAgICAgYXBpICAgICAgID0gJy9yL3Byb2plY3QvZXhlY3V0ZS8nICsgKGRhdGEuY29kZSA/ICdjb2RlJyA6ICdzY3JpcHQnKSxcbiAgICAgICAgICAgIHJpbnB1dHMgICA9IGRhdGEucmlucHV0cyB8fCBbXSxcbiAgICAgICAgICAgIHJvdXRwdXRzICA9IGRhdGEucm91dHB1dHMgfHwgW10sXG4gICAgICAgICAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICBkZWxldGUgZGF0YS5yaW5wdXRzO1xuICAgICAgICBkZWxldGUgZGF0YS5yb3V0cHV0cztcblxuICAgICAgICB0aGlzLnJlc291cmNlVG9rZW4gPSByZXNvdXJjZVRva2VuO1xuXG4gICAgICAgIHJldHVybiBkZXBsb3lyLmlvKGFwaSlcbiAgICAgICAgICAgIC5zaGFyZSh0aGlzLnJ1c2VyLmdldENvb2tpZXMoKSlcbiAgICAgICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgICAgICAucmlucHV0cyhyaW5wdXRzKVxuICAgICAgICAgICAgLnJvdXRwdXRzKHJvdXRwdXRzKVxuICAgICAgICAgICAgLmdsb2JhbChmYWxzZSkgLy8gc3VwcmVzcyBnbG9iYWwgZXJyb3IgZXZlbnRzIGZvciB0aGlzIGBpb2AgICAgICAgICAgICBcbiAgICAgICAgICAgIC5wcm9taXNlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5kZXBsb3lyLnJlc3BvbnNlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGdlbmVyYXRlZENvbnNvbGUgPSByZXMuZXhlY3V0aW9uLmNvbnNvbGUsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZFBsb3RzICAgPSByZXMuZXhlY3V0aW9uLnJlc3VsdHMsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEZpbGVzICAgPSByZXMuZXhlY3V0aW9uLmFydGlmYWN0cyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkT2JqZWN0cyA9IHJlcy53b3Jrc3BhY2Uub2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkRmlsZXMgICAgICA9IHJlcy5yZXBvc2l0b3J5LmZpbGVzO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHRoZSBwcm9taXNlIHdoaWNoIGtpY2tzLW9mZiB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiByZXMucHJvamVjdC5wcm9qZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUlRhc2tUeXBlLlBPT0xFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lT25Db2RlOiByZXMuZXhlY3V0aW9uLnRpbWVDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU9uU2VydmVyOiByZXMuZXhlY3V0aW9uLnRpbWVUb3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPbkNhbGw6IChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJydXB0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkQ29uc29sZTogZ2VuZXJhdGVkQ29uc29sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZFBsb3RzOiBnZW5lcmF0ZWRQbG90cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEZpbGVzOiBnZW5lcmF0ZWRGaWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZE9iamVjdHM6IGdlbmVyYXRlZE9iamVjdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRGaWxlczogc3RvcmVkRmlsZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgIH0sXG5cbiAgICB0ZXJtaW5hdGU6IGZ1bmN0aW9uKGludGVycnVwdCkge1xuICAgICAgICAvLyB3b3JrIGhhcyBzdGFydGVkIGFuZCBhIGZvcmNlZCBpbnRlcnJ1cHQgZ2l2ZW5cbiAgICAgICAgaWYgKGludGVycnVwdCAmJiB0aGlzLnJlc291cmNlVG9rZW4gJiYgdGhpcy5pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5ydXNlci5pbygnL3IvcHJvamVjdC9leGVjdXRlL2ludGVycnVwdCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoeyBwcm9qZWN0OiB0aGlzLnJlc291cmNlVG9rZW4gfSlcbiAgICAgICAgICAgICAgICAuZW5kKCk7ICBcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBSVGFzayBzdGlsbCBwZW5kaW5nIGNvbmZpcm1hdGlvbiBmcm9tIFJCcm9rZXIgaWYgdGhlcmUgaXMgbm9cbiAgICAgICAgICAgIC8vIGByZXNvdXJjZVRva2VuYCBoZW5jZSBjYW4gbm90IGJlIGludGVycnVwdGVkIFtvcl0gdGhlIHRhc2sgaXNcbiAgICAgICAgICAgIC8vIGJlaW5nIHdvcmtlZCBvbiBhbmQgYSBmb3JjZWQgYGludGVycnVwdGAgd2FzIG5vdCBnaXZlblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG4iLCIvKiFcbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IGJ5IFJldm9sdXRpb24gQW5hbHl0aWNzIEluYy5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSB0ZXJtcyBvZiBWZXJzaW9uIDIuMCBvZiB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlLiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5UWSwgSU5DTFVESU5HIFRIT1NFIE9GIE5PTi1JTkZSSU5HRU1FTlQsXG4gKiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFBsZWFzZSByZWZlciB0byB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlIDIuMCAoaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wKSBmb3IgbW9yZSBcbiAqIGRldGFpbHMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCdzZWxmaXNoJykuQmFzZSxcbiAgICBEICAgID0gcmVxdWlyZSgnZC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKHRhc2spIHtcbiAgICAgICAgdGhpcy50YXNrICA9IHRhc2s7XG4gICAgICAgIHRoaXMuZGVmZXIgPSBEKCk7XG4gICAgfSxcblxuICAgIHdvcms6IGZ1bmN0aW9uKHJlc291cmNlVG9rZW4pIHsgLyogb3ZlcnJpZGUgKi8gfSxcblxuICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24oaW50ZXJydXB0KSB7IC8qIG92ZXJyaWRlICovIH0sXG5cbiAgICBpc1BlbmRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZlci5wcm9taXNlLmlzUGVuZGluZygpO1xuICAgIH0sXG5cbiAgICByZXNvbHZlOiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5kZWZlci5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfSxcblxuICAgIHJlamVjdDogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHRoaXMuZGVmZXIucmVqZWN0KGVycik7XG4gICAgfVxufSk7XG4iLG51bGwsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4qIGF0dGVtcHQgb2YgYSBzaW1wbGUgZGVmZXIvcHJvbWlzZSBsaWJyYXJ5IGZvciBtb2JpbGUgZGV2ZWxvcG1lbnRcbiogQGF1dGhvciBKb25hdGhhbiBHb3R0aSA8IGpnb3R0aSBhdCBqZ290dGkgZG90IG5ldD5cbiogQHNpbmNlIDIwMTItMTBcbiogQHZlcnNpb24gMC42LjBcbiogQGNoYW5nZWxvZ1xuKiAgICAgICAgICAgLSAyMDEzLTEyLTA3IC0gbGFzdCBwcm9taXNlIDEuMSBzcGVjcyB0ZXN0IHBhc3NpbmdzICh0aHggdG8gd2l6YXJkd2VyZG5hKVxuICogICAgICAgICAgICAgICAgICAgICAgIC0gcmVkdWNlIHByb21pc2VzIGZvb3RwcmludCBieSB1bnNjb3BpbmcgbWV0aG9kcyB0aGF0IGNvdWxkIGJlXG4qICAgICAgICAgICAtIDIwMTMtMTAtMjMgLSBtYWtlIGl0IHdvcmtpZyBhY3Jvc3Mgbm9kZS13ZWJraXQgY29udGV4dHNcbiogICAgICAgICAgIC0gMjAxMy0wNy0wMyAtIGJ1ZyBjb3JyZWN0aW9uIGluIHByb21peGlmeSBtZXRob2QgKHRoeCB0byBhZHJpZW4gZ2licmF0IClcbiogICAgICAgICAgIC0gMjAxMy0wNi0yMiAtIGJ1ZyBjb3JyZWN0aW9uIGluIG5vZGVDYXBzdWxlIG1ldGhvZFxuKiAgICAgICAgICAgLSAyMDEzLTA2LTE3IC0gcmVtb3ZlIHVubmVjZXNzYXJ5IEFycmF5LmluZGV4T2YgbWV0aG9kIGRlcGVuZGVuY3lcbiogICAgICAgICAgIC0gMjAxMy0wNC0xOCAtIGFkZCB0cnkvY2F0Y2ggYmxvY2sgYXJvdW5kIG5vZGVDYXBzdWxlZCBtZXRob2RzXG4qICAgICAgICAgICAtIDIwMTMtMDQtMTMgLSBjaGVjayBwcm9taXNlcy9BKyBjb25mb3JtaXR5XG4qICAgICAgICAgICAgICAgICAgICAgICAgLSBtYWtlIHNvbWUgbWluaWNhdGlvbiBvcHRpbWlzYXRpb25zXG4qICAgICAgICAgICAtIDIwMTMtMDMtMjYgLSBhZGQgcmVzb2x2ZWQsIGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgbWV0aG9kc1xuKiAgICAgICAgICAgLSAyMDEzLTAzLTIxIC0gYnJvd3Nlci9ub2RlIGNvbXBhdGlibGVcbiogICAgICAgICAgICAgICAgICAgICAgICAtIG5ldyBtZXRob2Qgbm9kZUNhcHN1bGVcbiogICAgICAgICAgICAgICAgICAgICAgICAtIHNpbXBsZXIgcHJvbWl4aWZ5IHdpdGggZnVsbCBhcGkgc3VwcG9ydFxuKiAgICAgICAgICAgLSAyMDEzLTAxLTI1IC0gYWRkIHJldGhyb3cgbWV0aG9kXG4qICAgICAgICAgICAgICAgICAgICAgICAgLSBuZXh0VGljayBvcHRpbWlzYXRpb24gLT4gYWRkIHN1cHBvcnQgZm9yIHByb2Nlc3MubmV4dFRpY2sgKyBNZXNzYWdlQ2hhbm5lbCB3aGVyZSBhdmFpbGFibGVcbiogICAgICAgICAgIC0gMjAxMi0xMi0yOCAtIGFkZCBhcHBseSBtZXRob2QgdG8gcHJvbWlzZVxuKiAgICAgICAgICAgLSAyMDEyLTEyLTIwIC0gYWRkIGFsd2F5c0FzeW5jIHBhcmFtZXRlcnMgYW5kIHByb3BlcnR5IGZvciBkZWZhdWx0IHNldHRpbmdcbiovXG4oZnVuY3Rpb24odW5kZWYpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgbmV4dFRpY2tcblx0XHQsIGlzRnVuYyA9IGZ1bmN0aW9uKGYpeyByZXR1cm4gKCB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJyApOyB9XG5cdFx0LCBpc0FycmF5ID0gZnVuY3Rpb24oYSl7IHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShhKSA6IChhIGluc3RhbmNlb2YgQXJyYXkpOyB9XG5cdFx0LCBpc09iak9yRnVuYyA9IGZ1bmN0aW9uKG8peyByZXR1cm4gISEobyAmJiAodHlwZW9mIG8pLm1hdGNoKC9mdW5jdGlvbnxvYmplY3QvKSk7IH1cblx0XHQsIGlzTm90VmFsID0gZnVuY3Rpb24odil7IHJldHVybiAodiA9PT0gZmFsc2UgfHwgdiA9PT0gdW5kZWYgfHwgdiA9PT0gbnVsbCk7IH1cblx0XHQsIHNsaWNlID0gZnVuY3Rpb24oYSwgb2Zmc2V0KXsgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYSwgb2Zmc2V0KTsgfVxuXHRcdCwgdW5kZWZTdHIgPSAndW5kZWZpbmVkJ1xuXHRcdCwgdEVyciA9IHR5cGVvZiBUeXBlRXJyb3IgPT09IHVuZGVmU3RyID8gRXJyb3IgOiBUeXBlRXJyb3Jcblx0O1xuXHRpZiAoICh0eXBlb2YgcHJvY2VzcyAhPT0gdW5kZWZTdHIpICYmIHByb2Nlc3MubmV4dFRpY2sgKSB7XG5cdFx0bmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09IHVuZGVmU3RyICkge1xuXHRcdHZhciBudGlja0NoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSwgcXVldWUgPSBbXTtcblx0XHRudGlja0NoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oKXsgcXVldWUubGVuZ3RoICYmIChxdWV1ZS5zaGlmdCgpKSgpOyB9O1xuXHRcdG5leHRUaWNrID0gZnVuY3Rpb24oY2Ipe1xuXHRcdFx0cXVldWUucHVzaChjYik7XG5cdFx0XHRudGlja0NoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRuZXh0VGljayA9IGZ1bmN0aW9uKGNiKXsgc2V0VGltZW91dChjYiwgMCk7IH07XG5cdH1cblx0ZnVuY3Rpb24gcmV0aHJvdyhlKXsgbmV4dFRpY2soZnVuY3Rpb24oKXsgdGhyb3cgZTt9KTsgfVxuXG5cdC8qKlxuXHQgKiBAdHlwZWRlZiBkZWZlcnJlZFxuXHQgKiBAcHJvcGVydHkge3Byb21pc2V9IHByb21pc2Vcblx0ICogQG1ldGhvZCByZXNvbHZlXG5cdCAqIEBtZXRob2QgZnVsZmlsbFxuXHQgKiBAbWV0aG9kIHJlamVjdFxuXHQgKi9cblxuXHQvKipcblx0ICogQHR5cGVkZWYge2Z1bmN0aW9ufSBmdWxmaWxsZWRcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBwcm9taXNlIHJlc29sdmVkIHZhbHVlXG5cdCAqIEByZXR1cm5zIHsqfSBuZXh0IHByb21pc2UgcmVzb2x1dGlvbiB2YWx1ZVxuXHQgKi9cblxuXHQvKipcblx0ICogQHR5cGVkZWYge2Z1bmN0aW9ufSBmYWlsZWRcblx0ICogQHBhcmFtIHsqfSByZWFzb24gcHJvbWlzZSByZWplY3Rpb24gcmVhc29uXG5cdCAqIEByZXR1cm5zIHsqfSBuZXh0IHByb21pc2UgcmVzb2x1dGlvbiB2YWx1ZSBvciByZXRocm93IHRoZSByZWFzb25cblx0ICovXG5cblx0Ly8tLSBkZWZpbmluZyB1bmVuY2xvc2VkIHByb21pc2UgbWV0aG9kcyAtLS8vXG5cdC8qKlxuXHQgKiBzYW1lIGFzIHRoZW4gd2l0aG91dCBmYWlsZWQgY2FsbGJhY2tcblx0ICogQHBhcmFtIHtmdWxmaWxsZWR9IGZ1bGZpbGxlZCBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gYSBuZXcgcHJvbWlzZVxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvbWlzZV9zdWNjZXNzKGZ1bGZpbGxlZCl7IHJldHVybiB0aGlzLnRoZW4oZnVsZmlsbGVkLCB1bmRlZik7IH1cblxuXHQvKipcblx0ICogc2FtZSBhcyB0aGVuIHdpdGggb25seSBhIGZhaWxlZCBjYWxsYmFja1xuXHQgKiBAcGFyYW0ge2ZhaWxlZH0gZmFpbGVkIGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfSBhIG5ldyBwcm9taXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9taXNlX2Vycm9yKGZhaWxlZCl7IHJldHVybiB0aGlzLnRoZW4odW5kZWYsIGZhaWxlZCk7IH1cblxuXG5cdC8qKlxuXHQgKiBzYW1lIGFzIHRoZW4gYnV0IGZ1bGZpbGxlZCBjYWxsYmFjayB3aWxsIHJlY2VpdmUgbXVsdGlwbGUgcGFyYW1ldGVycyB3aGVuIHByb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYW4gQXJyYXlcblx0ICogQHBhcmFtIHtmdWxmaWxsZWR9IGZ1bGZpbGxlZCBjYWxsYmFja1xuXHQgKiBAcGFyYW0ge2ZhaWxlZH0gZmFpbGVkIGNhbGxiYWNrXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfSBhIG5ldyBwcm9taXNlXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9taXNlX2FwcGx5KGZ1bGZpbGxlZCwgZmFpbGVkKXtcblx0XHRyZXR1cm4gdGhpcy50aGVuKFxuXHRcdFx0ZnVuY3Rpb24oYSl7XG5cdFx0XHRcdHJldHVybiBpc0Z1bmMoZnVsZmlsbGVkKSA/IGZ1bGZpbGxlZC5hcHBseShudWxsLCBpc0FycmF5KGEpID8gYSA6IFthXSkgOiAoZGVmZXIub25seUZ1bmNzID8gYSA6IGZ1bGZpbGxlZCk7XG5cdFx0XHR9XG5cdFx0XHQsIGZhaWxlZCB8fCB1bmRlZlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogY2xlYW51cCBtZXRob2Qgd2hpY2ggd2lsbCBiZSBhbHdheXMgZXhlY3V0ZWQgcmVnYXJkbGVzcyBmdWxmaWxsbWVudCBvciByZWplY3Rpb25cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgYSBjYWxsYmFjayBjYWxsZWQgcmVnYXJkbGVzcyBvZiB0aGUgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIG9mIHRoZSBwcm9taXNlIHdoaWNoIHdpbGwgYmUgY2FsbGVkXG5cdCAqICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHByb21pc2UgaXMgbm90IHBlbmRpbmcgYW55bW9yZVxuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gdGhlIHNhbWUgcHJvbWlzZSB1bnRvdWNoZWRcblx0ICovXG5cdGZ1bmN0aW9uIHByb21pc2VfZW5zdXJlKGNiKXtcblx0XHRmdW5jdGlvbiBfY2IoKXsgY2IoKTsgfVxuXHRcdHRoaXMudGhlbihfY2IsIF9jYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogdGFrZSBhIHNpbmdsZSBjYWxsYmFjayB3aGljaCB3YWl0IGZvciBhbiBlcnJvciBhcyBmaXJzdCBwYXJhbWV0ZXIuIG90aGVyIHJlc29sdXRpb24gdmFsdWVzIGFyZSBwYXNzZWQgYXMgd2l0aCB0aGUgYXBwbHkvc3ByZWFkIG1ldGhvZFxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBhIGNhbGxiYWNrIGNhbGxlZCByZWdhcmRsZXNzIG9mIHRoZSBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gb2YgdGhlIHByb21pc2Ugd2hpY2ggd2lsbCBiZSBjYWxsZWRcblx0ICogICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgcHJvbWlzZSBpcyBub3QgcGVuZGluZyBhbnltb3JlIHdpdGggZXJyb3IgYXMgZmlyc3QgcGFyYW1ldGVyIGlmIGFueSBhcyBpbiBub2RlIHN0eWxlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLiBSZXN0IG9mIHBhcmFtZXRlcnMgd2lsbCBiZSBhcHBsaWVkIGFzIHdpdGggdGhlIGFwcGx5IG1ldGhvZC5cblx0ICogQHJldHVybnMge3Byb21pc2V9IGEgbmV3IHByb21pc2Vcblx0ICovXG5cdGZ1bmN0aW9uIHByb21pc2Vfbm9kaWZ5KGNiKXtcblx0XHRyZXR1cm4gdGhpcy50aGVuKFxuXHRcdFx0ZnVuY3Rpb24oYSl7XG5cdFx0XHRcdHJldHVybiBpc0Z1bmMoY2IpID8gY2IuYXBwbHkobnVsbCwgaXNBcnJheShhKSA/IGEuc3BsaWNlKDAsMCx1bmRlZmluZWQpICYmIGEgOiBbdW5kZWZpbmVkLGFdKSA6IChkZWZlci5vbmx5RnVuY3MgPyBhIDogY2IpO1xuXHRcdFx0fVxuXHRcdFx0LCBmdW5jdGlvbihlKXtcblx0XHRcdFx0cmV0dXJuIGNiKGUpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZhaWxlZF0gd2l0aG91dCBwYXJhbWV0ZXIgd2lsbCBvbmx5IHJldGhyb3cgcHJvbWlzZSByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgb2YgdGhlIHByb21pc2UgbGlicmFyeSBvbiBuZXh0IHRpY2tcblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcGFzc2VkIGEgZmFpbGVkIG1ldGhvZCB0aGVuIHdpbGwgY2FsbCBmYWlsZWQgb24gcmVqZWN0aW9uIGFuZCB0aHJvdyB0aGUgZXJyb3IgYWdhaW4gaWYgZmFpbGVkIGRpZG4ndFxuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gYSBuZXcgcHJvbWlzZVxuXHQgKi9cblx0ZnVuY3Rpb24gcHJvbWlzZV9yZXRocm93KGZhaWxlZCl7XG5cdFx0cmV0dXJuIHRoaXMudGhlbihcblx0XHRcdHVuZGVmXG5cdFx0XHQsIGZhaWxlZCA/IGZ1bmN0aW9uKGUpeyBmYWlsZWQoZSk7IHRocm93IGU7IH0gOiByZXRocm93XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQqIEBwYXJhbSB7Ym9vbGVhbn0gW2Fsd2F5c0FzeW5jXSBpZiBzZXQgZm9yY2UgdGhlIGFzeW5jIHJlc29sdXRpb24gZm9yIHRoaXMgcHJvbWlzZSBpbmRlcGVuZGFudGx5IG9mIHRoZSBELmFsd2F5c0FzeW5jIG9wdGlvblxuXHQqIEByZXR1cm5zIHtkZWZlcnJlZH0gZGVmZXJlZCBvYmplY3Qgd2l0aCBwcm9wZXJ0eSAncHJvbWlzZScgYW5kIG1ldGhvZHMgcmVqZWN0LGZ1bGZpbGwscmVzb2x2ZSAoZnVsZmlsbCBiZWluZyBhbiBhbGlhcyBmb3IgcmVzb2x2ZSlcblx0Ki9cblx0dmFyIGRlZmVyID0gZnVuY3Rpb24gKGFsd2F5c0FzeW5jKXtcblx0XHR2YXIgYWx3YXlzQXN5bmNGbiA9ICh1bmRlZiAhPT0gYWx3YXlzQXN5bmMgPyBhbHdheXNBc3luYyA6IGRlZmVyLmFsd2F5c0FzeW5jKSA/IG5leHRUaWNrIDogZnVuY3Rpb24oZm4pe2ZuKCk7fVxuXHRcdFx0LCBzdGF0dXMgPSAwIC8vIC0xIGZhaWxlZCB8IDEgZnVsZmlsbGVkXG5cdFx0XHQsIHBlbmRpbmdzID0gW11cblx0XHRcdCwgdmFsdWVcblx0XHRcdC8qKlxuXHRcdFx0ICogQHR5cGVkZWYgcHJvbWlzZVxuXHRcdFx0ICovXG5cdFx0XHQsIF9wcm9taXNlICA9IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEBwYXJhbSB7ZnVsZmlsbGVkfGZ1bmN0aW9ufSBmdWxmaWxsZWQgY2FsbGJhY2tcblx0XHRcdFx0ICogQHBhcmFtIHtmYWlsZWR8ZnVuY3Rpb259IGZhaWxlZCBjYWxsYmFja1xuXHRcdFx0XHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gYSBuZXcgcHJvbWlzZVxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oZnVsZmlsbGVkLCBmYWlsZWQpe1xuXHRcdFx0XHRcdHZhciBkID0gZGVmZXIoKTtcblx0XHRcdFx0XHRwZW5kaW5ncy5wdXNoKFtcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKHZhbHVlKXtcblx0XHRcdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0XHRcdGlmKCBpc05vdFZhbChmdWxmaWxsZWQpKXtcblx0XHRcdFx0XHRcdFx0XHRcdGQucmVzb2x2ZSh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGQucmVzb2x2ZShpc0Z1bmMoZnVsZmlsbGVkKSA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiAoZGVmZXIub25seUZ1bmNzID8gdmFsdWUgOiBmdWxmaWxsZWQpKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1jYXRjaChlKXtcblx0XHRcdFx0XHRcdFx0XHRkLnJlamVjdChlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0LCBmdW5jdGlvbihlcnIpe1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzTm90VmFsKGZhaWxlZCkgfHwgKCghaXNGdW5jKGZhaWxlZCkpICYmIGRlZmVyLm9ubHlGdW5jcykgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZC5yZWplY3QoZXJyKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIGZhaWxlZCApIHtcblx0XHRcdFx0XHRcdFx0XHR0cnl7IGQucmVzb2x2ZShpc0Z1bmMoZmFpbGVkKSA/IGZhaWxlZChlcnIpIDogZmFpbGVkKTsgfWNhdGNoKGUpeyBkLnJlamVjdChlKTt9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0XHRzdGF0dXMgIT09IDAgJiYgYWx3YXlzQXN5bmNGbihleGVjQ2FsbGJhY2tzKTtcblx0XHRcdFx0XHRyZXR1cm4gZC5wcm9taXNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LCBzdWNjZXNzOiBwcm9taXNlX3N1Y2Nlc3NcblxuXHRcdFx0XHQsIGVycm9yOiBwcm9taXNlX2Vycm9yXG5cdFx0XHRcdCwgb3RoZXJ3aXNlOiBwcm9taXNlX2Vycm9yXG5cblx0XHRcdFx0LCBhcHBseTogcHJvbWlzZV9hcHBseVxuXHRcdFx0XHQsIHNwcmVhZDogcHJvbWlzZV9hcHBseVxuXG5cdFx0XHRcdCwgZW5zdXJlOiBwcm9taXNlX2Vuc3VyZVxuXG5cdFx0XHRcdCwgbm9kaWZ5OiBwcm9taXNlX25vZGlmeVxuXG5cdFx0XHRcdCwgcmV0aHJvdzogcHJvbWlzZV9yZXRocm93XG5cblx0XHRcdFx0LCBpc1BlbmRpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAhIShzdGF0dXMgPT09IDApOyB9XG5cblx0XHRcdFx0LCBnZXRTdGF0dXM6IGZ1bmN0aW9uKCl7IHJldHVybiBzdGF0dXM7IH1cblx0XHRcdH1cblx0XHQ7XG5cdFx0X3Byb21pc2UudG9Tb3VyY2UgPSBfcHJvbWlzZS50b1N0cmluZyA9IF9wcm9taXNlLnZhbHVlT2YgPSBmdW5jdGlvbigpe3JldHVybiB2YWx1ZSA9PT0gdW5kZWYgPyB0aGlzIDogdmFsdWU7IH07XG5cblxuXHRcdGZ1bmN0aW9uIGV4ZWNDYWxsYmFja3MoKXtcblx0XHRcdGlmICggc3RhdHVzID09PSAwICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2JzID0gcGVuZGluZ3MsIGkgPSAwLCBsID0gY2JzLmxlbmd0aCwgY2JJbmRleCA9IH5zdGF0dXMgPyAwIDogMSwgY2I7XG5cdFx0XHRwZW5kaW5ncyA9IFtdO1xuXHRcdFx0Zm9yKCA7IGkgPCBsOyBpKysgKXtcblx0XHRcdFx0KGNiID0gY2JzW2ldW2NiSW5kZXhdKSAmJiBjYih2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogZnVsZmlsbCBkZWZlcnJlZCB3aXRoIGdpdmVuIHZhbHVlXG5cdFx0ICogQHBhcmFtIHsqfSB2YWxcblx0XHQgKiBAcmV0dXJucyB7ZGVmZXJyZWR9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIF9yZXNvbHZlKHZhbCl7XG5cdFx0XHR2YXIgZG9uZSA9IGZhbHNlO1xuXHRcdFx0ZnVuY3Rpb24gb25jZShmKXtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHgpe1xuXHRcdFx0XHRcdGlmIChkb25lKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBmKHgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggc3RhdHVzICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB0aGVuID0gaXNPYmpPckZ1bmModmFsKSAmJiB2YWwudGhlbjtcblx0XHRcdFx0aWYgKCBpc0Z1bmModGhlbikgKSB7IC8vIG1hbmFnaW5nIGEgcHJvbWlzZVxuXHRcdFx0XHRcdGlmKCB2YWwgPT09IF9wcm9taXNlICl7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgdEVycihcIlByb21pc2UgY2FuJ3QgcmVzb2x2ZSBpdHNlbGZcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoZW4uY2FsbCh2YWwsIG9uY2UoX3Jlc29sdmUpLCBvbmNlKF9yZWplY3QpKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRvbmNlKF9yZWplY3QpKGUpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGFsd2F5c0FzeW5jRm4oZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFsdWUgPSB2YWw7XG5cdFx0XHRcdHN0YXR1cyA9IDE7XG5cdFx0XHRcdGV4ZWNDYWxsYmFja3MoKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogcmVqZWN0IGRlZmVycmVkIHdpdGggZ2l2ZW4gcmVhc29uXG5cdFx0ICogQHBhcmFtIHsqfSBFcnJcblx0XHQgKiBAcmV0dXJucyB7ZGVmZXJyZWR9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIF9yZWplY3QoRXJyKXtcblx0XHRcdHN0YXR1cyB8fCBhbHdheXNBc3luY0ZuKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHRyeXsgdGhyb3coRXJyKTsgfWNhdGNoKGUpeyB2YWx1ZSA9IGU7IH1cblx0XHRcdFx0c3RhdHVzID0gLTE7XG5cdFx0XHRcdGV4ZWNDYWxsYmFja3MoKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHJldHVybiAvKipAdHlwZSBkZWZlcnJlZCAqLyB7XG5cdFx0XHRwcm9taXNlOl9wcm9taXNlXG5cdFx0XHQscmVzb2x2ZTpfcmVzb2x2ZVxuXHRcdFx0LGZ1bGZpbGw6X3Jlc29sdmUgLy8gYWxpYXNcblx0XHRcdCxyZWplY3Q6X3JlamVjdFxuXHRcdH07XG5cdH07XG5cblx0ZGVmZXIuZGVmZXJyZWQgPSBkZWZlci5kZWZlciA9IGRlZmVyO1xuXHRkZWZlci5uZXh0VGljayA9IG5leHRUaWNrO1xuXHRkZWZlci5hbHdheXNBc3luYyA9IHRydWU7IC8vIHNldHRpbmcgdGhpcyB3aWxsIGNoYW5nZSBkZWZhdWx0IGJlaGF2aW91ci4gdXNlIGl0IG9ubHkgaWYgbmVjZXNzYXJ5IGFzIGFzeW5jaHJvbmljaXR5IHdpbGwgZm9yY2Ugc29tZSBkZWxheSBiZXR3ZWVuIHlvdXIgcHJvbWlzZSByZXNvbHV0aW9ucyBhbmQgaXMgbm90IGFsd2F5cyB3aGF0IHlvdSB3YW50LlxuXHQvKipcblx0KiBzZXR0aW5nIG9ubHlGdW5jcyB0byBmYWxzZSB3aWxsIGJyZWFrIHByb21pc2VzL0ErIGNvbmZvcm1pdHkgYnkgYWxsb3dpbmcgeW91IHRvIHBhc3Mgbm9uIHVuZGVmaW5lZC9udWxsIHZhbHVlcyBpbnN0ZWFkIG9mIGNhbGxiYWNrc1xuXHQqIGluc3RlYWQgb2YganVzdCBpZ25vcmluZyBhbnkgbm9uIGZ1bmN0aW9uIHBhcmFtZXRlcnMgdG8gdGhlbixzdWNjZXNzLGVycm9yLi4uIGl0IHdpbGwgYWNjZXB0IG5vbiBudWxsfHVuZGVmaW5lZCB2YWx1ZXMuXG5cdCogdGhpcyB3aWxsIGFsbG93IHlvdSBzaG9ydGN1dHMgbGlrZSBwcm9taXNlLnRoZW4oJ3ZhbCcsJ2hhbmRsZWQgZXJyb3InJylcblx0KiB0byBiZSBlcXVpdmFsZW50IG9mIHByb21pc2UudGhlbihmdW5jdGlvbigpeyByZXR1cm4gJ3ZhbCc7fSxmdW5jdGlvbigpeyByZXR1cm4gJ2hhbmRsZWQgZXJyb3InfSlcblx0Ki9cblx0ZGVmZXIub25seUZ1bmNzID0gdHJ1ZTtcblxuXHQvKipcblx0ICogcmV0dXJuIGEgZnVsZmlsbGVkIHByb21pc2Ugb2YgZ2l2ZW4gdmFsdWUgKGFsd2F5cyBhc3luYyByZXNvbHV0aW9uKVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfVxuXHQgKi9cblx0ZGVmZXIucmVzb2x2ZWQgPSBkZWZlci5mdWxmaWxsZWQgPSBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiBkZWZlcih0cnVlKS5yZXNvbHZlKHZhbHVlKS5wcm9taXNlOyB9O1xuXG5cdC8qKlxuXHQgKiByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIHdpdGggZ2l2ZW4gcmVhc29uIG9mIHJlamVjdGlvbiAoYWx3YXlzIGFzeW5jIHJlamVjdGlvbilcblx0ICogQHBhcmFtIHsqfSByZWFzb25cblx0ICogQHJldHVybnMge3Byb21pc2V9XG5cdCAqL1xuXHRkZWZlci5yZWplY3RlZCA9IGZ1bmN0aW9uKHJlYXNvbil7IHJldHVybiBkZWZlcih0cnVlKS5yZWplY3QocmVhc29uKS5wcm9taXNlOyB9O1xuXG5cdC8qKlxuXHQgKiByZXR1cm4gYSBwcm9taXNlIHdpdGggbm8gcmVzb2x1dGlvbiB2YWx1ZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGluIHRpbWUgbXMgKHVzaW5nIHNldFRpbWVvdXQpXG5cdCAqIEBwYXJhbSB7aW50fSBbdGltZV0gaW4gbXMgZGVmYXVsdCB0byAwXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfVxuXHQgKi9cblx0ZGVmZXIud2FpdCA9IGZ1bmN0aW9uKHRpbWUpe1xuXHRcdHZhciBkID0gZGVmZXIoKTtcblx0XHRzZXRUaW1lb3V0KGQucmVzb2x2ZSwgdGltZSB8fCAwKTtcblx0XHRyZXR1cm4gZC5wcm9taXNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiByZXR1cm4gYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIGZ1bmN0aW9uIGNhbGwgd2hpY2ggd2lsbCBiZSBmdWxmaWxsZWQgaW4gZGVsYXkgbXMgb3IgcmVqZWN0ZWQgaWYgZ2l2ZW4gZm4gdGhyb3cgYW4gZXJyb3Jcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cblx0ICogQHBhcmFtIHtpbnR9IFtkZWxheV0gaW4gbXMgZGVmYXVsdCB0byAwXG5cdCAqIEByZXR1cm5zIHtwcm9taXNlfVxuXHQgKi9cblx0ZGVmZXIuZGVsYXkgPSBmdW5jdGlvbihmbiwgZGVsYXkpe1xuXHRcdHZhciBkID0gZGVmZXIoKTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHRyeXsgZC5yZXNvbHZlKGZuLmFwcGx5KG51bGwpKTsgfWNhdGNoKGUpeyBkLnJlamVjdChlKTsgfSB9LCBkZWxheSB8fCAwKTtcblx0XHRyZXR1cm4gZC5wcm9taXNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBpZiBnaXZlbiB2YWx1ZSBpcyBub3QgYSBwcm9taXNlIHJldHVybiBhIGZ1bGZpbGxlZCBwcm9taXNlIHJlc29sdmVkIHRvIGdpdmVuIHZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0gcHJvbWlzZSBhIHZhbHVlIG9yIGEgcHJvbWlzZVxuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX1cblx0ICovXG5cdGRlZmVyLnByb21pc2lmeSA9IGZ1bmN0aW9uKHByb21pc2Upe1xuXHRcdGlmICggcHJvbWlzZSAmJiBpc0Z1bmMocHJvbWlzZS50aGVuKSApIHsgcmV0dXJuIHByb21pc2U7fVxuXHRcdHJldHVybiBkZWZlci5yZXNvbHZlZChwcm9taXNlKTtcblx0fTtcblxuXHRmdW5jdGlvbiBtdWx0aVByb21pc2VSZXNvbHZlcihjYWxsZXJBcmd1bWVudHMsIHJldHVyblByb21pc2VzKXtcblx0XHR2YXIgcHJvbWlzZXMgPSBzbGljZShjYWxsZXJBcmd1bWVudHMpO1xuXHRcdGlmICggcHJvbWlzZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkocHJvbWlzZXNbMF0pICkge1xuXHRcdFx0aWYoISBwcm9taXNlc1swXS5sZW5ndGggKXtcblx0XHRcdFx0cmV0dXJuIGRlZmVyLmZ1bGZpbGxlZChbXSk7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlcyA9IHByb21pc2VzWzBdO1xuXHRcdH1cblx0XHR2YXIgYXJncyA9IFtdXG5cdFx0XHQsIGQgPSBkZWZlcigpXG5cdFx0XHQsIGMgPSBwcm9taXNlcy5sZW5ndGhcblx0XHQ7XG5cdFx0aWYgKCAhYyApIHtcblx0XHRcdGQucmVzb2x2ZShhcmdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHJlc29sdmVyID0gZnVuY3Rpb24oaSl7XG5cdFx0XHRcdHByb21pc2VzW2ldID0gZGVmZXIucHJvbWlzaWZ5KHByb21pc2VzW2ldKTtcblx0XHRcdFx0cHJvbWlzZXNbaV0udGhlbihcblx0XHRcdFx0XHRmdW5jdGlvbih2KXtcblx0XHRcdFx0XHRcdGlmICghIChpIGluIGFyZ3MpICkgeyAvL0B0b2RvIGNoZWNrIHRoaXMgaXMgc3RpbGwgcmVxdWlyZWQgYXMgcHJvbWlzZXMgY2FuJ3QgYmUgcmVzb2x2ZSBtb3JlIHRoYW4gb25jZVxuXHRcdFx0XHRcdFx0XHRhcmdzW2ldID0gcmV0dXJuUHJvbWlzZXMgPyBwcm9taXNlc1tpXSA6IHY7XG5cdFx0XHRcdFx0XHRcdCgtLWMpIHx8IGQucmVzb2x2ZShhcmdzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0LCBmdW5jdGlvbihlKXtcblx0XHRcdFx0XHRcdGlmKCEgKGkgaW4gYXJncykgKXtcblx0XHRcdFx0XHRcdFx0aWYoICEgcmV0dXJuUHJvbWlzZXMgKXtcblx0XHRcdFx0XHRcdFx0XHRkLnJlamVjdChlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRhcmdzW2ldID0gcHJvbWlzZXNbaV07XG5cdFx0XHRcdFx0XHRcdFx0KC0tYykgfHwgZC5yZXNvbHZlKGFyZ3MpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fTtcblx0XHRcdGZvciggdmFyIGkgPSAwLCBsID0gYzsgaSA8IGw7IGkrKyApe1xuXHRcdFx0XHRyZXNvbHZlcihpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGQucHJvbWlzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiByZXR1cm4gYSBwcm9taXNlIGZvciBhbGwgZ2l2ZW4gcHJvbWlzZXMgLyB2YWx1ZXMuXG5cdCAqIHRoZSByZXR1cm5lZCBwcm9taXNlcyB3aWxsIGJlIGZ1bGZpbGxlZCB3aXRoIGEgbGlzdCBvZiByZXNvbHZlZCB2YWx1ZS5cblx0ICogaWYgYW55IGdpdmVuIHByb21pc2UgaXMgcmVqZWN0ZWQgdGhlbiBvbiB0aGUgZmlyc3QgcmVqZWN0aW9uIHRoZSByZXR1cm5lZCBwcm9taXNlZCB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWUgcmVhc29uXG5cdCAqIEBwYXJhbSB7YXJyYXl8Li4uKn0gW3Byb21pc2VdIGNhbiBiZSBhIHNpbmdsZSBhcnJheSBvZiBwcm9taXNlL3ZhbHVlcyBhcyBmaXJzdCBwYXJhbWV0ZXIgb3IgYSBsaXN0IG9mIGRpcmVjdCBwYXJhbWV0ZXJzIHByb21pc2UvdmFsdWVcblx0ICogQHJldHVybnMge3Byb21pc2V9IG9mIGEgbGlzdCBvZiBnaXZlbiBwcm9taXNlIHJlc29sdXRpb24gdmFsdWVcblx0ICovXG5cdGRlZmVyLmFsbCA9IGZ1bmN0aW9uKCl7IHJldHVybiBtdWx0aVByb21pc2VSZXNvbHZlcihhcmd1bWVudHMsZmFsc2UpOyB9O1xuXG5cdC8qKlxuXHQgKiByZXR1cm4gYW4gYWx3YXlzIGZ1bGZpbGxlZCBwcm9taXNlIG9mIGFycmF5PHByb21pc2U+IGxpc3Qgb2YgcHJvbWlzZXMvdmFsdWVzIHJlZ2FyZGxlc3MgdGhleSByZXNvbHZlIGZ1bGZpbGxlZCBvciByZWplY3RlZFxuXHQgKiBAcGFyYW0ge2FycmF5fC4uLip9IFtwcm9taXNlXSBjYW4gYmUgYSBzaW5nbGUgYXJyYXkgb2YgcHJvbWlzZS92YWx1ZXMgYXMgZmlyc3QgcGFyYW1ldGVyIG9yIGEgbGlzdCBvZiBkaXJlY3QgcGFyYW1ldGVycyBwcm9taXNlL3ZhbHVlXG5cdCAqICAgICAgICAgICAgICAgICAgICAgKG5vbiBwcm9taXNlIHZhbHVlcyB3aWxsIGJlIHByb21pc2lmaWVkKVxuXHQgKiBAcmV0dXJucyB7cHJvbWlzZX0gb2YgdGhlIGxpc3Qgb2YgZ2l2ZW4gcHJvbWlzZXNcblx0ICovXG5cdGRlZmVyLnJlc29sdmVBbGwgPSBmdW5jdGlvbigpeyByZXR1cm4gbXVsdGlQcm9taXNlUmVzb2x2ZXIoYXJndW1lbnRzLHRydWUpOyB9O1xuXG5cdC8qKlxuXHQgKiB0cmFuc2Zvcm0gYSB0eXBpY2FsIG5vZGVqcyBhc3luYyBtZXRob2QgYXdhaXRpbmcgYSBjYWxsYmFjayBhcyBsYXN0IHBhcmFtZXRlciwgcmVjZWl2aW5nIGVycm9yIGFzIGZpcnN0IHBhcmFtZXRlciB0byBhIGZ1bmN0aW9uIHRoYXRcblx0ICogd2lsbCByZXR1cm4gYSBwcm9taXNlIGluc3RlYWQuIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIG5vcm1hbCBjYWxsYmFjayB2YWx1ZSBtaW51cyB0aGUgZmlyc3QgZXJyb3IgcGFyYW1ldGVyIG9uXG5cdCAqIGZ1bGZpbGwgYW5kIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGF0IGVycm9yIGFzIHJlYXNvbiBpbiBjYXNlIG9mIGVycm9yLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3N1YmplY3RdIG9wdGlvbmFsIHN1YmplY3Qgb2YgdGhlIG1ldGhvZCB0byBlbmNhcHN1bGF0ZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiB0aGUgZnVuY3Rpb24gdG8gZW5jYXBzdWxhdGUgaWYgdGhlIG5vcm1hbCBjYWxsYmFjayBzaG91bGQgcmVjZWl2ZSBtb3JlIHRoYW4gYSBzaW5nbGUgcGFyYW1ldGVyIChtaW51cyB0aGUgZXJyb3IpXG5cdCAqICAgICAgICAgICAgICAgICAgICAgIHRoZSBwcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBsaXN0IG9yIHBhcmFtZXRlcnMgYXMgZnVsZmlsbG1lbnQgdmFsdWUuIElmIG9ubHkgb25lIHBhcmFtZXRlciBpcyBzZW50IHRvIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayB0aGVuIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgcmVzb2x1dGlvbiB2YWx1ZS5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxuXHQgKi9cblx0ZGVmZXIubm9kZUNhcHN1bGUgPSBmdW5jdGlvbihzdWJqZWN0LCBmbil7XG5cdFx0aWYgKCAhZm4gKSB7XG5cdFx0XHRmbiA9IHN1YmplY3Q7XG5cdFx0XHRzdWJqZWN0ID0gdm9pZCgwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgZCA9IGRlZmVyKCksIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpO1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uKGVyciwgcmVzKXtcblx0XHRcdFx0ZXJyID8gZC5yZWplY3QoZXJyKSA6IGQucmVzb2x2ZShhcmd1bWVudHMubGVuZ3RoID4gMiA/IHNsaWNlKGFyZ3VtZW50cywgMSkgOiByZXMpO1xuXHRcdFx0fSk7XG5cdFx0XHR0cnl7XG5cdFx0XHRcdGZuLmFwcGx5KHN1YmplY3QsIGFyZ3MpO1xuXHRcdFx0fWNhdGNoKGUpe1xuXHRcdFx0XHRkLnJlamVjdChlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkLnByb21pc2U7XG5cdFx0fTtcblx0fTtcblxuXHR0eXBlb2Ygd2luZG93ICE9PSB1bmRlZlN0ciAmJiAod2luZG93LkQgPSBkZWZlcik7XG5cdHR5cGVvZiBtb2R1bGUgIT09IHVuZGVmU3RyICYmIG1vZHVsZS5leHBvcnRzICYmIChtb2R1bGUuZXhwb3J0cyA9IGRlZmVyKTtcblxufSkoKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5a0xtcHpMMnhwWWk5RUxtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRU0lzSW1acGJHVWlPaUpuWlc1bGNtRjBaV1F1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaUx5b3FYRzRxSUdGMGRHVnRjSFFnYjJZZ1lTQnphVzF3YkdVZ1pHVm1aWEl2Y0hKdmJXbHpaU0JzYVdKeVlYSjVJR1p2Y2lCdGIySnBiR1VnWkdWMlpXeHZjRzFsYm5SY2Jpb2dRR0YxZEdodmNpQktiMjVoZEdoaGJpQkhiM1IwYVNBOElHcG5iM1IwYVNCaGRDQnFaMjkwZEdrZ1pHOTBJRzVsZEQ1Y2Jpb2dRSE5wYm1ObElESXdNVEl0TVRCY2Jpb2dRSFpsY25OcGIyNGdNQzQyTGpCY2Jpb2dRR05vWVc1blpXeHZaMXh1S2lBZ0lDQWdJQ0FnSUNBZ0xTQXlNREV6TFRFeUxUQTNJQzBnYkdGemRDQndjbTl0YVhObElERXVNU0J6Y0dWamN5QjBaWE4wSUhCaGMzTnBibWR6SUNoMGFIZ2dkRzhnZDJsNllYSmtkMlZ5Wkc1aEtWeHVJQ29nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDMGdjbVZrZFdObElIQnliMjFwYzJWeklHWnZiM1J3Y21sdWRDQmllU0IxYm5OamIzQnBibWNnYldWMGFHOWtjeUIwYUdGMElHTnZkV3hrSUdKbFhHNHFJQ0FnSUNBZ0lDQWdJQ0F0SURJd01UTXRNVEF0TWpNZ0xTQnRZV3RsSUdsMElIZHZjbXRwWnlCaFkzSnZjM01nYm05a1pTMTNaV0pyYVhRZ1kyOXVkR1Y0ZEhOY2Jpb2dJQ0FnSUNBZ0lDQWdJQzBnTWpBeE15MHdOeTB3TXlBdElHSjFaeUJqYjNKeVpXTjBhVzl1SUdsdUlIQnliMjFwZUdsbWVTQnRaWFJvYjJRZ0tIUm9lQ0IwYnlCaFpISnBaVzRnWjJsaWNtRjBJQ2xjYmlvZ0lDQWdJQ0FnSUNBZ0lDMGdNakF4TXkwd05pMHlNaUF0SUdKMVp5QmpiM0p5WldOMGFXOXVJR2x1SUc1dlpHVkRZWEJ6ZFd4bElHMWxkR2h2WkZ4dUtpQWdJQ0FnSUNBZ0lDQWdMU0F5TURFekxUQTJMVEUzSUMwZ2NtVnRiM1psSUhWdWJtVmpaWE56WVhKNUlFRnljbUY1TG1sdVpHVjRUMllnYldWMGFHOWtJR1JsY0dWdVpHVnVZM2xjYmlvZ0lDQWdJQ0FnSUNBZ0lDMGdNakF4TXkwd05DMHhPQ0F0SUdGa1pDQjBjbmt2WTJGMFkyZ2dZbXh2WTJzZ1lYSnZkVzVrSUc1dlpHVkRZWEJ6ZFd4bFpDQnRaWFJvYjJSelhHNHFJQ0FnSUNBZ0lDQWdJQ0F0SURJd01UTXRNRFF0TVRNZ0xTQmphR1ZqYXlCd2NtOXRhWE5sY3k5Qkt5QmpiMjVtYjNKdGFYUjVYRzRxSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdMU0J0WVd0bElITnZiV1VnYldsdWFXTmhkR2x2YmlCdmNIUnBiV2x6WVhScGIyNXpYRzRxSUNBZ0lDQWdJQ0FnSUNBdElESXdNVE10TURNdE1qWWdMU0JoWkdRZ2NtVnpiMngyWldRc0lHWjFiR1pwYkd4bFpDQmhibVFnY21WcVpXTjBaV1FnYldWMGFHOWtjMXh1S2lBZ0lDQWdJQ0FnSUNBZ0xTQXlNREV6TFRBekxUSXhJQzBnWW5KdmQzTmxjaTl1YjJSbElHTnZiWEJoZEdsaWJHVmNiaW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQXRJRzVsZHlCdFpYUm9iMlFnYm05a1pVTmhjSE4xYkdWY2Jpb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdElITnBiWEJzWlhJZ2NISnZiV2w0YVdaNUlIZHBkR2dnWm5Wc2JDQmhjR2tnYzNWd2NHOXlkRnh1S2lBZ0lDQWdJQ0FnSUNBZ0xTQXlNREV6TFRBeExUSTFJQzBnWVdSa0lISmxkR2h5YjNjZ2JXVjBhRzlrWEc0cUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnTFNCdVpYaDBWR2xqYXlCdmNIUnBiV2x6WVhScGIyNGdMVDRnWVdSa0lITjFjSEJ2Y25RZ1ptOXlJSEJ5YjJObGMzTXVibVY0ZEZScFkyc2dLeUJOWlhOellXZGxRMmhoYm01bGJDQjNhR1Z5WlNCaGRtRnBiR0ZpYkdWY2Jpb2dJQ0FnSUNBZ0lDQWdJQzBnTWpBeE1pMHhNaTB5T0NBdElHRmtaQ0JoY0hCc2VTQnRaWFJvYjJRZ2RHOGdjSEp2YldselpWeHVLaUFnSUNBZ0lDQWdJQ0FnTFNBeU1ERXlMVEV5TFRJd0lDMGdZV1JrSUdGc2QyRjVjMEZ6ZVc1aklIQmhjbUZ0WlhSbGNuTWdZVzVrSUhCeWIzQmxjblI1SUdadmNpQmtaV1poZFd4MElITmxkSFJwYm1kY2Jpb3ZYRzRvWm5WdVkzUnBiMjRvZFc1a1pXWXBlMXh1WEhSY0luVnpaU0J6ZEhKcFkzUmNJanRjYmx4dVhIUjJZWElnYm1WNGRGUnBZMnRjYmx4MFhIUXNJR2x6Um5WdVl5QTlJR1oxYm1OMGFXOXVLR1lwZXlCeVpYUjFjbTRnS0NCMGVYQmxiMllnWmlBOVBUMGdKMloxYm1OMGFXOXVKeUFwT3lCOVhHNWNkRngwTENCcGMwRnljbUY1SUQwZ1puVnVZM1JwYjI0b1lTbDdJSEpsZEhWeWJpQkJjbkpoZVM1cGMwRnljbUY1SUQ4Z1FYSnlZWGt1YVhOQmNuSmhlU2hoS1NBNklDaGhJR2x1YzNSaGJtTmxiMllnUVhKeVlYa3BPeUI5WEc1Y2RGeDBMQ0JwYzA5aWFrOXlSblZ1WXlBOUlHWjFibU4wYVc5dUtHOHBleUJ5WlhSMWNtNGdJU0VvYnlBbUppQW9kSGx3Wlc5bUlHOHBMbTFoZEdOb0tDOW1kVzVqZEdsdmJueHZZbXBsWTNRdktTazdJSDFjYmx4MFhIUXNJR2x6VG05MFZtRnNJRDBnWm5WdVkzUnBiMjRvZGlsN0lISmxkSFZ5YmlBb2RpQTlQVDBnWm1Gc2MyVWdmSHdnZGlBOVBUMGdkVzVrWldZZ2ZId2dkaUE5UFQwZ2JuVnNiQ2s3SUgxY2JseDBYSFFzSUhOc2FXTmxJRDBnWm5WdVkzUnBiMjRvWVN3Z2IyWm1jMlYwS1hzZ2NtVjBkWEp1SUZ0ZExuTnNhV05sTG1OaGJHd29ZU3dnYjJabWMyVjBLVHNnZlZ4dVhIUmNkQ3dnZFc1a1pXWlRkSElnUFNBbmRXNWtaV1pwYm1Wa0oxeHVYSFJjZEN3Z2RFVnljaUE5SUhSNWNHVnZaaUJVZVhCbFJYSnliM0lnUFQwOUlIVnVaR1ZtVTNSeUlEOGdSWEp5YjNJZ09pQlVlWEJsUlhKeWIzSmNibHgwTzF4dVhIUnBaaUFvSUNoMGVYQmxiMllnY0hKdlkyVnpjeUFoUFQwZ2RXNWtaV1pUZEhJcElDWW1JSEJ5YjJObGMzTXVibVY0ZEZScFkyc2dLU0I3WEc1Y2RGeDBibVY0ZEZScFkyc2dQU0J3Y205alpYTnpMbTVsZUhSVWFXTnJPMXh1WEhSOUlHVnNjMlVnYVdZZ0tDQjBlWEJsYjJZZ1RXVnpjMkZuWlVOb1lXNXVaV3dnSVQwOUlIVnVaR1ZtVTNSeUlDa2dlMXh1WEhSY2RIWmhjaUJ1ZEdsamEwTm9ZVzV1Wld3Z1BTQnVaWGNnVFdWemMyRm5aVU5vWVc1dVpXd29LU3dnY1hWbGRXVWdQU0JiWFR0Y2JseDBYSFJ1ZEdsamEwTm9ZVzV1Wld3dWNHOXlkREV1YjI1dFpYTnpZV2RsSUQwZ1puVnVZM1JwYjI0b0tYc2djWFZsZFdVdWJHVnVaM1JvSUNZbUlDaHhkV1YxWlM1emFHbG1kQ2dwS1NncE95QjlPMXh1WEhSY2RHNWxlSFJVYVdOcklEMGdablZ1WTNScGIyNG9ZMklwZTF4dVhIUmNkRngwY1hWbGRXVXVjSFZ6YUNoallpazdYRzVjZEZ4MFhIUnVkR2xqYTBOb1lXNXVaV3d1Y0c5eWRESXVjRzl6ZEUxbGMzTmhaMlVvTUNrN1hHNWNkRngwZlR0Y2JseDBmU0JsYkhObElIdGNibHgwWEhSdVpYaDBWR2xqYXlBOUlHWjFibU4wYVc5dUtHTmlLWHNnYzJWMFZHbHRaVzkxZENoallpd2dNQ2s3SUgwN1hHNWNkSDFjYmx4MFpuVnVZM1JwYjI0Z2NtVjBhSEp2ZHlobEtYc2dibVY0ZEZScFkyc29ablZ1WTNScGIyNG9LWHNnZEdoeWIzY2daVHQ5S1RzZ2ZWeHVYRzVjZEM4cUtseHVYSFFnS2lCQWRIbHdaV1JsWmlCa1pXWmxjbkpsWkZ4dVhIUWdLaUJBY0hKdmNHVnlkSGtnZTNCeWIyMXBjMlY5SUhCeWIyMXBjMlZjYmx4MElDb2dRRzFsZEdodlpDQnlaWE52YkhabFhHNWNkQ0FxSUVCdFpYUm9iMlFnWm5Wc1ptbHNiRnh1WEhRZ0tpQkFiV1YwYUc5a0lISmxhbVZqZEZ4dVhIUWdLaTljYmx4dVhIUXZLaXBjYmx4MElDb2dRSFI1Y0dWa1pXWWdlMloxYm1OMGFXOXVmU0JtZFd4bWFXeHNaV1JjYmx4MElDb2dRSEJoY21GdElIc3FmU0IyWVd4MVpTQndjbTl0YVhObElISmxjMjlzZG1Wa0lIWmhiSFZsWEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHNxZlNCdVpYaDBJSEJ5YjIxcGMyVWdjbVZ6YjJ4MWRHbHZiaUIyWVd4MVpWeHVYSFFnS2k5Y2JseHVYSFF2S2lwY2JseDBJQ29nUUhSNWNHVmtaV1lnZTJaMWJtTjBhVzl1ZlNCbVlXbHNaV1JjYmx4MElDb2dRSEJoY21GdElIc3FmU0J5WldGemIyNGdjSEp2YldselpTQnlaV3BsWTNScGIyNGdjbVZoYzI5dVhHNWNkQ0FxSUVCeVpYUjFjbTV6SUhzcWZTQnVaWGgwSUhCeWIyMXBjMlVnY21WemIyeDFkR2x2YmlCMllXeDFaU0J2Y2lCeVpYUm9jbTkzSUhSb1pTQnlaV0Z6YjI1Y2JseDBJQ292WEc1Y2JseDBMeTh0TFNCa1pXWnBibWx1WnlCMWJtVnVZMnh2YzJWa0lIQnliMjFwYzJVZ2JXVjBhRzlrY3lBdExTOHZYRzVjZEM4cUtseHVYSFFnS2lCellXMWxJR0Z6SUhSb1pXNGdkMmwwYUc5MWRDQm1ZV2xzWldRZ1kyRnNiR0poWTJ0Y2JseDBJQ29nUUhCaGNtRnRJSHRtZFd4bWFXeHNaV1I5SUdaMWJHWnBiR3hsWkNCallXeHNZbUZqYTF4dVhIUWdLaUJBY21WMGRYSnVjeUI3Y0hKdmJXbHpaWDBnWVNCdVpYY2djSEp2YldselpWeHVYSFFnS2k5Y2JseDBablZ1WTNScGIyNGdjSEp2YldselpWOXpkV05qWlhOektHWjFiR1pwYkd4bFpDbDdJSEpsZEhWeWJpQjBhR2x6TG5Sb1pXNG9ablZzWm1sc2JHVmtMQ0IxYm1SbFppazdJSDFjYmx4dVhIUXZLaXBjYmx4MElDb2djMkZ0WlNCaGN5QjBhR1Z1SUhkcGRHZ2diMjVzZVNCaElHWmhhV3hsWkNCallXeHNZbUZqYTF4dVhIUWdLaUJBY0dGeVlXMGdlMlpoYVd4bFpIMGdabUZwYkdWa0lHTmhiR3hpWVdOclhHNWNkQ0FxSUVCeVpYUjFjbTV6SUh0d2NtOXRhWE5sZlNCaElHNWxkeUJ3Y205dGFYTmxYRzVjZENBcUwxeHVYSFJtZFc1amRHbHZiaUJ3Y205dGFYTmxYMlZ5Y205eUtHWmhhV3hsWkNsN0lISmxkSFZ5YmlCMGFHbHpMblJvWlc0b2RXNWtaV1lzSUdaaGFXeGxaQ2s3SUgxY2JseHVYRzVjZEM4cUtseHVYSFFnS2lCellXMWxJR0Z6SUhSb1pXNGdZblYwSUdaMWJHWnBiR3hsWkNCallXeHNZbUZqYXlCM2FXeHNJSEpsWTJWcGRtVWdiWFZzZEdsd2JHVWdjR0Z5WVcxbGRHVnljeUIzYUdWdUlIQnliMjFwYzJVZ2FYTWdablZzWm1sc2JHVmtJSGRwZEdnZ1lXNGdRWEp5WVhsY2JseDBJQ29nUUhCaGNtRnRJSHRtZFd4bWFXeHNaV1I5SUdaMWJHWnBiR3hsWkNCallXeHNZbUZqYTF4dVhIUWdLaUJBY0dGeVlXMGdlMlpoYVd4bFpIMGdabUZwYkdWa0lHTmhiR3hpWVdOclhHNWNkQ0FxSUVCeVpYUjFjbTV6SUh0d2NtOXRhWE5sZlNCaElHNWxkeUJ3Y205dGFYTmxYRzVjZENBcUwxeHVYSFJtZFc1amRHbHZiaUJ3Y205dGFYTmxYMkZ3Y0d4NUtHWjFiR1pwYkd4bFpDd2dabUZwYkdWa0tYdGNibHgwWEhSeVpYUjFjbTRnZEdocGN5NTBhR1Z1S0Z4dVhIUmNkRngwWm5WdVkzUnBiMjRvWVNsN1hHNWNkRngwWEhSY2RISmxkSFZ5YmlCcGMwWjFibU1vWm5Wc1ptbHNiR1ZrS1NBL0lHWjFiR1pwYkd4bFpDNWhjSEJzZVNodWRXeHNMQ0JwYzBGeWNtRjVLR0VwSUQ4Z1lTQTZJRnRoWFNrZ09pQW9aR1ZtWlhJdWIyNXNlVVoxYm1OeklEOGdZU0E2SUdaMWJHWnBiR3hsWkNrN1hHNWNkRngwWEhSOVhHNWNkRngwWEhRc0lHWmhhV3hsWkNCOGZDQjFibVJsWmx4dVhIUmNkQ2s3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNvZ1kyeGxZVzUxY0NCdFpYUm9iMlFnZDJocFkyZ2dkMmxzYkNCaVpTQmhiSGRoZVhNZ1pYaGxZM1YwWldRZ2NtVm5ZWEprYkdWemN5Qm1kV3htYVd4c2JXVnVkQ0J2Y2lCeVpXcGxZM1JwYjI1Y2JseDBJQ29nUUhCaGNtRnRJSHRtZFc1amRHbHZibjBnWTJJZ1lTQmpZV3hzWW1GamF5QmpZV3hzWldRZ2NtVm5ZWEprYkdWemN5QnZaaUIwYUdVZ1puVnNabWxzYkcxbGJuUWdiM0lnY21WcVpXTjBhVzl1SUc5bUlIUm9aU0J3Y205dGFYTmxJSGRvYVdOb0lIZHBiR3dnWW1VZ1kyRnNiR1ZrWEc1Y2RDQXFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhkb1pXNGdkR2hsSUhCeWIyMXBjMlVnYVhNZ2JtOTBJSEJsYm1ScGJtY2dZVzU1Ylc5eVpWeHVYSFFnS2lCQWNtVjBkWEp1Y3lCN2NISnZiV2x6WlgwZ2RHaGxJSE5oYldVZ2NISnZiV2x6WlNCMWJuUnZkV05vWldSY2JseDBJQ292WEc1Y2RHWjFibU4wYVc5dUlIQnliMjFwYzJWZlpXNXpkWEpsS0dOaUtYdGNibHgwWEhSbWRXNWpkR2x2YmlCZlkySW9LWHNnWTJJb0tUc2dmVnh1WEhSY2RIUm9hWE11ZEdobGJpaGZZMklzSUY5allpazdYRzVjZEZ4MGNtVjBkWEp1SUhSb2FYTTdYRzVjZEgxY2JseHVYSFF2S2lwY2JseDBJQ29nZEdGclpTQmhJSE5wYm1kc1pTQmpZV3hzWW1GamF5QjNhR2xqYUNCM1lXbDBJR1p2Y2lCaGJpQmxjbkp2Y2lCaGN5Qm1hWEp6ZENCd1lYSmhiV1YwWlhJdUlHOTBhR1Z5SUhKbGMyOXNkWFJwYjI0Z2RtRnNkV1Z6SUdGeVpTQndZWE56WldRZ1lYTWdkMmwwYUNCMGFHVWdZWEJ3YkhrdmMzQnlaV0ZrSUcxbGRHaHZaRnh1WEhRZ0tpQkFjR0Z5WVcwZ2UyWjFibU4wYVc5dWZTQmpZaUJoSUdOaGJHeGlZV05ySUdOaGJHeGxaQ0J5WldkaGNtUnNaWE56SUc5bUlIUm9aU0JtZFd4bWFXeHNiV1Z1ZENCdmNpQnlaV3BsWTNScGIyNGdiMllnZEdobElIQnliMjFwYzJVZ2QyaHBZMmdnZDJsc2JDQmlaU0JqWVd4c1pXUmNibHgwSUNvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkMmhsYmlCMGFHVWdjSEp2YldselpTQnBjeUJ1YjNRZ2NHVnVaR2x1WnlCaGJubHRiM0psSUhkcGRHZ2daWEp5YjNJZ1lYTWdabWx5YzNRZ2NHRnlZVzFsZEdWeUlHbG1JR0Z1ZVNCaGN5QnBiaUJ1YjJSbElITjBlV3hsWEc1Y2RDQXFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUdOaGJHeGlZV05yTGlCU1pYTjBJRzltSUhCaGNtRnRaWFJsY25NZ2QybHNiQ0JpWlNCaGNIQnNhV1ZrSUdGeklIZHBkR2dnZEdobElHRndjR3g1SUcxbGRHaHZaQzVjYmx4MElDb2dRSEpsZEhWeWJuTWdlM0J5YjIxcGMyVjlJR0VnYm1WM0lIQnliMjFwYzJWY2JseDBJQ292WEc1Y2RHWjFibU4wYVc5dUlIQnliMjFwYzJWZmJtOWthV1o1S0dOaUtYdGNibHgwWEhSeVpYUjFjbTRnZEdocGN5NTBhR1Z1S0Z4dVhIUmNkRngwWm5WdVkzUnBiMjRvWVNsN1hHNWNkRngwWEhSY2RISmxkSFZ5YmlCcGMwWjFibU1vWTJJcElEOGdZMkl1WVhCd2JIa29iblZzYkN3Z2FYTkJjbkpoZVNoaEtTQS9JR0V1YzNCc2FXTmxLREFzTUN4MWJtUmxabWx1WldRcElDWW1JR0VnT2lCYmRXNWtaV1pwYm1Wa0xHRmRLU0E2SUNoa1pXWmxjaTV2Ym14NVJuVnVZM01nUHlCaElEb2dZMklwTzF4dVhIUmNkRngwZlZ4dVhIUmNkRngwTENCbWRXNWpkR2x2YmlobEtYdGNibHgwWEhSY2RGeDBjbVYwZFhKdUlHTmlLR1VwTzF4dVhIUmNkRngwZlZ4dVhIUmNkQ2s3WEc1Y2RIMWNibHh1WEhRdktpcGNibHgwSUNwY2JseDBJQ29nUUhCaGNtRnRJSHRtZFc1amRHbHZibjBnVzJaaGFXeGxaRjBnZDJsMGFHOTFkQ0J3WVhKaGJXVjBaWElnZDJsc2JDQnZibXg1SUhKbGRHaHliM2NnY0hKdmJXbHpaU0J5WldwbFkzUnBiMjRnY21WaGMyOXVJRzkxZEhOcFpHVWdiMllnZEdobElIQnliMjFwYzJVZ2JHbGljbUZ5ZVNCdmJpQnVaWGgwSUhScFkydGNibHgwSUNvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdjR0Z6YzJWa0lHRWdabUZwYkdWa0lHMWxkR2h2WkNCMGFHVnVJSGRwYkd3Z1kyRnNiQ0JtWVdsc1pXUWdiMjRnY21WcVpXTjBhVzl1SUdGdVpDQjBhSEp2ZHlCMGFHVWdaWEp5YjNJZ1lXZGhhVzRnYVdZZ1ptRnBiR1ZrSUdScFpHNG5kRnh1WEhRZ0tpQkFjbVYwZFhKdWN5QjdjSEp2YldselpYMGdZU0J1WlhjZ2NISnZiV2x6WlZ4dVhIUWdLaTljYmx4MFpuVnVZM1JwYjI0Z2NISnZiV2x6WlY5eVpYUm9jbTkzS0daaGFXeGxaQ2w3WEc1Y2RGeDBjbVYwZFhKdUlIUm9hWE11ZEdobGJpaGNibHgwWEhSY2RIVnVaR1ZtWEc1Y2RGeDBYSFFzSUdaaGFXeGxaQ0EvSUdaMWJtTjBhVzl1S0dVcGV5Qm1ZV2xzWldRb1pTazdJSFJvY205M0lHVTdJSDBnT2lCeVpYUm9jbTkzWEc1Y2RGeDBLVHRjYmx4MGZWeHVYRzVjZEM4cUtseHVYSFFxSUVCd1lYSmhiU0I3WW05dmJHVmhibjBnVzJGc2QyRjVjMEZ6ZVc1alhTQnBaaUJ6WlhRZ1ptOXlZMlVnZEdobElHRnplVzVqSUhKbGMyOXNkWFJwYjI0Z1ptOXlJSFJvYVhNZ2NISnZiV2x6WlNCcGJtUmxjR1Z1WkdGdWRHeDVJRzltSUhSb1pTQkVMbUZzZDJGNWMwRnplVzVqSUc5d2RHbHZibHh1WEhRcUlFQnlaWFIxY201eklIdGtaV1psY25KbFpIMGdaR1ZtWlhKbFpDQnZZbXBsWTNRZ2QybDBhQ0J3Y205d1pYSjBlU0FuY0hKdmJXbHpaU2NnWVc1a0lHMWxkR2h2WkhNZ2NtVnFaV04wTEdaMWJHWnBiR3dzY21WemIyeDJaU0FvWm5Wc1ptbHNiQ0JpWldsdVp5QmhiaUJoYkdsaGN5Qm1iM0lnY21WemIyeDJaU2xjYmx4MEtpOWNibHgwZG1GeUlHUmxabVZ5SUQwZ1puVnVZM1JwYjI0Z0tHRnNkMkY1YzBGemVXNWpLWHRjYmx4MFhIUjJZWElnWVd4M1lYbHpRWE41Ym1OR2JpQTlJQ2gxYm1SbFppQWhQVDBnWVd4M1lYbHpRWE41Ym1NZ1B5QmhiSGRoZVhOQmMzbHVZeUE2SUdSbFptVnlMbUZzZDJGNWMwRnplVzVqS1NBL0lHNWxlSFJVYVdOcklEb2dablZ1WTNScGIyNG9abTRwZTJadUtDazdmVnh1WEhSY2RGeDBMQ0J6ZEdGMGRYTWdQU0F3SUM4dklDMHhJR1poYVd4bFpDQjhJREVnWm5Wc1ptbHNiR1ZrWEc1Y2RGeDBYSFFzSUhCbGJtUnBibWR6SUQwZ1cxMWNibHgwWEhSY2RDd2dkbUZzZFdWY2JseDBYSFJjZEM4cUtseHVYSFJjZEZ4MElDb2dRSFI1Y0dWa1pXWWdjSEp2YldselpWeHVYSFJjZEZ4MElDb3ZYRzVjZEZ4MFhIUXNJRjl3Y205dGFYTmxJQ0E5SUh0Y2JseDBYSFJjZEZ4MEx5b3FYRzVjZEZ4MFhIUmNkQ0FxSUVCd1lYSmhiU0I3Wm5Wc1ptbHNiR1ZrZkdaMWJtTjBhVzl1ZlNCbWRXeG1hV3hzWldRZ1kyRnNiR0poWTJ0Y2JseDBYSFJjZEZ4MElDb2dRSEJoY21GdElIdG1ZV2xzWldSOFpuVnVZM1JwYjI1OUlHWmhhV3hsWkNCallXeHNZbUZqYTF4dVhIUmNkRngwWEhRZ0tpQkFjbVYwZFhKdWN5QjdjSEp2YldselpYMGdZU0J1WlhjZ2NISnZiV2x6WlZ4dVhIUmNkRngwWEhRZ0tpOWNibHgwWEhSY2RGeDBkR2hsYmpvZ1puVnVZM1JwYjI0b1puVnNabWxzYkdWa0xDQm1ZV2xzWldRcGUxeHVYSFJjZEZ4MFhIUmNkSFpoY2lCa0lEMGdaR1ZtWlhJb0tUdGNibHgwWEhSY2RGeDBYSFJ3Wlc1a2FXNW5jeTV3ZFhOb0tGdGNibHgwWEhSY2RGeDBYSFJjZEdaMWJtTjBhVzl1S0haaGJIVmxLWHRjYmx4MFhIUmNkRngwWEhSY2RGeDBkSEo1ZTF4dVhIUmNkRngwWEhSY2RGeDBYSFJjZEdsbUtDQnBjMDV2ZEZaaGJDaG1kV3htYVd4c1pXUXBLWHRjYmx4MFhIUmNkRngwWEhSY2RGeDBYSFJjZEdRdWNtVnpiMngyWlNoMllXeDFaU2s3WEc1Y2RGeDBYSFJjZEZ4MFhIUmNkRngwZlNCbGJITmxJSHRjYmx4MFhIUmNkRngwWEhSY2RGeDBYSFJjZEdRdWNtVnpiMngyWlNocGMwWjFibU1vWm5Wc1ptbHNiR1ZrS1NBL0lHWjFiR1pwYkd4bFpDaDJZV3gxWlNrZ09pQW9aR1ZtWlhJdWIyNXNlVVoxYm1OeklEOGdkbUZzZFdVZ09pQm1kV3htYVd4c1pXUXBLVHRjYmx4MFhIUmNkRngwWEhSY2RGeDBYSFI5WEc1Y2RGeDBYSFJjZEZ4MFhIUmNkSDFqWVhSamFDaGxLWHRjYmx4MFhIUmNkRngwWEhSY2RGeDBYSFJrTG5KbGFtVmpkQ2hsS1R0Y2JseDBYSFJjZEZ4MFhIUmNkRngwZlZ4dVhIUmNkRngwWEhSY2RGeDBmVnh1WEhSY2RGeDBYSFJjZEZ4MExDQm1kVzVqZEdsdmJpaGxjbklwZTF4dVhIUmNkRngwWEhSY2RGeDBYSFJwWmlBb0lHbHpUbTkwVm1Gc0tHWmhhV3hsWkNrZ2ZId2dLQ2doYVhOR2RXNWpLR1poYVd4bFpDa3BJQ1ltSUdSbFptVnlMbTl1YkhsR2RXNWpjeWtnS1NCN1hHNWNkRngwWEhSY2RGeDBYSFJjZEZ4MFpDNXlaV3BsWTNRb1pYSnlLVHRjYmx4MFhIUmNkRngwWEhSY2RGeDBmVnh1WEhSY2RGeDBYSFJjZEZ4MFhIUnBaaUFvSUdaaGFXeGxaQ0FwSUh0Y2JseDBYSFJjZEZ4MFhIUmNkRngwWEhSMGNubDdJR1F1Y21WemIyeDJaU2hwYzBaMWJtTW9abUZwYkdWa0tTQS9JR1poYVd4bFpDaGxjbklwSURvZ1ptRnBiR1ZrS1RzZ2ZXTmhkR05vS0dVcGV5QmtMbkpsYW1WamRDaGxLVHQ5WEc1Y2RGeDBYSFJjZEZ4MFhIUmNkSDFjYmx4MFhIUmNkRngwWEhSY2RIMWNibHgwWEhSY2RGeDBYSFJkS1R0Y2JseDBYSFJjZEZ4MFhIUnpkR0YwZFhNZ0lUMDlJREFnSmlZZ1lXeDNZWGx6UVhONWJtTkdiaWhsZUdWalEyRnNiR0poWTJ0ektUdGNibHgwWEhSY2RGeDBYSFJ5WlhSMWNtNGdaQzV3Y205dGFYTmxPMXh1WEhSY2RGeDBYSFI5WEc1Y2JseDBYSFJjZEZ4MExDQnpkV05qWlhOek9pQndjbTl0YVhObFgzTjFZMk5sYzNOY2JseHVYSFJjZEZ4MFhIUXNJR1Z5Y205eU9pQndjbTl0YVhObFgyVnljbTl5WEc1Y2RGeDBYSFJjZEN3Z2IzUm9aWEozYVhObE9pQndjbTl0YVhObFgyVnljbTl5WEc1Y2JseDBYSFJjZEZ4MExDQmhjSEJzZVRvZ2NISnZiV2x6WlY5aGNIQnNlVnh1WEhSY2RGeDBYSFFzSUhOd2NtVmhaRG9nY0hKdmJXbHpaVjloY0hCc2VWeHVYRzVjZEZ4MFhIUmNkQ3dnWlc1emRYSmxPaUJ3Y205dGFYTmxYMlZ1YzNWeVpWeHVYRzVjZEZ4MFhIUmNkQ3dnYm05a2FXWjVPaUJ3Y205dGFYTmxYMjV2WkdsbWVWeHVYRzVjZEZ4MFhIUmNkQ3dnY21WMGFISnZkem9nY0hKdmJXbHpaVjl5WlhSb2NtOTNYRzVjYmx4MFhIUmNkRngwTENCcGMxQmxibVJwYm1jNklHWjFibU4wYVc5dUtDbDdJSEpsZEhWeWJpQWhJU2h6ZEdGMGRYTWdQVDA5SURBcE95QjlYRzVjYmx4MFhIUmNkRngwTENCblpYUlRkR0YwZFhNNklHWjFibU4wYVc5dUtDbDdJSEpsZEhWeWJpQnpkR0YwZFhNN0lIMWNibHgwWEhSY2RIMWNibHgwWEhRN1hHNWNkRngwWDNCeWIyMXBjMlV1ZEc5VGIzVnlZMlVnUFNCZmNISnZiV2x6WlM1MGIxTjBjbWx1WnlBOUlGOXdjbTl0YVhObExuWmhiSFZsVDJZZ1BTQm1kVzVqZEdsdmJpZ3BlM0psZEhWeWJpQjJZV3gxWlNBOVBUMGdkVzVrWldZZ1B5QjBhR2x6SURvZ2RtRnNkV1U3SUgwN1hHNWNibHh1WEhSY2RHWjFibU4wYVc5dUlHVjRaV05EWVd4c1ltRmphM01vS1h0Y2JseDBYSFJjZEdsbUlDZ2djM1JoZEhWeklEMDlQU0F3SUNrZ2UxeHVYSFJjZEZ4MFhIUnlaWFIxY200N1hHNWNkRngwWEhSOVhHNWNkRngwWEhSMllYSWdZMkp6SUQwZ2NHVnVaR2x1WjNNc0lHa2dQU0F3TENCc0lEMGdZMkp6TG14bGJtZDBhQ3dnWTJKSmJtUmxlQ0E5SUg1emRHRjBkWE1nUHlBd0lEb2dNU3dnWTJJN1hHNWNkRngwWEhSd1pXNWthVzVuY3lBOUlGdGRPMXh1WEhSY2RGeDBabTl5S0NBN0lHa2dQQ0JzT3lCcEt5c2dLWHRjYmx4MFhIUmNkRngwS0dOaUlEMGdZMkp6VzJsZFcyTmlTVzVrWlhoZEtTQW1KaUJqWWloMllXeDFaU2s3WEc1Y2RGeDBYSFI5WEc1Y2RGeDBmVnh1WEc1Y2RGeDBMeW9xWEc1Y2RGeDBJQ29nWm5Wc1ptbHNiQ0JrWldabGNuSmxaQ0IzYVhSb0lHZHBkbVZ1SUhaaGJIVmxYRzVjZEZ4MElDb2dRSEJoY21GdElIc3FmU0IyWVd4Y2JseDBYSFFnS2lCQWNtVjBkWEp1Y3lCN1pHVm1aWEp5WldSOUlIUm9hWE1nWm05eUlHMWxkR2h2WkNCamFHRnBibWx1WjF4dVhIUmNkQ0FxTDF4dVhIUmNkR1oxYm1OMGFXOXVJRjl5WlhOdmJIWmxLSFpoYkNsN1hHNWNkRngwWEhSMllYSWdaRzl1WlNBOUlHWmhiSE5sTzF4dVhIUmNkRngwWm5WdVkzUnBiMjRnYjI1alpTaG1LWHRjYmx4MFhIUmNkRngwY21WMGRYSnVJR1oxYm1OMGFXOXVLSGdwZTF4dVhIUmNkRngwWEhSY2RHbG1JQ2hrYjI1bEtTQjdYRzVjZEZ4MFhIUmNkRngwWEhSeVpYUjFjbTRnZFc1a1pXWnBibVZrTzF4dVhIUmNkRngwWEhSY2RIMGdaV3h6WlNCN1hHNWNkRngwWEhSY2RGeDBYSFJrYjI1bElEMGdkSEoxWlR0Y2JseDBYSFJjZEZ4MFhIUmNkSEpsZEhWeWJpQm1LSGdwTzF4dVhIUmNkRngwWEhSY2RIMWNibHgwWEhSY2RGeDBmVHRjYmx4MFhIUmNkSDFjYmx4MFhIUmNkR2xtSUNnZ2MzUmhkSFZ6SUNrZ2UxeHVYSFJjZEZ4MFhIUnlaWFIxY200Z2RHaHBjenRjYmx4MFhIUmNkSDFjYmx4MFhIUmNkSFJ5ZVNCN1hHNWNkRngwWEhSY2RIWmhjaUIwYUdWdUlEMGdhWE5QWW1wUGNrWjFibU1vZG1Gc0tTQW1KaUIyWVd3dWRHaGxianRjYmx4MFhIUmNkRngwYVdZZ0tDQnBjMFoxYm1Nb2RHaGxiaWtnS1NCN0lDOHZJRzFoYm1GbmFXNW5JR0VnY0hKdmJXbHpaVnh1WEhSY2RGeDBYSFJjZEdsbUtDQjJZV3dnUFQwOUlGOXdjbTl0YVhObElDbDdYRzVjZEZ4MFhIUmNkRngwWEhSMGFISnZkeUJ1WlhjZ2RFVnljaWhjSWxCeWIyMXBjMlVnWTJGdUozUWdjbVZ6YjJ4MlpTQnBkSE5sYkdaY0lpazdYRzVjZEZ4MFhIUmNkRngwZlZ4dVhIUmNkRngwWEhSY2RIUm9aVzR1WTJGc2JDaDJZV3dzSUc5dVkyVW9YM0psYzI5c2RtVXBMQ0J2Ym1ObEtGOXlaV3BsWTNRcEtUdGNibHgwWEhSY2RGeDBYSFJ5WlhSMWNtNGdkR2hwY3p0Y2JseDBYSFJjZEZ4MGZWeHVYSFJjZEZ4MGZTQmpZWFJqYUNBb1pTa2dlMXh1WEhSY2RGeDBYSFJ2Ym1ObEtGOXlaV3BsWTNRcEtHVXBPMXh1WEhSY2RGeDBYSFJ5WlhSMWNtNGdkR2hwY3p0Y2JseDBYSFJjZEgxY2JseDBYSFJjZEdGc2QyRjVjMEZ6ZVc1alJtNG9ablZ1WTNScGIyNG9LWHRjYmx4MFhIUmNkRngwZG1Gc2RXVWdQU0IyWVd3N1hHNWNkRngwWEhSY2RITjBZWFIxY3lBOUlERTdYRzVjZEZ4MFhIUmNkR1Y0WldORFlXeHNZbUZqYTNNb0tUdGNibHgwWEhSY2RIMHBPMXh1WEhSY2RGeDBjbVYwZFhKdUlIUm9hWE03WEc1Y2RGeDBmVnh1WEc1Y2RGeDBMeW9xWEc1Y2RGeDBJQ29nY21WcVpXTjBJR1JsWm1WeWNtVmtJSGRwZEdnZ1oybDJaVzRnY21WaGMyOXVYRzVjZEZ4MElDb2dRSEJoY21GdElIc3FmU0JGY25KY2JseDBYSFFnS2lCQWNtVjBkWEp1Y3lCN1pHVm1aWEp5WldSOUlIUm9hWE1nWm05eUlHMWxkR2h2WkNCamFHRnBibWx1WjF4dVhIUmNkQ0FxTDF4dVhIUmNkR1oxYm1OMGFXOXVJRjl5WldwbFkzUW9SWEp5S1h0Y2JseDBYSFJjZEhOMFlYUjFjeUI4ZkNCaGJIZGhlWE5CYzNsdVkwWnVLR1oxYm1OMGFXOXVLQ2w3WEc1Y2RGeDBYSFJjZEhSeWVYc2dkR2h5YjNjb1JYSnlLVHNnZldOaGRHTm9LR1VwZXlCMllXeDFaU0E5SUdVN0lIMWNibHgwWEhSY2RGeDBjM1JoZEhWeklEMGdMVEU3WEc1Y2RGeDBYSFJjZEdWNFpXTkRZV3hzWW1GamEzTW9LVHRjYmx4MFhIUmNkSDBwTzF4dVhIUmNkRngwY21WMGRYSnVJSFJvYVhNN1hHNWNkRngwZlZ4dVhIUmNkSEpsZEhWeWJpQXZLaXBBZEhsd1pTQmtaV1psY25KbFpDQXFMeUI3WEc1Y2RGeDBYSFJ3Y205dGFYTmxPbDl3Y205dGFYTmxYRzVjZEZ4MFhIUXNjbVZ6YjJ4MlpUcGZjbVZ6YjJ4MlpWeHVYSFJjZEZ4MExHWjFiR1pwYkd3NlgzSmxjMjlzZG1VZ0x5OGdZV3hwWVhOY2JseDBYSFJjZEN4eVpXcGxZM1E2WDNKbGFtVmpkRnh1WEhSY2RIMDdYRzVjZEgwN1hHNWNibHgwWkdWbVpYSXVaR1ZtWlhKeVpXUWdQU0JrWldabGNpNWtaV1psY2lBOUlHUmxabVZ5TzF4dVhIUmtaV1psY2k1dVpYaDBWR2xqYXlBOUlHNWxlSFJVYVdOck8xeHVYSFJrWldabGNpNWhiSGRoZVhOQmMzbHVZeUE5SUhSeWRXVTdJQzh2SUhObGRIUnBibWNnZEdocGN5QjNhV3hzSUdOb1lXNW5aU0JrWldaaGRXeDBJR0psYUdGMmFXOTFjaTRnZFhObElHbDBJRzl1YkhrZ2FXWWdibVZqWlhOellYSjVJR0Z6SUdGemVXNWphSEp2Ym1samFYUjVJSGRwYkd3Z1ptOXlZMlVnYzI5dFpTQmtaV3hoZVNCaVpYUjNaV1Z1SUhsdmRYSWdjSEp2YldselpTQnlaWE52YkhWMGFXOXVjeUJoYm1RZ2FYTWdibTkwSUdGc2QyRjVjeUIzYUdGMElIbHZkU0IzWVc1MExseHVYSFF2S2lwY2JseDBLaUJ6WlhSMGFXNW5JRzl1YkhsR2RXNWpjeUIwYnlCbVlXeHpaU0IzYVd4c0lHSnlaV0ZySUhCeWIyMXBjMlZ6TDBFcklHTnZibVp2Y20xcGRIa2dZbmtnWVd4c2IzZHBibWNnZVc5MUlIUnZJSEJoYzNNZ2JtOXVJSFZ1WkdWbWFXNWxaQzl1ZFd4c0lIWmhiSFZsY3lCcGJuTjBaV0ZrSUc5bUlHTmhiR3hpWVdOcmMxeHVYSFFxSUdsdWMzUmxZV1FnYjJZZ2FuVnpkQ0JwWjI1dmNtbHVaeUJoYm5rZ2JtOXVJR1oxYm1OMGFXOXVJSEJoY21GdFpYUmxjbk1nZEc4Z2RHaGxiaXh6ZFdOalpYTnpMR1Z5Y205eUxpNHVJR2wwSUhkcGJHd2dZV05qWlhCMElHNXZiaUJ1ZFd4c2ZIVnVaR1ZtYVc1bFpDQjJZV3gxWlhNdVhHNWNkQ29nZEdocGN5QjNhV3hzSUdGc2JHOTNJSGx2ZFNCemFHOXlkR04xZEhNZ2JHbHJaU0J3Y205dGFYTmxMblJvWlc0b0ozWmhiQ2NzSjJoaGJtUnNaV1FnWlhKeWIzSW5KeWxjYmx4MEtpQjBieUJpWlNCbGNYVnBkbUZzWlc1MElHOW1JSEJ5YjIxcGMyVXVkR2hsYmlobWRXNWpkR2x2YmlncGV5QnlaWFIxY200Z0ozWmhiQ2M3ZlN4bWRXNWpkR2x2YmlncGV5QnlaWFIxY200Z0oyaGhibVJzWldRZ1pYSnliM0luZlNsY2JseDBLaTljYmx4MFpHVm1aWEl1YjI1c2VVWjFibU56SUQwZ2RISjFaVHRjYmx4dVhIUXZLaXBjYmx4MElDb2djbVYwZFhKdUlHRWdablZzWm1sc2JHVmtJSEJ5YjIxcGMyVWdiMllnWjJsMlpXNGdkbUZzZFdVZ0tHRnNkMkY1Y3lCaGMzbHVZeUJ5WlhOdmJIVjBhVzl1S1Z4dVhIUWdLaUJBY0dGeVlXMGdleXA5SUhaaGJIVmxYRzVjZENBcUlFQnlaWFIxY201eklIdHdjbTl0YVhObGZWeHVYSFFnS2k5Y2JseDBaR1ZtWlhJdWNtVnpiMngyWldRZ1BTQmtaV1psY2k1bWRXeG1hV3hzWldRZ1BTQm1kVzVqZEdsdmJpaDJZV3gxWlNsN0lISmxkSFZ5YmlCa1pXWmxjaWgwY25WbEtTNXlaWE52YkhabEtIWmhiSFZsS1M1d2NtOXRhWE5sT3lCOU8xeHVYRzVjZEM4cUtseHVYSFFnS2lCeVpYUjFjbTRnWVNCeVpXcGxZM1JsWkNCd2NtOXRhWE5sSUhkcGRHZ2daMmwyWlc0Z2NtVmhjMjl1SUc5bUlISmxhbVZqZEdsdmJpQW9ZV3gzWVhseklHRnplVzVqSUhKbGFtVmpkR2x2YmlsY2JseDBJQ29nUUhCaGNtRnRJSHNxZlNCeVpXRnpiMjVjYmx4MElDb2dRSEpsZEhWeWJuTWdlM0J5YjIxcGMyVjlYRzVjZENBcUwxeHVYSFJrWldabGNpNXlaV3BsWTNSbFpDQTlJR1oxYm1OMGFXOXVLSEpsWVhOdmJpbDdJSEpsZEhWeWJpQmtaV1psY2loMGNuVmxLUzV5WldwbFkzUW9jbVZoYzI5dUtTNXdjbTl0YVhObE95QjlPMXh1WEc1Y2RDOHFLbHh1WEhRZ0tpQnlaWFIxY200Z1lTQndjbTl0YVhObElIZHBkR2dnYm04Z2NtVnpiMngxZEdsdmJpQjJZV3gxWlNCM2FHbGphQ0IzYVd4c0lHSmxJSEpsYzI5c2RtVmtJR2x1SUhScGJXVWdiWE1nS0hWemFXNW5JSE5sZEZScGJXVnZkWFFwWEc1Y2RDQXFJRUJ3WVhKaGJTQjdhVzUwZlNCYmRHbHRaVjBnYVc0Z2JYTWdaR1ZtWVhWc2RDQjBieUF3WEc1Y2RDQXFJRUJ5WlhSMWNtNXpJSHR3Y205dGFYTmxmVnh1WEhRZ0tpOWNibHgwWkdWbVpYSXVkMkZwZENBOUlHWjFibU4wYVc5dUtIUnBiV1VwZTF4dVhIUmNkSFpoY2lCa0lEMGdaR1ZtWlhJb0tUdGNibHgwWEhSelpYUlVhVzFsYjNWMEtHUXVjbVZ6YjJ4MlpTd2dkR2x0WlNCOGZDQXdLVHRjYmx4MFhIUnlaWFIxY200Z1pDNXdjbTl0YVhObE8xeHVYSFI5TzF4dVhHNWNkQzhxS2x4dVhIUWdLaUJ5WlhSMWNtNGdZU0J3Y205dGFYTmxJR1p2Y2lCMGFHVWdjbVYwZFhKdUlIWmhiSFZsSUc5bUlHWjFibU4wYVc5dUlHTmhiR3dnZDJocFkyZ2dkMmxzYkNCaVpTQm1kV3htYVd4c1pXUWdhVzRnWkdWc1lYa2diWE1nYjNJZ2NtVnFaV04wWldRZ2FXWWdaMmwyWlc0Z1ptNGdkR2h5YjNjZ1lXNGdaWEp5YjNKY2JseDBJQ29nUUhCaGNtRnRJSHRtZFc1amRHbHZibjBnWm01Y2JseDBJQ29nUUhCaGNtRnRJSHRwYm5SOUlGdGtaV3hoZVYwZ2FXNGdiWE1nWkdWbVlYVnNkQ0IwYnlBd1hHNWNkQ0FxSUVCeVpYUjFjbTV6SUh0d2NtOXRhWE5sZlZ4dVhIUWdLaTljYmx4MFpHVm1aWEl1WkdWc1lYa2dQU0JtZFc1amRHbHZiaWhtYml3Z1pHVnNZWGtwZTF4dVhIUmNkSFpoY2lCa0lEMGdaR1ZtWlhJb0tUdGNibHgwWEhSelpYUlVhVzFsYjNWMEtHWjFibU4wYVc5dUtDbDdJSFJ5ZVhzZ1pDNXlaWE52YkhabEtHWnVMbUZ3Y0d4NUtHNTFiR3dwS1RzZ2ZXTmhkR05vS0dVcGV5QmtMbkpsYW1WamRDaGxLVHNnZlNCOUxDQmtaV3hoZVNCOGZDQXdLVHRjYmx4MFhIUnlaWFIxY200Z1pDNXdjbTl0YVhObE8xeHVYSFI5TzF4dVhHNWNkQzhxS2x4dVhIUWdLaUJwWmlCbmFYWmxiaUIyWVd4MVpTQnBjeUJ1YjNRZ1lTQndjbTl0YVhObElISmxkSFZ5YmlCaElHWjFiR1pwYkd4bFpDQndjbTl0YVhObElISmxjMjlzZG1Wa0lIUnZJR2RwZG1WdUlIWmhiSFZsWEc1Y2RDQXFJRUJ3WVhKaGJTQjdLbjBnY0hKdmJXbHpaU0JoSUhaaGJIVmxJRzl5SUdFZ2NISnZiV2x6WlZ4dVhIUWdLaUJBY21WMGRYSnVjeUI3Y0hKdmJXbHpaWDFjYmx4MElDb3ZYRzVjZEdSbFptVnlMbkJ5YjIxcGMybG1lU0E5SUdaMWJtTjBhVzl1S0hCeWIyMXBjMlVwZTF4dVhIUmNkR2xtSUNnZ2NISnZiV2x6WlNBbUppQnBjMFoxYm1Nb2NISnZiV2x6WlM1MGFHVnVLU0FwSUhzZ2NtVjBkWEp1SUhCeWIyMXBjMlU3ZlZ4dVhIUmNkSEpsZEhWeWJpQmtaV1psY2k1eVpYTnZiSFpsWkNod2NtOXRhWE5sS1R0Y2JseDBmVHRjYmx4dVhIUm1kVzVqZEdsdmJpQnRkV3gwYVZCeWIyMXBjMlZTWlhOdmJIWmxjaWhqWVd4c1pYSkJjbWQxYldWdWRITXNJSEpsZEhWeWJsQnliMjFwYzJWektYdGNibHgwWEhSMllYSWdjSEp2YldselpYTWdQU0J6YkdsalpTaGpZV3hzWlhKQmNtZDFiV1Z1ZEhNcE8xeHVYSFJjZEdsbUlDZ2djSEp2YldselpYTXViR1Z1WjNSb0lEMDlQU0F4SUNZbUlHbHpRWEp5WVhrb2NISnZiV2x6WlhOYk1GMHBJQ2tnZTF4dVhIUmNkRngwYVdZb0lTQndjbTl0YVhObGMxc3dYUzVzWlc1bmRHZ2dLWHRjYmx4MFhIUmNkRngwY21WMGRYSnVJR1JsWm1WeUxtWjFiR1pwYkd4bFpDaGJYU2s3WEc1Y2RGeDBYSFI5WEc1Y2RGeDBYSFJ3Y205dGFYTmxjeUE5SUhCeWIyMXBjMlZ6V3pCZE8xeHVYSFJjZEgxY2JseDBYSFIyWVhJZ1lYSm5jeUE5SUZ0ZFhHNWNkRngwWEhRc0lHUWdQU0JrWldabGNpZ3BYRzVjZEZ4MFhIUXNJR01nUFNCd2NtOXRhWE5sY3k1c1pXNW5kR2hjYmx4MFhIUTdYRzVjZEZ4MGFXWWdLQ0FoWXlBcElIdGNibHgwWEhSY2RHUXVjbVZ6YjJ4MlpTaGhjbWR6S1R0Y2JseDBYSFI5SUdWc2MyVWdlMXh1WEhSY2RGeDBkbUZ5SUhKbGMyOXNkbVZ5SUQwZ1puVnVZM1JwYjI0b2FTbDdYRzVjZEZ4MFhIUmNkSEJ5YjIxcGMyVnpXMmxkSUQwZ1pHVm1aWEl1Y0hKdmJXbHphV1o1S0hCeWIyMXBjMlZ6VzJsZEtUdGNibHgwWEhSY2RGeDBjSEp2YldselpYTmJhVjB1ZEdobGJpaGNibHgwWEhSY2RGeDBYSFJtZFc1amRHbHZiaWgyS1h0Y2JseDBYSFJjZEZ4MFhIUmNkR2xtSUNnaElDaHBJR2x1SUdGeVozTXBJQ2tnZXlBdkwwQjBiMlJ2SUdOb1pXTnJJSFJvYVhNZ2FYTWdjM1JwYkd3Z2NtVnhkV2x5WldRZ1lYTWdjSEp2YldselpYTWdZMkZ1SjNRZ1ltVWdjbVZ6YjJ4MlpTQnRiM0psSUhSb1lXNGdiMjVqWlZ4dVhIUmNkRngwWEhSY2RGeDBYSFJoY21kelcybGRJRDBnY21WMGRYSnVVSEp2YldselpYTWdQeUJ3Y205dGFYTmxjMXRwWFNBNklIWTdYRzVjZEZ4MFhIUmNkRngwWEhSY2RDZ3RMV01wSUh4OElHUXVjbVZ6YjJ4MlpTaGhjbWR6S1R0Y2JseDBYSFJjZEZ4MFhIUmNkSDFjYmx4MFhIUmNkRngwWEhSOVhHNWNkRngwWEhSY2RGeDBMQ0JtZFc1amRHbHZiaWhsS1h0Y2JseDBYSFJjZEZ4MFhIUmNkR2xtS0NFZ0tHa2dhVzRnWVhKbmN5a2dLWHRjYmx4MFhIUmNkRngwWEhSY2RGeDBhV1lvSUNFZ2NtVjBkWEp1VUhKdmJXbHpaWE1nS1h0Y2JseDBYSFJjZEZ4MFhIUmNkRngwWEhSa0xuSmxhbVZqZENobEtUdGNibHgwWEhSY2RGeDBYSFJjZEZ4MGZTQmxiSE5sSUh0Y2JseDBYSFJjZEZ4MFhIUmNkRngwWEhSaGNtZHpXMmxkSUQwZ2NISnZiV2x6WlhOYmFWMDdYRzVjZEZ4MFhIUmNkRngwWEhSY2RGeDBLQzB0WXlrZ2ZId2daQzV5WlhOdmJIWmxLR0Z5WjNNcE8xeHVYSFJjZEZ4MFhIUmNkRngwWEhSOVhHNWNkRngwWEhSY2RGeDBYSFI5WEc1Y2RGeDBYSFJjZEZ4MGZWeHVYSFJjZEZ4MFhIUXBPMXh1WEhSY2RGeDBmVHRjYmx4MFhIUmNkR1p2Y2lnZ2RtRnlJR2tnUFNBd0xDQnNJRDBnWXpzZ2FTQThJR3c3SUdrckt5QXBlMXh1WEhSY2RGeDBYSFJ5WlhOdmJIWmxjaWhwS1R0Y2JseDBYSFJjZEgxY2JseDBYSFI5WEc1Y2RGeDBjbVYwZFhKdUlHUXVjSEp2YldselpUdGNibHgwZlZ4dVhHNWNkQzhxS2x4dVhIUWdLaUJ5WlhSMWNtNGdZU0J3Y205dGFYTmxJR1p2Y2lCaGJHd2daMmwyWlc0Z2NISnZiV2x6WlhNZ0x5QjJZV3gxWlhNdVhHNWNkQ0FxSUhSb1pTQnlaWFIxY201bFpDQndjbTl0YVhObGN5QjNhV3hzSUdKbElHWjFiR1pwYkd4bFpDQjNhWFJvSUdFZ2JHbHpkQ0J2WmlCeVpYTnZiSFpsWkNCMllXeDFaUzVjYmx4MElDb2dhV1lnWVc1NUlHZHBkbVZ1SUhCeWIyMXBjMlVnYVhNZ2NtVnFaV04wWldRZ2RHaGxiaUJ2YmlCMGFHVWdabWx5YzNRZ2NtVnFaV04wYVc5dUlIUm9aU0J5WlhSMWNtNWxaQ0J3Y205dGFYTmxaQ0IzYVd4c0lHSmxJSEpsYW1WamRHVmtJSGRwZEdnZ2RHaGxJSE5oYldVZ2NtVmhjMjl1WEc1Y2RDQXFJRUJ3WVhKaGJTQjdZWEp5WVhsOExpNHVLbjBnVzNCeWIyMXBjMlZkSUdOaGJpQmlaU0JoSUhOcGJtZHNaU0JoY25KaGVTQnZaaUJ3Y205dGFYTmxMM1poYkhWbGN5QmhjeUJtYVhKemRDQndZWEpoYldWMFpYSWdiM0lnWVNCc2FYTjBJRzltSUdScGNtVmpkQ0J3WVhKaGJXVjBaWEp6SUhCeWIyMXBjMlV2ZG1Gc2RXVmNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UzQnliMjFwYzJWOUlHOW1JR0VnYkdsemRDQnZaaUJuYVhabGJpQndjbTl0YVhObElISmxjMjlzZFhScGIyNGdkbUZzZFdWY2JseDBJQ292WEc1Y2RHUmxabVZ5TG1Gc2JDQTlJR1oxYm1OMGFXOXVLQ2w3SUhKbGRIVnliaUJ0ZFd4MGFWQnliMjFwYzJWU1pYTnZiSFpsY2loaGNtZDFiV1Z1ZEhNc1ptRnNjMlVwT3lCOU8xeHVYRzVjZEM4cUtseHVYSFFnS2lCeVpYUjFjbTRnWVc0Z1lXeDNZWGx6SUdaMWJHWnBiR3hsWkNCd2NtOXRhWE5sSUc5bUlHRnljbUY1UEhCeWIyMXBjMlUrSUd4cGMzUWdiMllnY0hKdmJXbHpaWE12ZG1Gc2RXVnpJSEpsWjJGeVpHeGxjM01nZEdobGVTQnlaWE52YkhabElHWjFiR1pwYkd4bFpDQnZjaUJ5WldwbFkzUmxaRnh1WEhRZ0tpQkFjR0Z5WVcwZ2UyRnljbUY1ZkM0dUxpcDlJRnR3Y205dGFYTmxYU0JqWVc0Z1ltVWdZU0J6YVc1bmJHVWdZWEp5WVhrZ2IyWWdjSEp2YldselpTOTJZV3gxWlhNZ1lYTWdabWx5YzNRZ2NHRnlZVzFsZEdWeUlHOXlJR0VnYkdsemRDQnZaaUJrYVhKbFkzUWdjR0Z5WVcxbGRHVnljeUJ3Y205dGFYTmxMM1poYkhWbFhHNWNkQ0FxSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0tHNXZiaUJ3Y205dGFYTmxJSFpoYkhWbGN5QjNhV3hzSUdKbElIQnliMjFwYzJsbWFXVmtLVnh1WEhRZ0tpQkFjbVYwZFhKdWN5QjdjSEp2YldselpYMGdiMllnZEdobElHeHBjM1FnYjJZZ1oybDJaVzRnY0hKdmJXbHpaWE5jYmx4MElDb3ZYRzVjZEdSbFptVnlMbkpsYzI5c2RtVkJiR3dnUFNCbWRXNWpkR2x2YmlncGV5QnlaWFIxY200Z2JYVnNkR2xRY205dGFYTmxVbVZ6YjJ4MlpYSW9ZWEpuZFcxbGJuUnpMSFJ5ZFdVcE95QjlPMXh1WEc1Y2RDOHFLbHh1WEhRZ0tpQjBjbUZ1YzJadmNtMGdZU0IwZVhCcFkyRnNJRzV2WkdWcWN5QmhjM2x1WXlCdFpYUm9iMlFnWVhkaGFYUnBibWNnWVNCallXeHNZbUZqYXlCaGN5QnNZWE4wSUhCaGNtRnRaWFJsY2l3Z2NtVmpaV2wyYVc1bklHVnljbTl5SUdGeklHWnBjbk4wSUhCaGNtRnRaWFJsY2lCMGJ5QmhJR1oxYm1OMGFXOXVJSFJvWVhSY2JseDBJQ29nZDJsc2JDQnlaWFIxY200Z1lTQndjbTl0YVhObElHbHVjM1JsWVdRdUlIUm9aU0J5WlhSMWNtNWxaQ0J3Y205dGFYTmxJSGRwYkd3Z2NtVnpiMngyWlNCM2FYUm9JRzV2Y20xaGJDQmpZV3hzWW1GamF5QjJZV3gxWlNCdGFXNTFjeUIwYUdVZ1ptbHljM1FnWlhKeWIzSWdjR0Z5WVcxbGRHVnlJRzl1WEc1Y2RDQXFJR1oxYkdacGJHd2dZVzVrSUhkcGJHd2dZbVVnY21WcVpXTjBaV1FnZDJsMGFDQjBhR0YwSUdWeWNtOXlJR0Z6SUhKbFlYTnZiaUJwYmlCallYTmxJRzltSUdWeWNtOXlMbHh1WEhRZ0tpQkFjR0Z5WVcwZ2UyOWlhbVZqZEgwZ1czTjFZbXBsWTNSZElHOXdkR2x2Ym1Gc0lITjFZbXBsWTNRZ2IyWWdkR2hsSUcxbGRHaHZaQ0IwYnlCbGJtTmhjSE4xYkdGMFpWeHVYSFFnS2lCQWNHRnlZVzBnZTJaMWJtTjBhVzl1ZlNCbWJpQjBhR1VnWm5WdVkzUnBiMjRnZEc4Z1pXNWpZWEJ6ZFd4aGRHVWdhV1lnZEdobElHNXZjbTFoYkNCallXeHNZbUZqYXlCemFHOTFiR1FnY21WalpXbDJaU0J0YjNKbElIUm9ZVzRnWVNCemFXNW5iR1VnY0dGeVlXMWxkR1Z5SUNodGFXNTFjeUIwYUdVZ1pYSnliM0lwWEc1Y2RDQXFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhSb1pTQndjbTl0YVhObElIZHBiR3dnY21WemIyeDJaU0IzYVhSb0lIUm9aU0JzYVhOMElHOXlJSEJoY21GdFpYUmxjbk1nWVhNZ1puVnNabWxzYkcxbGJuUWdkbUZzZFdVdUlFbG1JRzl1YkhrZ2IyNWxJSEJoY21GdFpYUmxjaUJwY3lCelpXNTBJSFJ2SUhSb1pWeHVYSFFnS2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQmpZV3hzWW1GamF5QjBhR1Z1SUdsMElIZHBiR3dnWW1VZ2RYTmxaQ0JoY3lCMGFHVWdjbVZ6YjJ4MWRHbHZiaUIyWVd4MVpTNWNibHgwSUNvZ1FISmxkSFZ5Ym5NZ2UwWjFibU4wYVc5dWZWeHVYSFFnS2k5Y2JseDBaR1ZtWlhJdWJtOWtaVU5oY0hOMWJHVWdQU0JtZFc1amRHbHZiaWh6ZFdKcVpXTjBMQ0JtYmlsN1hHNWNkRngwYVdZZ0tDQWhabTRnS1NCN1hHNWNkRngwWEhSbWJpQTlJSE4xWW1wbFkzUTdYRzVjZEZ4MFhIUnpkV0pxWldOMElEMGdkbTlwWkNnd0tUdGNibHgwWEhSOVhHNWNkRngwY21WMGRYSnVJR1oxYm1OMGFXOXVLQ2w3WEc1Y2RGeDBYSFIyWVhJZ1pDQTlJR1JsWm1WeUtDa3NJR0Z5WjNNZ1BTQnpiR2xqWlNoaGNtZDFiV1Z1ZEhNcE8xeHVYSFJjZEZ4MFlYSm5jeTV3ZFhOb0tHWjFibU4wYVc5dUtHVnljaXdnY21WektYdGNibHgwWEhSY2RGeDBaWEp5SUQ4Z1pDNXlaV3BsWTNRb1pYSnlLU0E2SUdRdWNtVnpiMngyWlNoaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvSUQ0Z01pQS9JSE5zYVdObEtHRnlaM1Z0Wlc1MGN5d2dNU2tnT2lCeVpYTXBPMXh1WEhSY2RGeDBmU2s3WEc1Y2RGeDBYSFIwY25sN1hHNWNkRngwWEhSY2RHWnVMbUZ3Y0d4NUtITjFZbXBsWTNRc0lHRnlaM01wTzF4dVhIUmNkRngwZldOaGRHTm9LR1VwZTF4dVhIUmNkRngwWEhSa0xuSmxhbVZqZENobEtUdGNibHgwWEhSY2RIMWNibHgwWEhSY2RISmxkSFZ5YmlCa0xuQnliMjFwYzJVN1hHNWNkRngwZlR0Y2JseDBmVHRjYmx4dVhIUjBlWEJsYjJZZ2QybHVaRzkzSUNFOVBTQjFibVJsWmxOMGNpQW1KaUFvZDJsdVpHOTNMa1FnUFNCa1pXWmxjaWs3WEc1Y2RIUjVjR1Z2WmlCdGIyUjFiR1VnSVQwOUlIVnVaR1ZtVTNSeUlDWW1JRzF2WkhWc1pTNWxlSEJ2Y25SeklDWW1JQ2h0YjJSMWJHVXVaWGh3YjNKMGN5QTlJR1JsWm1WeUtUdGNibHh1ZlNrb0tUdGNiaUpkZlE9PSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIi9yL3VzZXIvbG9naW5cIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci91c2VyL2xvZ291dFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3VzZXIvYWJvdXRcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci91c2VyL2F1dG9zYXZlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvdXNlci9yZWxlYXNlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9jcmVhdGVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L3Bvb2xcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L3JlY3ljbGVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2xpc3RcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L3BpbmdcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2Fib3V0XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9hYm91dC91cGRhdGVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L3NhdmVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L3NhdmVhc1wiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3Byb2plY3QvY2xvc2VcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2dyYW50XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9pbXBvcnRcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCIsXG4gICAgICAgIFwidXBsb2FkXCI6IHRydWVcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2V4cG9ydFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3Byb2plY3QvZGVsZXRlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9leGVjdXRlL2NvZGVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2V4ZWN1dGUvc2NyaXB0XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9leGVjdXRlL2ludGVycnVwdFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3Byb2plY3QvZXhlY3V0ZS9jb25zb2xlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9leGVjdXRlL2hpc3RvcnlcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2V4ZWN1dGUvZmx1c2hcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2V4ZWN1dGUvcmVzdWx0L2xpc3RcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2V4ZWN1dGUvcmVzdWx0L2Rvd25sb2FkXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9leGVjdXRlL3Jlc3VsdC9kZWxldGVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L3dvcmtzcGFjZS9saXN0XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC93b3Jrc3BhY2UvZ2V0XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC93b3Jrc3BhY2UvdXBsb2FkXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiLFxuICAgICAgICBcInVwbG9hZFwiOiB0cnVlXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC93b3Jrc3BhY2UvdHJhbnNmZXJcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L3dvcmtzcGFjZS9wdXNoXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC93b3Jrc3BhY2Uvc2F2ZVwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3Byb2plY3Qvd29ya3NwYWNlL3N0b3JlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC93b3Jrc3BhY2UvbG9hZFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3Byb2plY3Qvd29ya3NwYWNlL2RlbGV0ZVwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3Byb2plY3QvZGlyZWN0b3J5L2xpc3RcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2RpcmVjdG9yeS91cGxvYWRcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCIsXG4gICAgICAgIFwidXBsb2FkXCI6IHRydWVcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2RpcmVjdG9yeS90cmFuc2ZlclwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3Byb2plY3QvZGlyZWN0b3J5L3dyaXRlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9kaXJlY3RvcnkvdXBkYXRlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9kaXJlY3Rvcnkvc3RvcmVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2RpcmVjdG9yeS9sb2FkXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcHJvamVjdC9kaXJlY3RvcnkvZG93bmxvYWRcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L2RpcmVjdG9yeS9kZWxldGVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L3BhY2thZ2UvbGlzdFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3Byb2plY3QvcGFja2FnZS9hdHRhY2hcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9wcm9qZWN0L3BhY2thZ2UvZGV0YWNoXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3Ivam9iL2xpc3RcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9qb2Ivc3VibWl0XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3Ivam9iL3NjaGVkdWxlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3Ivam9iL3F1ZXJ5XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3Ivam9iL2NhbmNlbFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL2pvYi9kZWxldGVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L2RpcmVjdG9yeS9saXN0XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcmVwb3NpdG9yeS9kaXJlY3RvcnkvY3JlYXRlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcmVwb3NpdG9yeS9kaXJlY3RvcnkvcmVuYW1lXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcmVwb3NpdG9yeS9kaXJlY3RvcnkvY29weVwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvZGlyZWN0b3J5L21vdmVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L2RpcmVjdG9yeS91cGRhdGVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L3NjcmlwdC9saXN0XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcmVwb3NpdG9yeS9zY3JpcHQvZXhlY3V0ZVwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvc2NyaXB0L3JlbmRlclwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvc2NyaXB0L2ludGVycnVwdFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvc2hlbGwvZXhlY3V0ZVwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvZGlyZWN0b3J5L2FyY2hpdmVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L2RpcmVjdG9yeS91cGxvYWRcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCIsXG4gICAgICAgIFwidXBsb2FkXCI6IHRydWVcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L2RpcmVjdG9yeS9kb3dubG9hZFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvZGlyZWN0b3J5L2RlbGV0ZVwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvZmlsZS9saXN0XCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcmVwb3NpdG9yeS9maWxlL2ZldGNoXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcmVwb3NpdG9yeS9maWxlL2ZldGNoXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcmVwb3NpdG9yeS9maWxlL3VwbG9hZFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIixcbiAgICAgICAgXCJ1cGxvYWRcIjogdHJ1ZVxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvZmlsZS90cmFuc2ZlclwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvZmlsZS93cml0ZVwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvZmlsZS91cGRhdGVcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L2ZpbGUvZGlmZlwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3JlcG9zaXRvcnkvZmlsZS9yZXZlcnRcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L2ZpbGUvZ3JhbnRcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L2ZpbGUvZG93bmxvYWRcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L2ZpbGUvZGVsZXRlXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCIsXG4gICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgfSxcblxuICAgIFwiL3IvcmVwb3NpdG9yeS9maWxlL2NvcHlcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9LFxuXG4gICAgXCIvci9yZXBvc2l0b3J5L2ZpbGUvbW92ZVwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgIH0sXG5cbiAgICBcIi9yL3NlcnZlci9pbmZvXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICB9XG59XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyohXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNSBieSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgdGVybXMgb2YgVmVyc2lvbiAyLjAgb2YgdGhlXG4gKiBBcGFjaGUgTGljZW5zZS4gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIFdJVEhPVVRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVFksIElOQ0xVRElORyBUSE9TRSBPRiBOT04tSU5GUklOR0VNRU5ULFxuICogTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBQbGVhc2UgcmVmZXIgdG8gdGhlXG4gKiBBcGFjaGUgTGljZW5zZSAyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCkgZm9yIG1vcmUgXG4gKiBkZXRhaWxzLlxuICovXG5cbnZhciB3aW4gICAgICAgICA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyksICAgXG4gICAgcmVxdWVzdCAgICAgPSByZXF1aXJlKCdzdXBlcmFnZW50JyksXG4gICAgRCAgICAgICAgICAgPSByZXF1aXJlKCdkLmpzJyksXG4gICAgZnMgICAgICAgICAgPSByZXF1aXJlKCdmcycpLFxuICAgIGFwaXMgICAgICAgID0gcmVxdWlyZSgnLi9hcGlzLmpzb24nKSwgXG4gICAgRXZlbnRTdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9lcycpLFxuICAgIHV0aWxzICAgICAgID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKSxcbiAgICBMYW5nICAgICAgICA9IHJlcXVpcmUoJy4vbGliL2xhbmcnKSwgICBcbiAgICBMb2dnZXIgICAgICA9IHJlcXVpcmUoJy4vbGliL2xvZ2dlcicpLCAgIFxuICAgIFF1ZXVlICAgICAgID0gcmVxdWlyZSgnLi9saWIvcXVldWUnKSxcbiAgICBFbWl0dGVyICAgICA9IHJlcXVpcmUoJy4vbGliL2VtaXR0ZXInKSxcbiAgICBlbmNvZGVyICAgICA9IHJlcXVpcmUoJy4vbGliL2VuY29kZXInKSxcbiAgICBCYXNlICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3NlbGZpc2gnKS5CYXNlLFxuICAgIFJJbnB1dCAgICAgID0gcmVxdWlyZSgnLi9saWIvcmlucHV0JyksICAgIFxuICAgIFJJbnB1dHMgICAgID0gcmVxdWlyZSgnLi9saWIvcmlucHV0cycpLFxuICAgIG1lcmdlICAgICAgID0gdXRpbHMubWVyZ2U7XG5cbi8qXG4gKiBUdXJuIGdsb2JhbCBsb2dnaW5nIG9mZiBieSBkZWZhdWx0XG4gKi9cbkxvZ2dlci5zZXRMZXZlbChMb2dnZXIuT0ZGKTtcblxuLypcbiAqIEdsb2JhbCBvcHRpb25zIHRoYXQgcGVyc2lzdCB0aHJvdWdoIGFsbCBEZXBsb3lSIHJlcXVlc3RzLlxuICovXG52YXIgZ2xvYmFsT3B0aW9ucyA9IHsgXG4gIGNvcnM6IGZhbHNlLFxuICBsb2dnaW5nOiBmYWxzZSxcbiAgc3RpY2t5OiBmYWxzZSxcbiAgY29va2llczogbnVsbCxcbiAgaG9zdDogJycsXG4gIGFsbG93U2VsZlNpZ25lZFNTTENlcnQ6IGZhbHNlLFxuICBtYXhSZXF1ZXN0czogbnVsbCwgLy8gbm8gc29ja2V0IHBvb2xpbmcgaW4gaHR0cC5BZ2VudFxuICBldmVudHM6e30sXG4gIHNldDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHsgXG4gICAgaWYgKHByb3AgIT09ICdzZXQnKSB7IFxuICAgICAgaWYgKHByb3AgPT09ICdob3N0JyAmJiB2YWx1ZSkgeyAgICAgICAgIFxuICAgICAgICAgLy8gQmUgbW9yZSBmb3JnaXZpbmcgb24gdGhlIGVudGVyZWQgRGVwbG95UiAnZW5kcG9pbnQnOlxuICAgICAgICAgLy8gICAtIGh0dHAocyk6Ly9kaG9zdDpwb3J0XG4gICAgICAgICAvLyAgIC0gaHR0cChzKTovL2Rob3N0OnBvcnQvZGVwbG95clxuICAgICAgICAgLy8gICAtIGRob3N0OnBvcnRcbiAgICAgICAgIC8vICAgLSBkaG9zdDpwb3J0L2RlcGxveXIgICAgICAgICBcbiAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwvKiR8XFwvKmRlcGxveXJcXC8qJC8sICcnKTtcbiAgICAgICAgIHZhbHVlID0gKG5ldyBSZWdFeHAoJ14oaHR0cHxodHRwcyk6Ly8nLCAnaScpKS50ZXN0KHZhbHVlKSA/IHZhbHVlIDogXG4gICAgICAgICAgICAnaHR0cDovLycgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpc1twcm9wXSA9IHZhbHVlOyBcbiAgICB9IFxuICB9XG59O1xuXG4vKlxuICogVGhlIHRvcC1sZXZlbCBEZXBsb3lSIEFQSSByZXNwb25zZSBlbnRpdGllcy5cbiAqL1xudmFyIFRPUExFVkVMX0VOVElUSUVTID0gW1xuICAndXNlcicsIFxuICAncHJvamVjdCcsIFxuICAnd29ya3NwYWNlJywgXG4gICdleGVjdXRpb24nLCBcbiAgJ2RpcmVjdG9yeScsIFxuICAncmVwb3NpdG9yeScsIFxuICAncGFja2FnZXMnIFxuXTtcblxuLypcbiAqIE5vdGlmeSBnbG9iYWwgSU8gZXJyb3IgZXZlbnRzIGFjY2Vzc2libGUgYnkgYWxsIHN1YnNjcmliZXJzIGFjcm9zcyByZXF1ZXN0cy5cbiAqL1xuZnVuY3Rpb24gcmFpc2VHbG9iYWxFcnJvcnMoYXBpLCByZXMpIHtcbiAgdmFyIGNvZGUgICAgPSByZXMuZGVwbG95ciA/IHJlcy5kZXBsb3lyLnJlc3BvbnNlLmVycm9yQ29kZSA6IHJlcy5zdGF0dXMsXG4gICAgICBjb250ZXh0ID0gdGhpcztcblxuICAvLyAtLSBnbG9iYWwgZXZlbnRzIGlmIHByb3ZpZGVkIC0tXG4gIGlmIChnbG9iYWxPcHRpb25zLmV2ZW50cykge1xuICAgIGlmICghcmVzLmRlcGxveXIpIHtcbiAgICAgIHJlcyA9IHJlcy50ZXh0O1xuICAgIH1cblxuICAgIGNvbnRleHQgPSBnbG9iYWxPcHRpb25zLmV2ZW50cy5jdHggfHwgY29udGV4dDtcblxuICAgIC8vIC0tIGdlbmVyYWwgZ2xvYmFsIGZhaWx1cmUgLS1cbiAgICBpZiAoZ2xvYmFsT3B0aW9ucy5ldmVudHMuZXJyb3IpIHtcbiAgICAgIGdsb2JhbE9wdGlvbnMuZXZlbnRzLmVycm9yLmFwcGx5KGNvbnRleHQsIFthcGksIHJlc10pO1xuICAgIH1cblxuICAgIC8vIC0tIEhUVFAgb3IgRGVwbG95UiBnbG9iYWwgZXJyb3JzIC0tICAgIFxuICAgIGlmIChnbG9iYWxPcHRpb25zLmV2ZW50c1tjb2RlXSkge1xuICAgICAgZ2xvYmFsT3B0aW9ucy5ldmVudHNbY29kZV0uYXBwbHkoY29udGV4dCwgW2FwaSwgcmVzXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhlIGBEZXBsb3lSYCByZXF1ZXN0IGNsYXNzIGlzIGEgdXRpbGl0eSB0aGF0IGJyb2tlcnMgSFRUUCByZXF1ZXN0cyB0aHJvdWdoIGEgXG4gKiBzaW1wbGlmaWVkIGZsdWlkIGludGVyZmFjZSB0byBEZXBsb3lSLlxuICpcbiAqIEBtb2R1bGUgZGVwbG95clxuICogQGZvciBkZXBsb3lyXG4gKi9cbnZhciBEZXBsb3lSID0gQmFzZS5leHRlbmQoRW1pdHRlciwgUklucHV0cywge1xuXG4gIC8qKlxuICAgKiBUaGUgYERlcGxveVJgIFJlcXVlc3QgY2xhc3MgaXMgYSB1dGlsaXR5IHRoYXQgYnJva2VycyBIVFRQIHJlcXVlc3RzIHRocm91Z2ggXG4gICAqIGEgc2ltcGxpZmllZCBmbHVpZCBpbnRlcmZhY2UgdG8gRGVwbG95Ui5cbiAgICogXG4gICAqIEBjbGFzcyBcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhcGkgVGhlIERlcGxveVIgQVBJXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsaW5rIFRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIHRoZSBwcmV2aW91cyByZXF1ZXN0LlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoYXBpLCBsaW5rKSB7XG4gICAgIEVtaXR0ZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHt9KTtcbiAgXG4gICAgIHZhciBvcHRzID0gZ2xvYmFsT3B0aW9ucztcblxuICAgICBpZiAoIWFwaXNbYXBpXSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQVBJIFwiJyArIGFwaSArICdcIicpOyB9XG4gICAgXG4gICAgIHRoaXMuYXBpICAgICAgICA9IG1lcmdlKHsgJ2NhbGwnOiBhcGkgfSwgYXBpc1thcGldKTsgICAgXG4gICAgIHRoaXMubGluayAgICAgICA9IGxpbmsgfHwge307XG4gICAgIHRoaXMucSAgICAgICAgICA9IHRoaXMubGluay5xdWV1ZSB8fCBuZXcgUXVldWUoKTtcbiAgICAgdGhpcy5kZWZlcnJlZCAgID0gdGhpcy5saW5rLmRlZmVycmVkIHx8IEQoKTtcbiAgICAgdGhpcy5jb29raWVzICAgID0gdGhpcy5saW5rLmNvb2tpZXM7XG4gICAgIHRoaXMubG9nZ2VyICAgICA9IExvZ2dlci5nZXQoYXBpLCBMb2dnZXIuT0ZGKTsgLy8gdHJhbnNhY3Rpb24tbGV2ZWwgbG9nZ2luZ1xuICAgICB0aGlzLnBhcmFtcyAgICAgPSB7fTtcbiAgICAgdGhpcy5pbnB1dHMgICAgID0gW107IC8vIHJpbnB1dHMgbGlzdCBcbiAgICAgdGhpcy5vdXRwdXRzICAgID0gW107IC8vIHJvdXRwdXQgb2JqZWN0IGxpc3RcbiAgICAgdGhpcy5yc3RyZWFtICAgID0gZmFsc2U7XG4gICAgIHRoaXMuZGVsYXllZCAgICA9IGZhbHNlO1xuICAgICB0aGlzLmdsb2JhbEV2dHMgPSB0cnVlOyAvLyBzdXBwcmVzc3xyYWlzZSBnbG9iYWwgZXZlbnRzIGZvdCB0aGlzIGBpb2AgICAgIFxuICAgICB0aGlzLmZpbGUgICAgICAgPSBudWxsOyBcbiAgICAgdGhpcy5maWx0ZXIgICAgID0gbnVsbDsgXG5cbiAgICAgLy8gcHJlc2V0IGRlcGxveXIncyBhc3NpZ25lZCByZXNwb25zZSBmb3JtYXQgZm9yIGB0aGlzYCBhcGlcbiAgICAgdGhpcy5kYXRhKHsgZm9ybWF0OiB0aGlzLmFwaS5mb3JtYXQgfSk7XG5cbiAgICAgLy8gd3JhcCBzdXBlcmFnZW50IGZvciB0aGUgaGVhdnkgbGlmdGluZyAgICAgXG4gICAgIHRoaXMucmVxID0gXG4gICAgICAgIHJlcXVlc3RbdGhpcy5hcGkubWV0aG9kLnRvTG93ZXJDYXNlKCldKG9wdHMuaG9zdCArICcvZGVwbG95cicgKyBhcGkpO1xuICAgICB0aGlzLnJlcS50aW1lb3V0KDIwICogNjAgKiAxMDAwKTsgLy8gZGVmYXVsdCB0aW1lb3V0IC0tPiAyMCBtaW51dGVzXG5cbiAgICAgLy8gQWxsIENPUlMgZGVwbG95ciBjYWxscyByZXF1aXJlIHN0aWNreSBzZXNzaW9uc1xuICAgICBpZiAod2luICYmIGdsb2JhbE9wdGlvbnMuY29ycykgeyB0aGlzLnJlcS53aXRoQ3JlZGVudGlhbHMoKTsgfVxuXG4gICAgIC8vIE5vZGUuanMgLSBhY2Nlc3MgYW4gU1NMIGVuZHBvaW50IHdpdGggc2VsZiBzaWduZWQgY2VydHMgZm9yIHRlc3Rpbmd8ZGV2XG4gICAgIGlmICghd2luICYmIGdsb2JhbE9wdGlvbnMuYWxsb3dTZWxmU2lnbmVkU1NMQ2VydCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX1RMU19SRUpFQ1RfVU5BVVRIT1JJWkVEID0gJzAnOyAgICAgICAgXG4gICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQmluZHMgdGhlIHNjb3BlIGNvbnRleHQgZm9yIHRoZSBjb25maWd1cmVkIGAuZW5kKClgIGFuZCBgLmVycm9yKClgIGV2ZW50ICAgIFxuICAgKiBoYW5kbGVyIGNhbGxiYWNrcyBvbiB0aGlzIHJlcXVlc3QuXG4gICAqXG4gICAqIEBtZXRob2QgY3R4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBgdGhpc2Agb2JqZWN0IGZvciB0aGUgY29uZmlndXJlZCBgLmVuZCgpYCBhbmRcbiAgICogYC5lcnJvcigpYCBldmVudCBoYW5kbGVycyBvbiB0aGlzIHJlcXVlc3QuXG4gICAqIEBhcGkgcHVibGljICAgXG4gICAqLyBcbiAgY3R4OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHRoaXMuc2NvcGUgPSBjb250ZXh0IHx8IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU3VwcHJlc3Mgb3IgcmFpc2UgZ2xvYmFsIGV2ZW50cyBmb3IgdGhpcyBgaW9gIHJlcXVlc3QuXG4gICAqXG4gICAqIEBtZXRob2QgZ2xvYmFsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmFpc2UgYHRydWVgIHRvIHJhaXNlIGdsb2JhbCBldmVudHMsIGBmYWxzZWAgdG8gc3VwcmVzcyBcbiAgICogZXZlbnQgZmlyaW5nIGdsb2JhbGx5LlxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqLyAgXG4gIGdsb2JhbDogZnVuY3Rpb24ocmFpc2UpIHtcbiAgICB0aGlzLmdsb2JhbEV2dHMgPSBMYW5nLmlzQm9vbGVhbihyYWlzZSkgPyByYWlzZSA6IHRoaXMuZ2xvYmFsRXZ0cztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LCAgXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGRldGFpbHMgYWJvdXQgdXNlci5cbiAgICogICBcbiAgICogQG1ldGhvZCBhYm91dFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGRldGFpbHMgYWJvdXQgdXNlciBvdGhlcndpZXMgYG51bGxgLlxuICAgKiBAYXBpIHB1YmxpYyAgIFxuICAgKi9cbiAgYWJvdXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IHRoaXMucmVxLnJlcztcblxuICAgIHJldHVybiB0aGlzLmFwaVsnY2FsbCddID09PSAnL3IvdXNlci9sb2dpbicgJiYgcmVzcG9uc2UgPyBcbiAgICAgICAgICAgcmVzcG9uc2UuYm9keS5nZXQoJ3VzZXInKSA6IG51bGw7XG4gIH0sICBcblxuICAvKipcbiAgICogU2hhcmVzIHRoZSBjb29raWVzIGZyb20gYSBkaWZmcmVudCBgLmlvKClgIGFnZW50IHRvIHByZXNlcnZlIHNlc3Npb24gc3RhdGVcbiAgICogYWNyb3NzIGB0aGlzYCByZXF1ZXN0IGFuZCBhbGwgcmVxdWVzdHMgY2hhaW5lZCB0byBpdC5cbiAgICpcbiAgICogQG1ldGhvZCBzaGFyZVxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljICAgXG4gICAqLyAgXG4gIHNoYXJlOiBmdW5jdGlvbiAoY29va2llcykge1xuICAgIGlmIChnbG9iYWxPcHRpb25zLnN0aWNreSkge1xuICAgICAgaWYgKGdsb2JhbE9wdGlvbnMuY29va2llcykge1xuICAgICAgICB0aGlzLmNvb2tpZXMgPSBnbG9iYWxPcHRpb25zLmNvb2tpZXMuc2xpY2UoMCk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvb2tpZXMpIHsgXG4gICAgICAgICAgdGhpcy5jb29raWVzID0gY29va2llcy5zbGljZSgwKTsgXG4gICAgICAgICAgZ2xvYmFsT3B0aW9ucy5zZXQoJ2Nvb2tpZXMnLCB0aGlzLmNvb2tpZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29va2llcyA9IChjb29raWVzID8gY29va2llcy5zbGljZSgwKSA6IHRoaXMuY29va2llcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEhUVFAgY29va2llIHByZXZpb3VzbHkgc2VudCBieSB0aGUgc2VydmVyIHdpdGggU2V0LUNvb2tpZS5cbiAgICogVGhpcyB2YWx1ZSBjYW4gYmUgcGFzc2VkIHRvIGAuc2hhcmUocnVzZXIuZ2V0Q29va2llcygpKWAgb2YgYSBkaWZmcmVudFxuICAgKiBgLmlvKClgIGFnZW50IHRvIHByZXNlcnZlIHNlc3Npb24gc3RhdGUgYWNyb3NzIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAbWV0aG9kIGdldENvb2tpZXNcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBIVFRQIGNvb2tpZSBwcmV2aW91c2x5IHNlbnQgYnkgdGhlIHNlcnZlciB3aXRoIFxuICAgKiBTZXQtQ29va2llLlxuICAgKiBAYXBpIHB1YmxpYyAgIFxuICAgKi8gIFxuICBnZXRDb29raWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29va2llcztcbiAgfSwgXG5cbiAgZGVsYXk6IGZ1bmN0aW9uIChtcykge1xuICAgIC8vIFRPRE86IHN1cHBvcnQgZGVsYXllZCByZXF1ZXN0cyBiYXNlZCBvbiBtcyBmb3Igbm93IHRoaXMgaXMganVzdCBhIHBhdXNlLlxuICAgIHRoaXMuZGVsYXllZCA9ICFpc05hTihwYXJzZUZsb2F0KG1zKSkgJiYgaXNGaW5pdGUobXMpID8gbXMgOiB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sICAgXG5cbiAgLyoqXG4gICAqIFVud2luZCB0aGUgcXVldWUgY2hhaW4gY2xlYXJpbmcgcmVxdWVzdHMgdGhhdCBtaWdodCBoYXZlIGRlbGF5cyBhdHRhY2hlZC5cbiAgICpcbiAgICogQG1ldGhvZCBkcmFpblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2Ugd3JhcHBpbmcgdGhlIHJlc29sdXRpb24gb2YgZWl0aGVyIFwicmVzb2x2ZVwiIG9yXG4gICAqIFwicmVqZWN0XCIgY2FsbGJhY2suXG4gICAqIEBhcGkgcHVibGljICAgXG4gICAqL1xuICBkcmFpbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVsYXllZCA9IGZhbHNlO1xuICAgIHRoaXMucS5mbHVzaCgpOyBcblxuICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnByb21pc2U7XG4gIH0sICAgXG5cbiAgLyoqXG4gICAqIFRoZSBgLnByb21pc2UoKWAgbWV0aG9kIHJldHVybnMgYSBkeW5hbWljYWxseSBnZW5lcmF0ZWQgUHJvbWlzZSB0aGF0IGlzIFxuICAgKiByZXNvbHZlZCBvbmNlIGFsbCBEZXBsb3lSIGAuaW8oKWAgcmVxdWVzdHMgaGF2ZSBlbmRlZC5cbiAgICogICBcbiAgICogQG1ldGhvZCBwcm9taXNlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB3cmFwcGluZyB0aGUgcmVzb2x1dGlvbiBvZiBlaXRoZXIgXCJyZXNvbHZlXCIgb3JcbiAgICogXCJyZWplY3RcIiBjYWxsYmFjay5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovICAgICBcbiAgcHJvbWlzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5kKCk7XG5cbiAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBYm9ydCB0aGUgRGVwbG95UiByZXF1ZXN0LlxuICAgKlxuICAgKiBAbWV0aG9kIGFib3J0ICBcbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nLlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi8gIFxuICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVxLmFib3J0KCk7XG4gICAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KHRoaXMuX2hhbmRsZUVycm9yKHsgXG4gICAgICAgIHN0YXR1czogJ2Fib3J0JyxcbiAgICAgICAgdGV4dDogJ0RlcGxveVIgcmVxdWVzdCBhYm9ydGVkLidcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuIC8qKlxuICAqIFNldCB0aW1lb3V0IHRvIGBtc2AuXG4gICpcbiAgKiBAbWV0aG9kIHRpbWVvdXQgIFxuICAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZ1xuICAqIEBhcGkgcHVibGljXG4gICovICBcbiAgdGltZW91dDogZnVuY3Rpb24gKG1zKSB7XG4gICAgdGhpcy5yZXEudGltZW91dChtcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuIC8qKlxuICAqIFR1cm4gbG9nZ2luZyBvbiBmb3IgdGhlIHNwZWNpZmljIHRyYW5zYWN0aW9uLlxuICAqXG4gICogQG1ldGhvZCBsb2dcbiAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmdcbiAgKiBAYXBpIHB1YmxpY1xuICAqLyBcbiAgbG9nOiBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICB0aGlzLmxvZ2dlci5zZXRMZXZlbChsZXZlbCB8fCBMb2dnZXIuREVCVUcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgc3VjY2Vzc2Z1bCByZXNwb25zZXMgdG8gY29udGFpbiBvbmx5IGEgdG9wLWxldmVsIERlcGxveVIgQVBJIFxuICAgKiByZXNwb25zZSBlbnRpdGllczpcbiAgICogLSAndXNlcidcbiAgICogLSAncHJvamVjdCdcbiAgICogLSAnd29ya3NwYWNlJyBcbiAgICogLSAnZXhlY3V0aW9uJyBcbiAgICogLSAnZGlyZWN0b3J5JyBcbiAgICogLSAncmVwb3NpdG9yeSdcbiAgICogLSAncGFja2FnZXMnIFxuICAgKiAgIFxuICAgKiBAbWV0aG9kIGVudGl0eVxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGVudGl0eTogZnVuY3Rpb24gKGVudGl0eSkge1xuICAgIHRoaXMuZmlsdGVyID0gdXRpbHMuaW5BcnJheShUT1BMRVZFTF9FTlRJVElFUywgZW50aXR5KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSByZXF1ZXN0IGRhdGEgYmVpbmcgc2VudCB0byBhIERlcGxveVIgQVBJLiBcbiAgICpcbiAgICogQG1ldGhvZCBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBvYmplY3QgbGl0ZXJhbCBjb25maWd1cmF0aW9uIGhhc2guIFxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGRhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307ICAgIFxuXG4gICAgLy8gcmVtb3ZlIGFueSBpbmxpbmVkIHJpbnB1dChzKSBhbmQgYXR0YWNoIHRoZW0gdG8gdGhlIHJpbnB1dChzKSBwcm9wZXJ0eVxuICAgIGlmIChkYXRhLnJpbnB1dCB8fCBkYXRhLnJpbnB1dHMpIHtcbiAgICAgIHRoaXMucmlucHV0KGRhdGEucmlucHV0KTtcbiAgICAgIHRoaXMucmlucHV0cyhkYXRhLnJpbnB1dHMpO1xuICAgIH0gXG5cbiAgICAvLyByZW1vdmUgYW55IGByZXNlcnZlZGAgdmFsdWVzIHRoYXQgY291bGQgaGF2ZSBiZWVuIHBhc3NlZCBieSBtaXN0YWtlXG4gICAgdmFyIEJMQUNLTElTVCA9IFsncmlucHV0JywgJ3JpbnB1dHMnLCAnX19jb29raWVzX18nXTtcbiAgICBCTEFDS0xJU1QuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkgeyBkZWxldGUgZGF0YVtwYXJhbV07IH0pOyAgXG5cbiAgICB0aGlzLnBhcmFtcyA9IG1lcmdlKHRoaXMucGFyYW1zLCBkYXRhKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhIGZpbGUgdG8gYmUgdXBsb2FkZWQuIFxuICAgKlxuICAgKiBAbWV0aG9kIGF0dGFjaFxuICAgKiBAcGFyYW0ge0ZpbGV8QmxvYnxwYXRofSBmaWxlIFRoZSBmaWxlIHRvIGJlIGF0dGFjaGVkIGZvciBhbiB1cGxvYWQuIEZvciBcbiAgICogQnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIEhUTUw1IEZpbGV8QmxvYiBpcyB1c2VkLiBGb3IgdGhlIE5vZGUuanMgXG4gICAqIGVudmlyb25tZW50LCBhIGZpbGUgcGF0aCBpcyBhY2NlcHRlZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWQuIFxuICAgKiBUaGlzIG5hbWUgZG9lcyBub3QgaGF2ZSB0byBtYXRjaCB0aGUgYWN0dWFsIHNvdXJjZSBmaWxlbmFtZS5cbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBhdHRhY2g6IGZ1bmN0aW9uIChmaWxlLCBmaWxlbmFtZSkge1xuICAgIGlmICh0aGlzLmFwaS51cGxvYWQpIHtcbiAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG5cbiAgICAgIC8vIG9wdGlvbmFsIGZpbGVuYW1lIGhlcmUgZm9yIGNvbnZlbmllbmNlXG4gICAgICBpZiAoZmlsZW5hbWUpIHsgdGhpcy5kYXRhKCB7IGZpbGVuYW1lOiBmaWxlbmFtZSB9ICk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU3VwcG9ydGVkIG9ubHkgaW4gTm9kZS5qcywgdGhpcyBtZXRob2Qgd29ya3MgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgXG4gICAqIGF0dGFjaCBtZXRob2QgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZmlsZSBzaG91bGQgYmUgcmVhZCBpbiBhcyBhIHJlYWRhYmxlIFxuICAgKiBzdHJlYW0gZHVyaW5nIGEgZmlsZSB1cGxvYWQuXG4gICAqXG4gICAqIEBtZXRob2Qgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIChvcHRpb25hbCkgdGhlIFJlYWRhYmxlIFN0cmVhbSBvcHRpb25zIGhhc2guXG4gICAqICBgYGBcbiAgICogICAgeyBmbGFnczogJ3InLFxuICAgKiAgICAgIGVuY29kaW5nOiBudWxsLFxuICAgKiAgICAgIGZkOiBudWxsLFxuICAgKiAgICAgIG1vZGU6IDA2NjYsXG4gICAqICAgICAgYXV0b0Nsb3NlOiB0cnVlXG4gICAqICAgIH1cbiAgICogYGBgXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgc3RyZWFtOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yc3RyZWFtID0gKCF3aW4gJiYgdGhpcy5hcGkudXBsb2FkKTsgLy9ub2RlanMgb25seVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIFxuICAvKipcbiAgICogQWN0cyBhcyBhIGZpbmFsbHkgc3RhdGVtZW50IGFsbG93aW5nIHlvdSB0byBleGVjdXRlIFwiY2xlYW51cFwiIHR5cGUgdGFza3MgXG4gICAqIGluIGEgcmVxdWVzdCBjaGFpbi4gSXQgYXJyYW5nZXMgZm9yIGNsZWFudXAgdG8gYmUgY2FsbGVkLCB3aXRoIG5vIFxuICAgKiBhcmd1bWVudHMsIHdoZW4gdGhlIERlcGxveVIgcmVxdWVzdCBjaGFpbiBpcyBlaXRoZXIgY29tcGxldGVseSBmdWxmaWxsZWQgXG4gICAqIG9yIHJlamVjdGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIGVuc3VyZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSDOuyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi8gIFxuICBlbnN1cmU6IGZ1bmN0aW9uIChmbikge1xuICAgIHRoaXMuZGVmZXJyZWQucHJvbWlzZS5lbnN1cmUoZm4pO1xuXG4gICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQucHJvbWlzZTtcbiAgfSxcbiAgICAgIFxuICAvKipcbiAgICogVGhlIGdlbmVyYWwgZmFpbHVyZSBjYWxsYmFjay4gSWYgY2FsbGVkLCBhbGwgRGVwbG95UiBlcnJvcnMgZm9yIHRoaXMgXG4gICAqIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmV0dXJuZWQgaGVyZSB3aGVuIHJhaXNlZC5cbiAgICpcbiAgICogQG1ldGhvZCBlcnJvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSDOuyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZ1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgZXJyb3I6IGZ1bmN0aW9uIChmbikge1xuICAgIHRoaXMub24oJ2Vycm9yJywgZm4pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0cmVhbSB0aGUgRGVwbG95UiByZXNwb25zZSBpbnRvIHRoZSBwaXBlLiBJdCBpcyBpbXBvcnRhbnQgdG8gbm90ZSB0aGF0IGlmIFxuICAgKiB0aGUgYC5waXBlKClgIG1ldGhvZCBpcyBuZXZlciBjYWxsZWQgdGhlIHJlcXVlc3Qgd2lsbCBub3QgYmUgc2VudC5cbiAgICpcbiAgICogVGhlIGAucGlwZSgpYCBtZXRob2Qgc2hvdWxkIGJlIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gYC5lbmQoKWAgYW5kIFxuICAgKiBuZXZlciBhbG9uZyBzaWRlIG9mIGl0LiBgLnBpcGUoKWAgYW5kIGAuZW5kKClgIGFyZSBhbiBlaXRoZXItb3IuXG4gICAqXG4gICAqIEBtZXRob2QgcGlwZVxuICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIEEgZGVzdGluYXRpb24gU3RyZWFtLlxuICAgKiBAcmV0dXJuIHtTdHJlYW19IFRoZSBwYXNzZWQgaW4gZGVzdGluYXRpb24gc3RyZWFtIHRvIGJlIHVzZWQgZm9yIGFkZGl0aW9uYWwgXG4gICAqIHBpcGluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIHBpcGU6IGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgdmFyIHEgICA9IHRoaXMucSxcbiAgICAgICAgYXBpID0gdGhpcy5hcGk7ICAgICAgICBcblxuICAgIHEuYWRkKGZ1bmN0aW9uKHJlc3BvbnNlQ2hhaW4sIGVycm9yLCBwcmV2QXJncykgeyAgICBcbiAgICAgIC8vIGJyYWtlIHRoZSBjYWxsIGNoYWluIG9uIGVycm9yICAgICAgXG4gICAgICBpZiAoZXJyb3IpIHsgICAgICAgIFxuICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnJvcik7ICAgICAgXG4gICAgICAgIHEuZmx1c2gocmVzcG9uc2VDaGFpbiwgZXJyb3IsIHByZXZBcmdzKTsgLy8gZHJhaW4gdGhlIHF1ZXVlXG4gICAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5fcHJlcFJlcXVlc3QocmVzcG9uc2VDaGFpbiwgcHJldkFyZ3MpO1xuXG4gICAgICBMb2dnZXIuaW5mbygncGlwZSgpJywgYXBpLCB0aGlzLnJlcSk7XG4gICAgICB0aGlzLmxvZ2dlci5pbmZvKCdwaXBlKCknLCBhcGksIHRoaXMucmVxKTsgICBcblxuICAgICAgdmFyIHN0cmVhbSA9IHRoaXMucmVxLnBpcGUoZGVzdCk7XG4gICAgICBxLnlpZWxkKHRydWUpO1xuICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHsgfSk7ICAgIFxuICAgICAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHsgfSk7ICAgICBcbiAgICAgIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKCkgeyB9KTsgICAgICBcbiAgICB9LCB0aGlzKTtcbiAgXG4gICAgaWYgKHEuc2l6ZSgpIDw9IDEpIHsgcS5mbHVzaCgpOyB9XG5cbiAgICByZXR1cm4gZGVzdDtcbiAgfSxcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3QgaXMgcmVhZHkgdG8gYmUgc2VudCB0byBEZXBsb3lSLiBJdCBpcyBpbXBvcnRhbnQgXG4gICAqIHRvIG5vdGUgdGhhdCBpZiB0aGUgYC5lbmQoKWAgbWV0aG9kIGlzIG5ldmVyIGNhbGxlZCB0aGUgcmVxdWVzdCB3aWxsIG5vdCBiZVxuICAgKiBzZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIGVuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSDOuyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy5cbiAgICogQGFwaSBwdWJsaWNcbiAgICovIFxuICBlbmQ6IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBzZWxmICAgPSB0aGlzLFxuICAgICAgICBxICAgICAgPSB0aGlzLnEsXG4gICAgICAgIGFwaSAgICA9IHRoaXMuYXBpLFxuICAgICAgICBhcmdzICAgPSBudWxsLFxuICAgICAgICBlbnRpdHkgPSB0aGlzLmZpbHRlcjtcblxuICAgIHEuYWRkKGZ1bmN0aW9uKHJlc3BvbnNlQ2hhaW4sIGVycm9yLCBwcmV2QXJncykge1xuICAgICAgLy8gYnJlYWsgdGhlIGNhbGwgY2hhaW4gb24gZXJyb3IgICAgICBcbiAgICAgIGlmIChlcnJvcikgeyAgICAgICAgXG4gICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KGVycm9yKTsgICAgICAgIFxuICAgICAgICBxLmZsdXNoKHJlc3BvbnNlQ2hhaW4sIGVycm9yLCBwcmV2QXJncyk7IC8vIGRyYWluIHRoZSBxdWV1ZVxuICAgICAgICB0aGlzLl9jbGVhcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuX3ByZXBSZXF1ZXN0KHJlc3BvbnNlQ2hhaW4sIHByZXZBcmdzKTtcblxuICAgICAgTG9nZ2VyLmluZm8oJ2lvKCknLCBhcGksIHRoaXMucmVxKTtcbiAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ2lvKCknLCBhcGksIHRoaXMucmVxKTsgICAgXG5cbiAgICAgIHRoaXMucmVxLmVuZChmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgc2VsZi5zaGFyZShzZWxmLmNvb2tpZXMgfHwgcmVzLmhlYWRlcnNbJ3NldC1jb29raWUnXSk7ICAgICAgICAgXG5cbiAgICAgICAgLy8gLS0gbG9nIGNvb2tpZXMgYWNyb3NzIHJlcXVlc3RzIC0tXG4gICAgICAgIGlmIChzZWxmLmNvb2tpZXMpIHtcbiAgICAgICAgICBMb2dnZXIuaW5mbygnY29va2llcycsIGFwaSwgc2VsZi5jb29raWVzKTsgXG4gICAgICAgICAgc2VsZi5sb2dnZXIuaW5mbygnY29va2llcycsIGFwaSwgc2VsZi5jb29raWVzKTsgXG4gICAgICAgIH1cblxuICAgICAgICBlcnJvciA9IHNlbGYuX2hhbmRsZUVycm9yKHJlcyk7XG4gICAgICAgIHZhciBkcmVzID0gKHJlcy5ib2R5ICYmIHJlcy5ib2R5LmRlcGxveXIgPyByZXMuYm9keSA6IHJlcyk7ICAgICAgICAgICAgIFxuICAgICAgXG4gICAgICAgIHNlbGYuaW5wdXRzID0gW107XG4gICAgICAgIHNlbGYub3V0cHV0cyA9IFtdO1xuXG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgLy8gLS0gTG9nIGdsb2JhbCArIHRyYW5zYWN0aW9uIGxvZyAtLVxuICAgICAgICAgICBMb2dnZXIuaW5mbygnZW5kKCknLCBhcGksIGRyZXMsIHJlcyk7XG4gICAgICAgICAgIHNlbGYubG9nZ2VyLmluZm8oJ2VuZCgpJywgYXBpLCBkcmVzLCByZXMpO1xuXG4gICAgICAgICAgIC8vIC0tIHdhbGsgcmVzcG9uc2UgZm9yIHRvcC1sZXZlbCBlbnRpdHkgcmVzcG9uc2UgYXNzaWdubWVudCAtLSAgICAgICAgXG4gICAgICAgICAgIGlmIChlbnRpdHkpIHsgZHJlcyA9IGRyZXMuZGVwbG95ci5yZXNwb25zZVtlbnRpdHldIHx8IGRyZXM7IH1cblxuICAgICAgICAgICBkcmVzLmdldCA9IGZ1bmN0aW9uKGtleSkgeyBcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmdldChkcmVzLmRlcGxveXIucmVzcG9uc2UsIGtleSk7IFxuICAgICAgICAgICB9O1xuXG4gICAgICAgICAgIGRyZXMud29ya3NwYWNlID0gZnVuY3Rpb24obmFtZSkgeyBcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLndvcmtzcGFjZShkcmVzLmRlcGxveXIucmVzcG9uc2UsIG5hbWUpOyBcbiAgICAgICAgICAgfTtcblxuICAgICAgICAgICAvLyAtLSBjYWxsYmFjayAtLVxuICAgICAgICAgICBpZiAoZm4pIHsgYXJncyA9IGZuLmFwcGx5KHNlbGYuc2NvcGUsIFtkcmVzLCByZXNwb25zZUNoYWluXSk7fVxuXG4gICAgICAgICAgIC8vIC0tIG5vdGlmeSB0aGF0IHRoZSBxdWV1ZSBoYXMgYmVlbiBkcmFpbmVkLi4uIC0tXG4gICAgICAgICAgIGlmIChxLnNpemUoKSA9PT0gMCkgeyBcbiAgICAgICAgICAgICBzZWxmLl9jbGVhcigpO1xuICAgICAgICAgICAgIHNlbGYuZGVmZXJyZWQucmVzb2x2ZShyZXNwb25zZUNoYWluIHx8IGRyZXMpO1xuICAgICAgICAgICB9ICAgICAgICAgIFxuXG4gICAgICAgICAgIC8vIC0tIGluY2x1ZGUgY29va2llcyBpbiBuZXh0IHJlcXVlc3QgaW4gdGhlIHF1ZXVlIC0tXG4gICAgICAgICAgIGFyZ3MgPSBtZXJnZShhcmdzLCB7IF9fY29va2llc19fOiBzZWxmLmNvb2tpZXMgfSk7ICAgICAgICAgIFxuICAgICAgICB9ICAgICAgICBcblxuICAgICAgICBxLnlpZWxkKGZhbHNlKTtcbiAgICAgICAgcS5mbHVzaChkcmVzLCBlcnJvciwgYXJncyk7IC8vIHBhc3MgcmVzdWx0fGVycm9yfGFyZ3MgdG8gbmV4dCBcbiAgICAgIH0pO1xuXG4gICAgICBxLnlpZWxkKHRydWUpO1xuICAgIH0sIHRoaXMsIHRoaXMuZGVsYXllZCk7XG4gIFxuICAgIGlmICghdGhpcy5kZWxheWVkICYmIHEuc2l6ZSgpIDw9IDEpIHsgcS5mbHVzaCgpOyB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSwgXG5cbiAgLyoqIFxuICAgKiBBZGQgYW4gYWRkaXRpb25hbCBJTyByZXF1ZXN0IHRvIHRoZSBleHNpc3Rpbmcgc2VxdWVudGlhbCByZXF1ZXN0IGNoYWluLlxuICAgKlxuICAgKiBAbWV0aG9kIGlvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhcGkgT25lIG9mIHRoZSBzdXBwb3J0ZWQgRGVwbG95UiBBUElzLlxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmcuXG4gICAqIEBhcGkgcHVibGljXG4gICAqLyAgIFxuICBpbzogZnVuY3Rpb24gKGFwaSkgeyAgICBcbiAgICByZXR1cm4gRGVwbG95Ui5uZXcoYXBpLCB7IFxuICAgICAgY29va2llczogdGhpcy5jb29raWVzLCBcbiAgICAgIHF1ZXVlOiB0aGlzLnEsIFxuICAgICAgZGVmZXJyZWQ6IHRoaXMuZGVmZXJyZWRcbiAgICB9KTtcbiAgfSxcblxuICAvKiogXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBhZGRpbmcgYW4gYWRkaXRpb25hbCBzY3JpcHQgZXhlY3V0aW9uIHRvIHRoZSBcbiAgICogZXhzaXN0aW5nIHNlcXVlbnRpYWwgcmVxdWVzdCBjaGFpbi5cbiAgICpcbiAgICogQG1ldGhvZCBzY3JpcHRcbiAgICogQHBhcmFtIHtBcmd1bWVudHN9IEFyZ3VtZW50cyB0byBkZWZpbmUgdGhlIGZ1bGx5IHF1YWxpZmllZCBzY3JpcHQgZm9yIFxuICAgKiBleGVjdXRpb24uXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy4gICBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIHNjcmlwdDogZnVuY3Rpb24oKSB7XG4gICAgIHZhciBhcmdzID0gdXRpbHMuc2lnbmF0dXJlKGFyZ3VtZW50cyksXG4gICAgICAgICBvcHRzID0gYXJncy5vcHRzLFxuICAgICAgICAgYXBpICA9IGFyZ3MuYXBpLFxuICAgICAgICAgbGluayA9IHsgXG4gICAgICAgICAgY29va2llczogdGhpcy5jb29raWVzLCBcbiAgICAgICAgICBxdWV1ZTogdGhpcy5xLCBcbiAgICAgICAgICBkZWZlcnJlZDogdGhpcy5kZWZlcnJlZFxuICAgICAgICB9OyAgXG5cbiAgICAvLyBjb252ZW5pZW5jZSAtIGlmIHRoZSBwcm9qZWN0IGlzIGEgYm9vbGVuIGB0cnVlYCByYXRoZXIgdGhhbiBhIHBpZCwgZmlyc3RcbiAgICAvLyBjcmVhdGUgYSBuZXcgcHJvamVjdCBhbmQgdGhlbiBwcmVwYXJlIHRoZSBwcm9qZWN0IGFwaSBjYWxsIHRvIGV4ZWN1dGVcbiAgICBpZiAoYXJncy5jcmVhdGUpIHtcbiAgICAgIHJldHVybiBEZXBsb3lSLm5ldygnL3IvcHJvamVjdC9jcmVhdGUnLCBsaW5rKVxuICAgICAgICAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHByb2plY3Q6IHJlcy5nZXQoJ3Byb2plY3QnKS5wcm9qZWN0IH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgIC5pbyhhcGkpXG4gICAgICAgICAgICAgICAuZGF0YShvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIERlcGxveVIubmV3KGFwaSwgbGluaykuZGF0YShvcHRzKTtcbiAgICB9ICAgIFxuICB9LFxuXG4gIC8qKiBcbiAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFkZGluZyBhbiBhZGRpdGlvbmFsIHJlcG9zaXRvcnktbWFuYWdlZCBzaGVsbCBcbiAgICogc2NyaXB0IGV4ZWN1dGlvbiB0byB0aGUgZXhzaXN0aW5nIHNlcXVlbnRpYWwgcmVxdWVzdCBjaGFpbi5cbiAgICpcbiAgICogVGhpcyBjYWxsIGV4ZWN1dGVzIHJlcG9zaXRvcnktbWFuYWdlZCBzaGVsbCBzY3JpcHRzIC5zaCwgLmNzaCwgLmJhc2gsIC5iYXQgXG4gICAqIG9uIHRoZSBEZXBsb3lSIHNlcnZlci4gRHVlIHRvIHRoZSBzcGVjaWFsIHNlY3VyaXR5IGNvbmNlcm5zIGFzc29jaWF0ZWQgd2l0aCBcbiAgICogZXhjdXRpbmcgc2hlbGwgc2NyaXB0cyBvbiB0aGUgRGVwbG95UiBzZXJ2ZXIsIG9ubHkgc2hlbGwgc2NyaXB0cyBvd25lZCBieSBcbiAgICogX0FETUlOSVNUUkFUT1JfIHVzZXJzIGNhbiBiZSBleGVjdXRlZCBvbiB0aGlzIEFQSSBjYWxsLiBBbnkgYXR0ZW1wdCB0byBcbiAgICogZXhlY3V0ZSBhIHNoZWxsIHNjcmlwdCBzdG9yZWQgaW4gdGhlIHJlcG9zaXRvcnkgdGhhdCBpcyBub3Qgb3duZWQgYnkgYW4gXG4gICAqIF9BRE1JTklTVFJBVE9SXyB1c2VyIHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAqXG4gICAqIFRvIGV4ZWN1dGUgYSByZXBvc2l0b3J5LW1hbmFnZWQgc2hlbGwgc2NyaXB0IHRoZSBjYWxsZXIgbXVzdCBwcm92aWRlIFxuICAgKiBwYXJhbWV0ZXIgdmFsdWVzIGZvciBfYXV0aG9yXywgX2RpcmVjdG9yeV8sIF9maWxlbmFtZV8uIFRoaXMgY2FuIGJlXG4gICAqIGFjaGlldmVkIGJ5IHByb3ZpZGluZyBhIGZ1bGx5IHF1YWxpZmllZCBzaGVsbCBzY3JpcHQgXG4gICAqIGAvPGF1dGhvcj4vPGRpcmVjdG9yeT4vPGZpbGVuYW1lPmAsIGZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgYGBgXG4gICAqICAuc2hlbGwoJy9hZG1pbi9leHRlcm5hbDpwdWJsaWM6YWRtaW4vZWNoby5zaCcsICdlY2hvLnNoIGFyZ3MgdG8gcGFzcy4nKVxuICAgKiAgYGBgXG4gICAqXG4gICAqIEBtZXRob2Qgc2hlbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVwYXRoIHRvIGRlZmluZSB0aGUgZnVsbHkgcXVhbGlmaWVkIHNoZWxsIHNjcmlwdCBmb3JcbiAgICogZXhlY3V0aW9uLiBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFyZ3MgKG9wdGlvbmFsKSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIGludG8gdGhlIHNoZWxsIFxuICAgKiBzY3JpcHQgb24gZXhlY3V0aW9uLlxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmcuICAgXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBzaGVsbDogZnVuY3Rpb24ocGF0aCwgYXJncykgeyAgIFxuICAgIHZhciBsaW5rID0geyBcbiAgICAgICAgICBjb29raWVzOiB0aGlzLmNvb2tpZXMsIFxuICAgICAgICAgIHF1ZXVlOiB0aGlzLnEsIFxuICAgICAgICAgIGRlZmVycmVkOiB0aGlzLmRlZmVycmVkXG4gICAgICAgIH0sXG4gICAgICAgIHRva2VucyA9IExhbmcuaXNTdHJpbmcocGF0aCkgPyBwYXRoLnNwbGl0KCdcXC8nKSA6IFtdO1xuXG4gICAgLy8gaGFuZGxlIGJvdGg6IGAvYXV0aG9yL2RpcmVjdG9yeS9maWxlbmFtZWAgJiBgYXV0aG9yL2RpcmVjdG9yeS9maWxlbmFtZWBcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDMpIHsgdG9rZW5zID0gdG9rZW5zLnNsaWNlKDEpOyB9XG5cbiAgICByZXR1cm4gRGVwbG95Ui5uZXcoJy9yL3JlcG9zaXRvcnkvc2hlbGwvZXhlY3V0ZScsIGxpbmspLmRhdGEoe1xuICAgICAgYXV0aG9yOiB0b2tlbnNbMF0sXG4gICAgICBkaXJlY3Rvcnk6IHRva2Vuc1sxXSxcbiAgICAgIGZpbGVuYW1lOiB0b2tlbnNbMl0sXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqIFxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgZXhlY3V0aW5nIGEgYmxvY2sgb2YgUiBjb2RlIG9uIHRoZSBSIHNlc3Npb24uXG5cbiAgICogRXhhbXBsZTpcbiAgICogIGBgYFxuICAgKiAgLmNvZGUoJ3g8LTUnKVxuICAgKiAgLy8gLS0gb3IgLS1cbiAgICogIC5jb2RlKCd4PC01JywgcHJvamVjdElkKVxuICAgKiAgYGBgXG4gICAqICAgXG4gICAqIEBtZXRob2QgY29kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gciAtIFRoZSBibG9jayBvZiBSIGNvZGUgdG8gZXhlY3V0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb2plY3QgLSAob3B0aW9uYWwpIGlmIG9taXR0ZWQgYSBuZXcgcHJvamVjdCB3aWxsIGZpcnN0IGJlIFxuICAgKiBjcmVhdGVkIGFuZCB1c2VkLCBvdGhlcndpc2UgaXQgd2lsbCBleGVjdXRlIG9uIHRoZSBSIHNlc3Npb24gaWRlbnRpZmllZCBieSBcbiAgICogdGhpcyBgcHJvamVjdGAuXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy4gICBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGNvZGU6IGZ1bmN0aW9uKHIsIHByb2plY3QpIHtcbiAgICAgdmFyIGxpbmsgPSB7XG4gICAgICAgICAgICAgY29va2llczogdGhpcy5jb29raWVzLFxuICAgICAgICAgICAgIHF1ZXVlOiB0aGlzLnEsXG4gICAgICAgICAgICAgZGVmZXJyZWQ6IHRoaXMuZGVmZXJyZWRcbiAgICAgICAgIH0sXG4gICAgICAgICBhcGkgPSAnL3IvcHJvamVjdC9leGVjdXRlL2NvZGUnO1xuXG4gICAgIGlmICghcHJvamVjdCkge1xuICAgICAgICAgcmV0dXJuIERlcGxveVIubmV3KCcvci9wcm9qZWN0L2NyZWF0ZScsIGxpbmspXG4gICAgICAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvamVjdDogcmVzLmdldCgncHJvamVjdCcpLnByb2plY3QgfTtcbiAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgIC5pbyhhcGkpXG4gICAgICAgICAgICAgLmRhdGEoeyBjb2RlOiByIH0pO1xuICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIERlcGxveVIubmV3KGFwaSwgbGluaykuZGF0YSh7IGNvZGU6IHIsIHByb2plY3Q6IHByb2plY3QgfSk7XG4gICAgIH1cbiAgfSxcbiAgXG4gIC8qKiBcbiAgICogUmVsZWFzZSBhbnkgcmVzaWR1YWwgcHJvamVjdCByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHBsaWNhdGlvbiBcbiAgICogaW5zdGFuY2Ugd2hlbmV2ZXIgYSBjbGllbnQgYXBwbGljYXRpb24gdGVybWluYXRlcy4gVGhpcyBpbmNsdWRlcyBjbG9zaW5nIFxuICAgKiBhbnkgc3VwcGxpZWQgcHJvamVjdHMgZG93biBhbmQgbG9nZ2luZyBvdXQuXG4gICAqXG4gICAqIEBtZXRob2QgcmVsZWFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcHJvamVjdHMgVGhlIHByb2plY3Qgb3IgbGlzdCBvZiBwcm9qZWN0cyB0byBjbG9zZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhdXRoIChvcHRpb25hbCkgdG8gcmVtYWluIGF1dGhlbnRpY2F0ZWQuXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy4gICBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIHJlbGVhc2U6IGZ1bmN0aW9uKHByb2plY3RzLCBhdXRoKSB7XG4gICAgIHByb2plY3RzID0gTGFuZy5pc0FycmF5KHByb2plY3RzKSA/IHByb2plY3RzIDogW3Byb2plY3RzXTtcblxuICAgICB2YXIgc2VsZiAgICAgPSB0aGlzLFxuICAgICAgICAgZGVmZXJyZWQgPSBEKCksXG4gICAgICAgICBlbXB0eSAgICA9ICFwcm9qZWN0cyB8fCAhcHJvamVjdHNbMF0sXG4gICAgICAgICBjb3VudCAgICA9IDAsXG4gICAgICAgICBsYXN0ICAgICA9ICFlbXB0eSA/IHByb2plY3RzLmxlbmd0aCAtIDEgOiBjb3VudCxcbiAgICAgICAgIGNvb2tpZXMgID0gdGhpcy5nZXRDb29raWVzKCk7ICAgICAgICAgICBcblxuICAgIGZ1bmN0aW9uIGxvZ291dChpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSBsYXN0KSB7XG4gICAgICAgIGlmICghYXV0aCkge1xuICAgICAgICAgIERlcGxveVIubmV3KCcvci91c2VyL2xvZ291dCcpXG4gICAgICAgICAgLnNoYXJlKGNvb2tpZXMpXG4gICAgICAgICAgLmVycm9yKGZ1bmN0aW9uKCkgeyAgICAgICAgICBcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChmYWxzZSk7XG4gICAgICAgICAgfSkgICAgICBcbiAgICAgICAgICAuZW5kKGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZW5zdXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSBcbiAgICB9XG5cbiAgICBpZiAoIWVtcHR5KSB7XG4gICAgICBwcm9qZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKHByb2plY3QpIHtcbiAgICAgICAgRGVwbG95Ui5uZXcoJy9yL3Byb2plY3QvY2xvc2UnKVxuICAgICAgICAuZGF0YSh7IHByb2plY3Q6IHByb2plY3QgfSlcbiAgICAgICAgLnNoYXJlKGNvb2tpZXMpXG4gICAgICAgIC5lbmQoKVxuICAgICAgICAuZW5zdXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvZ291dChjb3VudCk7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSk7XG4gICAgICB9KTsgICBcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nb3V0KGNvdW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTsgIFxuICB9LCAgXG5cbiAgLyoqIFxuICAgKiBBIGNvbnZlbmllbmNlIGFsdGVybmF0aXZlIHRvIG11bHRpcGxlIGAucmlucHV0KClgIGNhbGxzLiBEZWZpbmVzIGEgbmFtZSBcbiAgICogbGlzdCBvZiBSIG9iamVjdHMgdGhhdCB3aWxsIGJlIHJldHVybmVkIGFzIERlcGxveVItZW5jb2RlZCBSIG9iamVjdHMgb24gdGhlIFxuICAgKiByZXNwb25zZSBtYXJrdXAuXG4gICAqXG4gICAqIENhbGxpbmcgdGhpcyBtZXRob2Qgfi5yb3V0cHV0cyhbIC4uLiBdKWAgaXMgZXF1aXZhbGVudCB0byBpbnZva2luZyBtdWx0aXBsZSBcbiAgICogYC5yb3V0cHV0KC4uLilgIGNhbGxzLlxuICAgKlxuICAgKiBAbWV0aG9kIHJvdXRwdXRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJvYmplY3RzIEEgbmFtZSBsaXN0IG9mIFIgb2JqZWN0cyB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IGZvciBjaGFpbmluZy4gICBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIHJvdXRwdXRzOiBmdW5jdGlvbiAocm91dHB1dHMpIHtcbiAgICBpZiAocm91dHB1dHMpIHsgdGhpcy5vdXRwdXRzID0gdGhpcy5vdXRwdXRzLmNvbmNhdChyb3V0cHV0cyk7IH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBcbiAgLyoqIFxuICAgKiBEZWZpbmVzIHRoZSBuYW1lIG9mIHRoZSBSIG9iamVjdCB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgYXMgYSBEZXBsb3lSLWVuY29kZWQgXG4gICAqIFIgb2JqZWN0IG9uIHRoZSByZXNwb25zZSBtYXJrdXAuXG4gICAqXG4gICAqIEBtZXRob2Qgcm91dHB1dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcm9iamVjdCBUaGUgbmFtZSBvZiB0aGUgUiBvYmplY3QgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBmb3IgY2hhaW5pbmcuICAgXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICByb3V0cHV0OiBmdW5jdGlvbiAocm91dHB1dCkge1xuICAgIGlmIChyb3V0cHV0KSB7IHRoaXMucm91dHB1dHMoW3JvdXRwdXRdKTsgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqIFxuICAgKiBVc2VkIHRvIHBhc3MgbXVsdGlwbGUgaW5wdXRzIGF0IG9uY2UgZnJvbSBKYXZhU2NyaXB0IHRvIGFuIFIgc2NyaXB0IHVzaW5nIFxuICAgKiBvbmUgb2YgdGhlIGRlZmluZWQgYFJJbnB1dGAgZmFjdG9yaWVzLlxuICAgKlxuICAgKiBAbWV0aG9kIHJpbnB1dHNcbiAgICogQHBhcmFtIHtBcnJheX0gcmlucHV0cyBUaGUgYFJJbnB1dGAgbGlzdCBvZiBEZXBsb3lSLXNwZWNpZmljIGVuY29kZWQgUiBcbiAgICogb2JqZWN0IGRhdGEgZm9yIHVzZSBvbiBhbiBBUEkgY2FsbC5cbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nLiAgIFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgcmlucHV0czogZnVuY3Rpb24gKHJpbnB1dHMpIHtcbiAgICBpZiAocmlucHV0cykgeyB0aGlzLmlucHV0cyA9IHRoaXMuaW5wdXRzLmNvbmNhdChyaW5wdXRzKTsgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqIFxuICAgKiBVc2VkIHRvIHBhc3MgbXVsdGlwbGUgaW5wdXRzIGF0IG9uY2UgZnJvbSBKYXZhU2NyaXB0IHRvIGFuIFIgc2NyaXB0IHVzaW5nIFxuICAgKiBvbmUgb2YgdGhlIGRlZmluZWQgYFJJbnB1dGAgZmFjdG9yaWVzLlxuICAgKlxuICAgKiBAbWV0aG9kIHJpbnB1dFxuICAgKiBAcGFyYW0ge1JJbnB1dH0gcmlucHV0IFRoZSBEZXBsb3lSLXNwZWNpZmljIGVuY29kZWQgUiBvYmplY3QgZGF0YSBmb3IgdXNlIFxuICAgKiBvbiBhbiBBUEkgY2FsbC4gICBcbiAgICogQHJldHVybiB7RGVwbG95Un0gZm9yIGNoYWluaW5nLiAgIFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgcmlucHV0OiBmdW5jdGlvbiAocmlucHV0KSB7XG4gICAgaWYgKHJpbnB1dCkgeyB0aGlzLmlucHV0cy5wdXNoKHJpbnB1dCk7IH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95IGxpZmVjeWNsZSBtZXRob2QuIEZpcmVzIHRoZSBgZGVzdHJveWAgZXZlbnQsIHByaW9yIHRvIGludm9raW5nIFxuICAgKiBkZXN0cnVjdG9ycyBmb3IgdGhlIGNsYXNzIGhpZXJhcmNoeS4gQ2FsbGVkIGludGVybmFsbHkgd2hlbiBgLnJlbGVhc2UoKWBcbiAgICogaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICogQGFwaSBwdWJsaWMgICBcbiAgICovXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgICB0aGlzLm9mZkFsbCgpO1xuICAgIFxuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkgeyBcbiAgICAgICAgICB0aGlzW2tleV0gPSBudWxsOyBcbiAgICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHt9XG4gIH0sICBcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBQcml2YXRlIG1ldGhvZHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBfY2xlYXI6IGZ1bmN0aW9uKCkgeyAgICBcbiAgICB0aGlzLnBhcmFtcyAgPSB7fTtcbiAgICB0aGlzLmlucHV0cyAgPSBbXTtcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICB0aGlzLnJzdHJlYW0gPSBmYWxzZTtcbiAgICB0aGlzLmRlbGF5ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFwaSAgICAgPSBudWxsOyAgICBcbiAgICB0aGlzLmZpbGUgICAgPSBudWxsOyAgXG4gICAgdGhpcy5maWx0ZXIgID0gbnVsbDtcbiAgfSwgXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBSZXF1ZXN0OiBmdW5jdGlvbiAocmVzcG9uc2VDaGFpbiwgYXJncykge1xuICAgIHZhciByZXEgID0gdGhpcy5yZXEsXG4gICAgICAgIGZpbGUgPSB0aGlzLmZpbGU7XG5cbiAgICAvLyBzZXQgdGhlIHJlcXVlc3QgdHlwZSAgICBcbiAgICBpZiAodGhpcy5hcGkudXBsb2FkKSB7XG4gICAgICAgLy8gSWYgdGhlIGVudiBpcyB0aGUgQnJvd3NlciB0aGVyZSBpcyBubyBuZWVkIHRvIG1hbnVhbGx5IHNldCB0aGVcbiAgICAgICAvLyBDb250ZW50LVR5cGUuIFRoZSBicm93c2VyIHdpbGwgYXV0b21hdGljYWxseSBzZXQgdGhlIFxuICAgICAgIC8vIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9Li4uXCIgdmFsdWUuIElmIHRoZSBlbnYgaXMgTm9kZSB3ZSBuZWVkXG4gICAgICAgLy8gdG8gc2V0IGl0IG1hbnVhbGx5LlxuICAgICAgIGlmICghd2luKSB7IHRoaXMucmVxLnR5cGUoJ211bHRpcGFydC9mb3JtLWRhdGEnKTsgfSAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxLnR5cGUoJ2Zvcm0nKTtcbiAgICB9ICAgIFxuXG4gICAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikgeyBcbiAgICAgIGVyciA9IGVyciB8fCB7ICBjb2RlOiAnVU5LTk9XTiBDT0RFJywgdGV4dDogJ1VOS05PV04gRVJST1InIH07XG5cbiAgICAgIHRoaXMuX2hhbmRsZUVycm9yKHsgXG4gICAgICAgIHN0YXR1czogZXJyLmNvZGUgfHwgJ1VOS05PV04gQ09ERScsXG4gICAgICAgIHRleHQ6IGVyclxuICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpKTsgICAgXG5cbiAgICB0aGlzLnNoYXJlKGFyZ3MgPyBhcmdzLl9fY29va2llc19fIDogbnVsbCk7XG5cbiAgICAvLyBhcmd1bWVudHMgcmV0dXJuZWQgZnJvbSBwcmV2IHJlcXVlc3QncyBpbygpLmVuZChmdW5jdGlvbigpIHsgcmV0dXJuIHg7IH0pXG4gICAgaWYgKGFyZ3MpIHsgXG4gICAgICAgdGhpcy5kYXRhKGFyZ3MpO1xuICAgIH0gXG5cbiAgICBpZiAodGhpcy5pbnB1dHMubGVuZ3RoID4gMCkgeyBcbiAgICAgIHRoaXMuZGF0YSh7IGlucHV0czogZW5jb2Rlci5lbmNvZGUodGhpcy5pbnB1dHMpIH0pOyBcbiAgICB9XG4gIFxuICAgIGlmICh0aGlzLm91dHB1dHMubGVuZ3RoID4gMCkgeyBcbiAgICAgIHRoaXMuZGF0YSh7IHJvYmplY3RzOiB0aGlzLm91dHB1dHMuam9pbigpIH0pOyBcbiAgICB9ICAgIFxuXG4gICAgaWYgKHRoaXMuY29va2llcykgeyAgICAgXG4gICAgICB0aGlzLmNvb2tpZXMuZm9yRWFjaCggZnVuY3Rpb24oYykgeyByZXEuc2V0KCdDb29raWUnLCBjKTsgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXBpLnVwbG9hZCkgeyAgICBcbiAgICAgIGZvcih2YXIgcCBpbiB0aGlzLnBhcmFtcykge1xuICAgICAgIHJlcS5maWVsZChwLCB0aGlzLnBhcmFtc1twXSA/IHRoaXMucGFyYW1zW3BdICsgJycgOiAnJyk7ICBcbiAgICAgIH0gXG4gICAgICByZXEuYXR0YWNoKCdmaWxlJywgdGhpcy5yc3RyZWFtID8gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlKSA6IGZpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXFbdGhpcy5hcGkubWV0aG9kID09PSAnR0VUJyA/ICdxdWVyeScgOiAnc2VuZCddKHRoaXMucGFyYW1zKTtcbiAgICB9IFxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVFcnJvcjogZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciBzdGF0ICA9IHJhdy5zdGF0dXMsXG4gICAgICAgIHJlcyAgID0gKHJhdy5ib2R5ICYmIHJhdy5ib2R5LmRlcGxveXIgPyByYXcuYm9keSA6IHJhdyksXG4gICAgICAgIGVycm9yID0gKChzdGF0ICE9PSAyMDApIHx8IHJlcy5kZXBsb3lyICYmICFyZXMuZGVwbG95ci5yZXNwb25zZS5zdWNjZXNzKTtcblxuICAgIC8vIC0tIEhhbmRsZSBlcnJvcnMgLS1cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJlcyA9IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHsgXG4gICAgICAgICAgcmV0dXJuIHV0aWxzLmdldCh0aGlzLmRlcGxveXIucmVzcG9uc2UsIGtleSk7IFxuICAgICAgICB9LFxuICAgICAgICBkZXBsb3lyOiB7ICAgICAgICAgIFxuICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGNhbGw6IHRoaXMuYXBpWydjYWxsJ10sXG4gICAgICAgICAgICBlcnJvckNvZGU6IHJlcy5kZXBsb3lyID8gcmVzLmRlcGxveXIucmVzcG9uc2UuZXJyb3JDb2RlIDogc3RhdCxcbiAgICAgICAgICAgIGVycm9yOiByZXMuZGVwbG95ciA/IHJlcy5kZXBsb3lyLnJlc3BvbnNlLmVycm9yIDogcmVzLnRleHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIExvZ2dlci5lcnJvcignZXJyb3IoKScsIHRoaXMuYXBpLCByZXMsIHJhdyk7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignZXJyb3IoKScsIHRoaXMuYXBpLCByZXMsIHJhdyk7XG5cbiAgICAgIC8vIC0tIG5vdGlmeSBnbG9iYWwgZXJyb3JzIGZpcnN0IChpZiBhbnkpIGZvciB0aGlzIGNhbGwgLS0gICAgICBcbiAgICAgIGlmICh0aGlzLmdsb2JhbEV2dHMpIHtcbiAgICAgICAgcmFpc2VHbG9iYWxFcnJvcnModGhpcy5hcGlbJ2NhbGwnXSwgcmVzKTsgICAgICAgIFxuICAgICAgfVxuXG4gICAgICAvLyAtLSB0cmFuYWN0aW9uIGxldmVsIEhUVFAgb3IgRGVwbG95UiBlcnJvcnMgY29tZSBuZXh0IC0tICAgIFxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHJlcyk7XG4gICAgICB0aGlzLmVtaXQoJ2RlcGxveXItaW86JyArIHJlcy5kZXBsb3lyLnJlc3BvbnNlLmVycm9yQ29kZSwgcmVzKTtcbiAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KHJlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG59KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLyBJbmNsdWRlIHRoZSBgZGVwcmVjYXRlZGAganNEZXBsb3lSIGZvciBub3cuXG5pZiAod2luKSB7XG4gIHdpbmRvdy5SZXZvbHV0aW9uID0gd2luZG93LlJldm9sdXRpb24gfHwgcmVxdWlyZSgnLi9saWIvZGVwcmVjYXRlZCcpO1xufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogRXhwb3NlIGZvciBhIGNsZWFuZXIgY2xpZW50IGFwaSBpbnRvIERlcGxveVJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIEV4cG9zZXMgdGhlIGBEZXBsb3lSYCBvYmplY3QgZm9yIGV4dGVuZGluZy5cbiAgICpcbiAgICogYGBgdmFyIERlcGxveVIgPSByZXF1aXJlKCdkZXBsb3lyJykuRGVwbG95UjtgYGBcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBUaGUgYERlcGxveVJgIG9iamVjdC5cbiAgICovICAgXG4gIERlcGxveVI6IERlcGxveVIsXG5cbiAgLyoqXG4gICAqIEV4cG9zZXMgdGhlIHN1cHBvcnRlZCBEZXBsb3lSIEFQSXMuXG4gICAqXG4gICAqIEBtZXRob2QgYXBpc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZsYXQgKG9wdGlvbmFsKSBpZiBgdHJ1ZWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2YganVzdCB0aGUgXG4gICAqIEFQSSdzIGVuZHBvaW50IHByb3BlcnRpZXMsIGZvciBleGFtcGxlOiBcbiAgICogYGBgXG4gICAqIFsnL3IvdXNlci9sb2dpbicsICcvci91c2VyL2xvZ291dCcsICcvci91c2VyL2Fib3V0JywgLi4uXVxuICAgKiBgYGBcbiAgICogQHN0YXRpY1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAcmV0dXJuIHtPYmplY3R8QXJyYXl9IFRoZSBIVFRQIHJlcXVlc3QgdG8gdGhlIERlcGxveVIgc2VydmVyLiAgICAgIFxuICAgKi8gIFxuICBhcGlzOiBmdW5jdGlvbihmbGF0KSB7XG4gICAgcmV0dXJuIGZsYXQgPyBPYmplY3Qua2V5cyhhcGlzKSA6IGFwaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzdGF0aWMgbWV0aG9kIGZvciBjb25maWd1cmluZyBhbGwgRGVwbG95UiByZXF1ZXN0cy4gU2V0dGluZ3MgXG4gICAqIG1hZGUgaGVyZSBhcmUgYXBwbGllZCBnbG9iYWxseSBhY3Jvc3MgZXZlcnkgcmVxdWVzdC5cbiAgICpcbiAgICogQG1ldGhvZCBjb25maWd1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCBsaXRlcmFsIGNvbmZpZ3VyYXRpb24gaGFzaC4gXG4gICAqIEBzdGF0aWNcbiAgICogQGNoYWluYWJsZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgY29uZmlndXJlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHsgZ2xvYmFsT3B0aW9ucy5zZXQoaSwgb3B0aW9uc1tpXSk7IH1cblxuICAgIC8vIGFzc2VydCBnbG9iYWwgY29va2llcyBhcmUgZW1wdHkgaWYgZ2xvYmFsIGBzdGlja3lgIGpzZXNzaW9uaWQgaXMgb2ZmXG4gICAgaWYgKCFnbG9iYWxPcHRpb25zLnN0aWNreSkgIHsgZ2xvYmFsT3B0aW9ucy5zZXQoJ2Nvb2tpZXMnLCBudWxsKTsgfVxuXG4gICAgLy8gdHVybiBnbG9iYWwgbG9nZ2luZyBvbnxvZmYgKG9mZiBieSBkZWZhdWx0KVxuICAgIExvZ2dlci5zZXRMZXZlbChnbG9iYWxPcHRpb25zLmxvZ2dpbmcgPyBMb2dnZXIuREVCVUcgOiBMb2dnZXIuT0ZGKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgSU8gcmVxdWVzdHMgdG8gYERlcGxveVJgLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGAgICBcbiAgICogICAgZGVwbG95ci5pbygnL3IvdXNlci9hYm91dCcpLmVuZChjYWxsYmFjayk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAbWV0aG9kIGlvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhcGkgT25lIG9mIHRoZSBzdXBwb3J0ZWQgRGVwbG95UiBBUElzLlxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm4ge0RlcGxveVJ9IFRoZSBIVFRQIHJlcXVlc3QgdG8gdGhlIERlcGxveVIgc2VydmVyLlxuICAgKiBAYXBpIHB1YmxpYyAgIFxuICAgKi9cbiAgaW86IGZ1bmN0aW9uKGFwaSkgeyAgXG4gICAgcmV0dXJuIERlcGxveVIubmV3KGFwaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNpZ24gdGhlIHVzZXIgaW4gYnkgYXV0aGVudGljYXRpbmcgdGhlIGNyZWRlbnRpYWxzIFxuICAgKiB3aXRoIHRoZSBEZXBsb3lSIHNlcnZlci4gICBcbiAgICpcbiAgICogQG1ldGhvZCBhdXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSBTcGVjaWZpZXMgdGhlIHVzZXJuYW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgU3BlY2lmaWVzIHRoZSBwYXNzd29yZC5cbiAgICogQHN0YXRpY1xuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBUaGUgSFRUUCByZXF1ZXN0IHRvIHRoZSBEZXBsb3lSIHNlcnZlci4gICBcbiAgICogQGFwaSBwdWJsaWMgICBcbiAgICovICAgXG4gIGF1dGg6IGZ1bmN0aW9uKHVuLCBwdykge1xuICAgIHZhciBkYXRhID0geyB1c2VybmFtZTogdW4sIHBhc3N3b3JkOiBwdyB9O1xuICAgIHJldHVybiBEZXBsb3lSLm5ldygnL3IvdXNlci9sb2dpbicpLmRhdGEoZGF0YSkuZW5kKCk7ICAgIFxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzaWduIHRoZSB1c2VyIGluIGJ5IGF1dGhlbnRpY2F0aW5nIHRoZSBjcmVkZW50aWFscyBcbiAgICogd2l0aCB0aGUgRGVwbG95UiBzZXJ2ZXIuICAgXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiAgICBkZXBsb3lyLnNjcmlwdCgnL3Rlc3R1c2VyL3Jvb3QvcmVkdWNlLlInKVxuICAgKiAgICBkZXBsb3lyLnNjcmlwdCh7IGZpbGVuYW1lOiAncmVkdWNlLlInLCBhdXRob3I6ICd0ZXN0dXNlcicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiAncm9vdCd9KVxuICAgKiAgICBkZXBsb3lyLnNjcmlwdCgncmVkdWNlLlInLCAndGVzdHVzZXInLCAncm9vdCcpXG4gICAqICAgIGRlcGxveXIuc2NyaXB0KCcvdGVzdHVzZXIvcm9vdC9yZWR1Y2UuUicsIHByb2plY3QpICAgICBcbiAgICogYGBgICAgXG4gICAqXG4gICAqIEBtZXRob2Qgc2NyaXB0XG4gICAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmd1bWVudHMgQXJndW1lbnRzIHRvIGRlZmluZSB0aGUgZnVsbHkgcXVhbGlmaWVkIHNjcmlwdCBcbiAgICogZm9yIGV4ZWN1dGlvbi5cbiAgICogQHN0YXRpY1xuICAgKiBAcmV0dXJuIHtEZXBsb3lSfSBUaGUgSFRUUCByZXF1ZXN0IHRvIHRoZSBEZXBsb3lSIHNlcnZlci4gICBcbiAgICogQGFwaSBwdWJsaWMgICBcbiAgICovICAgICBcbiAgc2NyaXB0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IHV0aWxzLnNpZ25hdHVyZShhcmd1bWVudHMpLFxuICAgICAgICBvcHRzID0gYXJncy5vcHRzLFxuICAgICAgICBhcGkgID0gYXJncy5hcGk7ICBcblxuICAgIC8vIGNvbnZlbmllbmNlIC0gaWYgdGhlIHByb2plY3QgaXMgYSBib29sZW4gYHRydWVgIHJhdGhlciB0aGFuIGEgcGlkLCBmaXJzdFxuICAgIC8vIGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGFuZCB0aGVuIHByZXBhcmUgdGhlIHByb2plY3QgYXBpIGNhbGwgdG8gZXhlY3V0ZVxuICAgIGlmIChhcmdzLmNyZWF0ZSkge1xuICAgICAgcmV0dXJuIERlcGxveVIubmV3KCcvci9wcm9qZWN0L2NyZWF0ZScpXG4gICAgICAgICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJvamVjdDogcmVzLmdldCgncHJvamVjdCcpLnByb2plY3QgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgLmlvKGFwaSlcbiAgICAgICAgICAgICAgIC5kYXRhKG9wdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRGVwbG95Ui5uZXcoYXBpKS5kYXRhKG9wdHMpO1xuICAgIH1cbiAgfSwgIFxuXG4gIC8qKlxuICAgKiBSdW4gYW4gc2VyaWVzIG9mIGNoYWluZWQgRGVwbG95UiByZXF1ZXN0cyBpbiBzZXF1ZW5jZSBhbmQgd2l0aG91dCBvdmVybGFwLiAgICAgICBcbiAgICpcbiAgICogQG1ldGhvZCBwaXBsaW5lXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRhc2tzIFNwZWNpZmllcyB0aGUgbGlzdCBvZiBgRnVuY3Rpb25gIHRhc2tzLlxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB3cmFwcGluZyB0aGUgcmVzb2x1dGlvbiBvZiBlaXRoZXIgXCJyZXNvbHZlXCIgb3JcbiAgICogXCJyZWplY3RcIiBjYWxsYmFjay5cbiAgICogQGFwaSBwdWJsaWMgICBcbiAgICovXG4gIHBpcGVsaW5lOiBmdW5jdGlvbihjaGFpbnMpIHsgICAgICBcbiAgICB2YXIgZGVwbG95ciAgPSB0aGlzLFxuICAgICAgICBkZWZlcnJlZCA9IEQoKSxcbiAgICAgICAgcSAgICAgICAgPSBuZXcgUXVldWUoKSxcbiAgICAgICAgcmVzdWx0cyAgPSBbXSxcbiAgICAgICAgZXJyb3JzICAgPSBbXSxcbiAgICAgICAgTk9PUCAgICAgPSBudWxsLCAvLyBOT09QIGVycm9yc3xyZXN1bHRzIGZvciBbYV0gYmF0Y2ggcmVxdWVzdCBjaGFpblxuICAgICAgICBvcmlnICAgICA9IHtcbiAgICAgICAgICBzdGlja3k6IGdsb2JhbE9wdGlvbnMuc3RpY2t5LFxuICAgICAgICAgIGNvb2tpZXM6IGdsb2JhbE9wdGlvbnMuY29va2llc1xuICAgICAgICB9O1xuXG4gICAgLy8gbWFrZSBhIGNvcHlcbiAgICBjaGFpbnMgPSBjaGFpbnMuc2xpY2UoMCk7XG5cbiAgICAvLyB0dXJuIHN0aWNreSBzZXNzaW9uIGZvciB0aGVzZSByZXF1ZXN0IChoYWNreSlcbiAgICBkZXBsb3lyLmNvbmZpZ3VyZSggeyBzdGlja3k6IHRydWUgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICBxLmFkZChmdW5jdGlvbigpIHsgXG4gICAgICAgIGNoYWlucy5zaGlmdCgpLmRyYWluKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oY2hhaW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goY2hhaW4pOyAgXG4gICAgICAgICAgZXJyb3JzLnB1c2goTk9PUCk7ICAgICAgICAgICBcbiAgICAgICAgICBpZiAocS5pc0VtcHR5KCkpIHsgXG4gICAgICAgICAgICBkZXBsb3lyLmNvbmZpZ3VyZShvcmlnKTsgLy8gcmVzZXRcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoeyByZXN1bHRzOiByZXN1bHRzLCBlcnJvcnM6IGVycm9ycyB9KTsgXG4gICAgICAgICAgfSAgXG5cbiAgICAgICAgICBxLnRha2UoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7ICAgICAgICAgIFxuICAgICAgICAgIHJlc3VsdHMucHVzaChOT09QKTsgXG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAvLyByZWplY3Rpb25zIGFyZSBvbmx5IG1ldCB3aGVuIHRoZXkgW2FsbF0gZmFpbFxuICAgICAgICAgIGlmIChxLmlzRW1wdHkoKSAmJiByZXN1bHRzLmxlbmd0aCA9PT0gMCkgeyBcbiAgICAgICAgICAgIGRlcGxveXIuY29uZmlndXJlKG9yaWcpOyAvLyByZXNldFxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9ycyk7IFxuICAgICAgICAgIH0gIFxuICAgICAgICAgIHEudGFrZSgpO1xuICAgICAgICB9KTsgICAgICAgXG4gICAgICB9LCBudWxsLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIGEgc2VxIHF1ZXVlIGZvciBiZXR0ZXIgaGFuZGxpbmdcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2hhaW5zLmxlbmd0aDsgaSsrKSB7IGFkZCgpOyB9XG5cbiAgICAvLyBzdGFydDogZGVxdWV1ZSBmaXJzdCBpdGVtIGFuZCBydW4gaXRcbiAgICBxLnRha2UoKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgc3RyZWFtIEFQSSBpcyB1bmlxdWUgd2l0aGluIHRoZSBEZXBsb3lSIEFQSSBhcyBpdCBzdXBwb3J0cyBwdXNoIFxuICAgKiBub3RpZmljYXRpb25zIGZyb20gdGhlIERlcGxveVIgc2VydmVyIHRvIGNsaWVudCBhcHBsaWNhdGlvbnMuIE5vdGlmaWNhdGlvbnMgXG4gICAqIGNvcnJlc3BvbmQgdG8gZGlzY3JldGUgZXZlbnRzIHRoYXQgb2NjdXIgd2l0aGluIHRoZSBEZXBsb3lSIHNlcnZlci4gVGhlcmUgXG4gICAqIGFyZSBmb3VyIGRpc3RpbmN0IGV2ZW50IGNhdGVnb3JpZXM6XG4gICAqIFxuICAgKiAtIFN0cmVhbSBMaWZlY3ljbGUgZXZlbnRzXG4gICAqIC0gRXhlY3V0aW9uIGV2ZW50c1xuICAgKiAtIEpvYiBMaWZlY3ljbGUgZXZlbnRzXG4gICAqIC0gTWFuYWdlbWVudCBldmVudHNcbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqIGRlcGxveXIuZXMoeyB1c2VybmFtZTogJ3Rlc3R1c2VyJywgcGFzc3dvcmQ6ICdzZWNyZXQnIH0pXG4gICAqICAgIC8vIC0tIGNvbm5lY3Rpb24gY2hvaWNlcyBmb3IgZXZlbnQgdHlwZXMgLS1cbiAgICogICAgLm1hbmFnZW1lbnQoKSAgLy8uc2Vzc2lvbigpIHwgLmFsbCgpIHwgLnByb2plY3QoaWQpIHwgLmpvYihpZClcbiAgICogICAgLm9uKCdlczpncmlkSGVhcnRiZWF0JywgZnVuY3Rpb24oZGF0YSkge1xuICAgKiAgICAgICAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09PT0nKTtcbiAgICogICAgICAgIGNvbnNvbGUubG9nKCdlczpncmlkSGVhcnRiZWF0Jyk7XG4gICAqICAgICAgICBjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PT09PScpOyAgICAgICAgICBcbiAgICogICAgIH0pXG4gICAqICAgICAub3BlbigpO1xuICAgKiBgYGBcbiAgICogXG4gICAqIEBtZXRob2QgZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCBsaXRlcmFsIGNvbmZpZ3VyYXRpb24gaGFzaC4gXG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybiB7RXZlbnRTdHJlYW19IGEgbmV3IGBFdmVudFN0cmVhbWAgZm9yIGJpbmRpbmcuXG4gICAqIEBhcGkgcHVibGljICAgXG4gICAqLyAgXG4gIGVzOiBmdW5jdGlvbihvcHRpb25zKSB7ICAgIFxuICAgIHZhciBzdHJlYW0gPSBFdmVudFN0cmVhbS5uZXcoZ2xvYmFsT3B0aW9ucy5ob3N0LCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudXNlcm5hbWUgJiYgb3B0aW9ucy5wYXNzd29yZCkge1xuICAgICAgdmFyIHJ1c2VyID0gdGhpcy5hdXRoKG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQpO1xuICAgICAgcnVzZXIuZW5zdXJlKGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgc3RyZWFtLnNoYXJlKHJ1c2VyLmdldENvb2tpZXMoKSk7XG4gICAgICAgIHN0cmVhbS5mbHVzaCgpOyBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJlYW07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIGZhY3RvcnkgZm9yIGNyZWF0aW5nIGEgRGVwbG95Ui1zcGVjaWZpYyBlbmNvZGVkIFIgb2JqZWN0IHRvIGJlIFxuICAgKiBzZW50IGFzIGlucHV0IHBhcmFtZXRlcnMgdG8gYW4gUiBzY3JpcHQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiAgICB2YXIgcmlucHV0ID0gZGVwbG95ci5SSW5wdXQubG9naWNhbCgnbG9naWNhbF9uYW1lJywgdHJ1ZSk7XG4gICAqICAgIHZhciByaW5wdXQgPSBkZXBsb3lyLlJJbnB1dC5udW1lcmljKCdudW1lcmljX25hbWUnLCAxMC41KTtcbiAgICogICAgdmFyIHJpbnB1dCA9IGRlcGxveXIuUklucHV0LmludGVnZXIoJ2ludGVnZXJfbmFtZScsIDUpO1xuICAgKiAgICB2YXIgcmlucHV0ID0gZGVwbG95ci5SSW5wdXQuY2hhcmFjdGVyKCdjaGFyYWN0ZXJfbmFtZScsICdIZWxsbycpO1xuICAgKiAgICAvLyBlY3QuLi5cbiAgICogYGBgXG4gICAqIEBwcm9wZXJ0eSBSSW5wdXRcbiAgICogQHN0YXRpY1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgUklucHV0OiB7XG4gICAgbnVtZXJpYzogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkubnVtZXJpYygpO1xuICAgIH0sXG5cbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5pbnRlZ2VyKCk7XG4gICAgfSxcblxuICAgIGxvZ2ljYWw6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmxvZ2ljYWwoKTtcbiAgICB9LFxuXG4gICAgY2hhcmFjdGVyOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5jaGFyYWN0ZXIoKTtcbiAgICB9LFxuXG4gICAgZGF0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkuZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBwb3NpeGN0OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5wb3NpeGN0KCk7XG4gICAgfSwgIFxuXG4gICAgbnVtZXJpY1ZlY3RvcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5udW1lcmljVmVjdG9yKCk7XG4gICAgfSwgXG5cbiAgICBpbnRlZ2VyVmVjdG9yOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5pbnRlZ2VyVmVjdG9yKCk7XG4gICAgfSxcblxuICAgIGxvZ2ljYWxWZWN0b3I6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5sb2dpY2FsVmVjdG9yKCk7XG4gICAgfSxcblxuICAgIGNoYXJhY3RlclZlY3RvcjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IFxuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmNoYXJhY3RlclZlY3RvcigpO1xuICAgIH0sICBcblxuICAgIGRhdGVWZWN0b3I6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5kYXRlVmVjdG9yKCk7XG4gICAgfSwgIFxuXG4gICAgcG9zaXhjdFZlY3RvcjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IFxuICAgICAgcmV0dXJuIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLnBvc2l4Y3RWZWN0b3IoKTtcbiAgICB9LFxuXG4gICAgbGlzdDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkubGlzdCgpOyBcbiAgICB9LFxuXG4gICAgZGF0YWZyYW1lOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHsgXG4gICAgICByZXR1cm4gUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkuZGF0YWZyYW1lKCk7XG4gICAgfSxcbiAgXG4gICAgZmFjdG9yOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGxldmVscywgbGFiZWxzKSB7XG4gICAgICB2YXIgb3B0cyA9IHsgbGV2ZWxzOiBsZXZlbHMsIGxhYmVsczogbGFiZWxzIH07XG4gICAgICByZXR1cm4gUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSwgb3B0cykuZmFjdG9yKCk7XG4gICAgfSxcblxuICAgIG9yZGVyZWQ6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgbGV2ZWxzLCBsYWJlbHMpIHtcbiAgICAgIHZhciBvcHRzID0geyBsZXZlbHM6IGxldmVscywgbGFiZWxzOiBsYWJlbHMgfTtcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlLCBvcHRzKS5vcmRlcmVkKCk7XG4gICAgfSxcblxuICAgIG51bWVyaWNNYXRyaXg6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5udW1lcmljTWF0cml4KCk7XG4gICAgfSxcblxuICAgIGludGVnZXJNYXRyaXg6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5pbnRlZ2VyTWF0cml4KCk7XG4gICAgfSxcblxuICAgIGxvZ2ljYWxNYXRyaXg6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcbiAgICAgIHJldHVybiBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5sb2dpY2FsTWF0cml4KCk7XG4gICAgfSxcblxuICAgIGNoYXJhY3Rlck1hdHJpeDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkuY2hhcmFjdGVyTWF0cml4KCk7XG4gICAgfVxuICB9XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5a1pYQnNiM2x5TDJSbGNHeHZlWEl1YW5NaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CSWl3aVptbHNaU0k2SW1kbGJtVnlZWFJsWkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLaUZjYmlBcUlFTnZjSGx5YVdkb2RDQW9ReWtnTWpBeE1DMHlNREUxSUdKNUlGSmxkbTlzZFhScGIyNGdRVzVoYkhsMGFXTnpJRWx1WXk1Y2JpQXFYRzRnS2lCVWFHbHpJSEJ5YjJkeVlXMGdhWE1nYkdsalpXNXpaV1FnZEc4Z2VXOTFJSFZ1WkdWeUlIUm9aU0IwWlhKdGN5QnZaaUJXWlhKemFXOXVJREl1TUNCdlppQjBhR1ZjYmlBcUlFRndZV05vWlNCTWFXTmxibk5sTGlCVWFHbHpJSEJ5YjJkeVlXMGdhWE1nWkdsemRISnBZblYwWldRZ1YwbFVTRTlWVkZ4dUlDb2dRVTVaSUVWWVVGSkZVMU1nVDFJZ1NVMVFURWxGUkNCWFFWSlNRVTVVV1N3Z1NVNURURlZFU1U1SElGUklUMU5GSUU5R0lFNVBUaTFKVGtaU1NVNUhSVTFGVGxRc1hHNGdLaUJOUlZKRFNFRk9WRUZDU1V4SlZGa2dUMUlnUmtsVVRrVlRVeUJHVDFJZ1FTQlFRVkpVU1VOVlRFRlNJRkJWVWxCUFUwVXVJRkJzWldGelpTQnlaV1psY2lCMGJ5QjBhR1ZjYmlBcUlFRndZV05vWlNCTWFXTmxibk5sSURJdU1DQW9hSFIwY0RvdkwzZDNkeTVoY0dGamFHVXViM0puTDJ4cFkyVnVjMlZ6TDB4SlEwVk9VMFV0TWk0d0tTQm1iM0lnYlc5eVpTQmNiaUFxSUdSbGRHRnBiSE11WEc0Z0tpOWNibHh1ZG1GeUlIZHBiaUFnSUNBZ0lDQWdJRDBnS0hSNWNHVnZaaUIzYVc1a2IzY2dJVDA5SUNkMWJtUmxabWx1WldRbktTd2dJQ0JjYmlBZ0lDQnlaWEYxWlhOMElDQWdJQ0E5SUhKbGNYVnBjbVVvSjNOMWNHVnlZV2RsYm5RbktTeGNiaUFnSUNCRUlDQWdJQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KMlF1YW5NbktTeGNiaUFnSUNCbWN5QWdJQ0FnSUNBZ0lDQTlJSEpsY1hWcGNtVW9KMlp6Snlrc1hHNGdJQ0FnWVhCcGN5QWdJQ0FnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMkZ3YVhNdWFuTnZiaWNwTENCY2JpQWdJQ0JGZG1WdWRGTjBjbVZoYlNBOUlISmxjWFZwY21Vb0p5NHZiR2xpTDJWekp5a3NYRzRnSUNBZ2RYUnBiSE1nSUNBZ0lDQWdQU0J5WlhGMWFYSmxLQ2N1TDJ4cFlpOTFkR2xzY3ljcExGeHVJQ0FnSUV4aGJtY2dJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlzYVdJdmJHRnVaeWNwTENBZ0lGeHVJQ0FnSUV4dloyZGxjaUFnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlzYVdJdmJHOW5aMlZ5Snlrc0lDQWdYRzRnSUNBZ1VYVmxkV1VnSUNBZ0lDQWdQU0J5WlhGMWFYSmxLQ2N1TDJ4cFlpOXhkV1YxWlNjcExGeHVJQ0FnSUVWdGFYUjBaWElnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlzYVdJdlpXMXBkSFJsY2ljcExGeHVJQ0FnSUdWdVkyOWtaWElnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlzYVdJdlpXNWpiMlJsY2ljcExGeHVJQ0FnSUVKaGMyVWdJQ0FnSUNBZ0lEMGdjbVZ4ZFdseVpTZ25MaTlzYVdJdmMyVnNabWx6YUNjcExrSmhjMlVzWEc0Z0lDQWdVa2x1Y0hWMElDQWdJQ0FnUFNCeVpYRjFhWEpsS0NjdUwyeHBZaTl5YVc1d2RYUW5LU3dnSUNBZ1hHNGdJQ0FnVWtsdWNIVjBjeUFnSUNBZ1BTQnlaWEYxYVhKbEtDY3VMMnhwWWk5eWFXNXdkWFJ6Snlrc1hHNGdJQ0FnYldWeVoyVWdJQ0FnSUNBZ1BTQjFkR2xzY3k1dFpYSm5aVHRjYmx4dUx5cGNiaUFxSUZSMWNtNGdaMnh2WW1Gc0lHeHZaMmRwYm1jZ2IyWm1JR0o1SUdSbFptRjFiSFJjYmlBcUwxeHVURzluWjJWeUxuTmxkRXhsZG1Wc0tFeHZaMmRsY2k1UFJrWXBPMXh1WEc0dktseHVJQ29nUjJ4dlltRnNJRzl3ZEdsdmJuTWdkR2hoZENCd1pYSnphWE4wSUhSb2NtOTFaMmdnWVd4c0lFUmxjR3h2ZVZJZ2NtVnhkV1Z6ZEhNdVhHNGdLaTljYm5aaGNpQm5iRzlpWVd4UGNIUnBiMjV6SUQwZ2V5QmNiaUFnWTI5eWN6b2dabUZzYzJVc1hHNGdJR3h2WjJkcGJtYzZJR1poYkhObExGeHVJQ0J6ZEdsamEzazZJR1poYkhObExGeHVJQ0JqYjI5cmFXVnpPaUJ1ZFd4c0xGeHVJQ0JvYjNOME9pQW5KeXhjYmlBZ1lXeHNiM2RUWld4bVUybG5ibVZrVTFOTVEyVnlkRG9nWm1Gc2MyVXNYRzRnSUcxaGVGSmxjWFZsYzNSek9pQnVkV3hzTENBdkx5QnVieUJ6YjJOclpYUWdjRzl2YkdsdVp5QnBiaUJvZEhSd0xrRm5aVzUwWEc0Z0lHVjJaVzUwY3pwN2ZTeGNiaUFnYzJWME9pQm1kVzVqZEdsdmJpaHdjbTl3TENCMllXeDFaU2tnZXlCY2JpQWdJQ0JwWmlBb2NISnZjQ0FoUFQwZ0ozTmxkQ2NwSUhzZ1hHNGdJQ0FnSUNCcFppQW9jSEp2Y0NBOVBUMGdKMmh2YzNRbklDWW1JSFpoYkhWbEtTQjdJQ0FnSUNBZ0lDQWdYRzRnSUNBZ0lDQWdJQ0F2THlCQ1pTQnRiM0psSUdadmNtZHBkbWx1WnlCdmJpQjBhR1VnWlc1MFpYSmxaQ0JFWlhCc2IzbFNJQ2RsYm1Sd2IybHVkQ2M2WEc0Z0lDQWdJQ0FnSUNBdkx5QWdJQzBnYUhSMGNDaHpLVG92TDJSb2IzTjBPbkJ2Y25SY2JpQWdJQ0FnSUNBZ0lDOHZJQ0FnTFNCb2RIUndLSE1wT2k4dlpHaHZjM1E2Y0c5eWRDOWtaWEJzYjNseVhHNGdJQ0FnSUNBZ0lDQXZMeUFnSUMwZ1pHaHZjM1E2Y0c5eWRGeHVJQ0FnSUNBZ0lDQWdMeThnSUNBdElHUm9iM04wT25CdmNuUXZaR1Z3Ykc5NWNpQWdJQ0FnSUNBZ0lGeHVJQ0FnSUNBZ0lDQWdkbUZzZFdVZ1BTQjJZV3gxWlM1eVpYQnNZV05sS0M5Y1hDOHFKSHhjWEM4cVpHVndiRzk1Y2x4Y0x5b2tMeXdnSnljcE8xeHVJQ0FnSUNBZ0lDQWdkbUZzZFdVZ1BTQW9ibVYzSUZKbFowVjRjQ2duWGlob2RIUndmR2gwZEhCektUb3ZMeWNzSUNkcEp5a3BMblJsYzNRb2RtRnNkV1VwSUQ4Z2RtRnNkV1VnT2lCY2JpQWdJQ0FnSUNBZ0lDQWdJQ2RvZEhSd09pOHZKeUFySUhaaGJIVmxPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0IwYUdselczQnliM0JkSUQwZ2RtRnNkV1U3SUZ4dUlDQWdJSDBnWEc0Z0lIMWNibjA3WEc1Y2JpOHFYRzRnS2lCVWFHVWdkRzl3TFd4bGRtVnNJRVJsY0d4dmVWSWdRVkJKSUhKbGMzQnZibk5sSUdWdWRHbDBhV1Z6TGx4dUlDb3ZYRzUyWVhJZ1ZFOVFURVZXUlV4ZlJVNVVTVlJKUlZNZ1BTQmJYRzRnSUNkMWMyVnlKeXdnWEc0Z0lDZHdjbTlxWldOMEp5d2dYRzRnSUNkM2IzSnJjM0JoWTJVbkxDQmNiaUFnSjJWNFpXTjFkR2x2Ymljc0lGeHVJQ0FuWkdseVpXTjBiM0o1Snl3Z1hHNGdJQ2R5WlhCdmMybDBiM0o1Snl3Z1hHNGdJQ2R3WVdOcllXZGxjeWNnWEc1ZE8xeHVYRzR2S2x4dUlDb2dUbTkwYVdaNUlHZHNiMkpoYkNCSlR5Qmxjbkp2Y2lCbGRtVnVkSE1nWVdOalpYTnphV0pzWlNCaWVTQmhiR3dnYzNWaWMyTnlhV0psY25NZ1lXTnliM056SUhKbGNYVmxjM1J6TGx4dUlDb3ZYRzVtZFc1amRHbHZiaUJ5WVdselpVZHNiMkpoYkVWeWNtOXljeWhoY0drc0lISmxjeWtnZTF4dUlDQjJZWElnWTI5a1pTQWdJQ0E5SUhKbGN5NWtaWEJzYjNseUlEOGdjbVZ6TG1SbGNHeHZlWEl1Y21WemNHOXVjMlV1WlhKeWIzSkRiMlJsSURvZ2NtVnpMbk4wWVhSMWN5eGNiaUFnSUNBZ0lHTnZiblJsZUhRZ1BTQjBhR2x6TzF4dVhHNGdJQzh2SUMwdElHZHNiMkpoYkNCbGRtVnVkSE1nYVdZZ2NISnZkbWxrWldRZ0xTMWNiaUFnYVdZZ0tHZHNiMkpoYkU5d2RHbHZibk11WlhabGJuUnpLU0I3WEc0Z0lDQWdhV1lnS0NGeVpYTXVaR1Z3Ykc5NWNpa2dlMXh1SUNBZ0lDQWdjbVZ6SUQwZ2NtVnpMblJsZUhRN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWTI5dWRHVjRkQ0E5SUdkc2IySmhiRTl3ZEdsdmJuTXVaWFpsYm5SekxtTjBlQ0I4ZkNCamIyNTBaWGgwTzF4dVhHNGdJQ0FnTHk4Z0xTMGdaMlZ1WlhKaGJDQm5iRzlpWVd3Z1ptRnBiSFZ5WlNBdExWeHVJQ0FnSUdsbUlDaG5iRzlpWVd4UGNIUnBiMjV6TG1WMlpXNTBjeTVsY25KdmNpa2dlMXh1SUNBZ0lDQWdaMnh2WW1Gc1QzQjBhVzl1Y3k1bGRtVnVkSE11WlhKeWIzSXVZWEJ3Ykhrb1kyOXVkR1Y0ZEN3Z1cyRndhU3dnY21WelhTazdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdMUzBnU0ZSVVVDQnZjaUJFWlhCc2IzbFNJR2RzYjJKaGJDQmxjbkp2Y25NZ0xTMGdJQ0FnWEc0Z0lDQWdhV1lnS0dkc2IySmhiRTl3ZEdsdmJuTXVaWFpsYm5SelcyTnZaR1ZkS1NCN1hHNGdJQ0FnSUNCbmJHOWlZV3hQY0hScGIyNXpMbVYyWlc1MGMxdGpiMlJsWFM1aGNIQnNlU2hqYjI1MFpYaDBMQ0JiWVhCcExDQnlaWE5kS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibjFjYmx4dUx5b3FYRzRnS2lCVWFHVWdZRVJsY0d4dmVWSmdJSEpsY1hWbGMzUWdZMnhoYzNNZ2FYTWdZU0IxZEdsc2FYUjVJSFJvWVhRZ1luSnZhMlZ5Y3lCSVZGUlFJSEpsY1hWbGMzUnpJSFJvY205MVoyZ2dZU0JjYmlBcUlITnBiWEJzYVdacFpXUWdabXgxYVdRZ2FXNTBaWEptWVdObElIUnZJRVJsY0d4dmVWSXVYRzRnS2x4dUlDb2dRRzF2WkhWc1pTQmtaWEJzYjNseVhHNGdLaUJBWm05eUlHUmxjR3h2ZVhKY2JpQXFMMXh1ZG1GeUlFUmxjR3h2ZVZJZ1BTQkNZWE5sTG1WNGRHVnVaQ2hGYldsMGRHVnlMQ0JTU1c1d2RYUnpMQ0I3WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRlJvWlNCZ1JHVndiRzk1VW1BZ1VtVnhkV1Z6ZENCamJHRnpjeUJwY3lCaElIVjBhV3hwZEhrZ2RHaGhkQ0JpY205clpYSnpJRWhVVkZBZ2NtVnhkV1Z6ZEhNZ2RHaHliM1ZuYUNCY2JpQWdJQ29nWVNCemFXMXdiR2xtYVdWa0lHWnNkV2xrSUdsdWRHVnlabUZqWlNCMGJ5QkVaWEJzYjNsU0xseHVJQ0FnS2lCY2JpQWdJQ29nUUdOc1lYTnpJRnh1SUNBZ0tpQkFZMjl1YzNSeWRXTjBiM0pjYmlBZ0lDb2dRSEJoY21GdElIdFRkSEpwYm1kOUlHRndhU0JVYUdVZ1JHVndiRzk1VWlCQlVFbGNiaUFnSUNvZ1FIQmhjbUZ0SUh0UFltcGxZM1I5SUd4cGJtc2dWR2hsSUc5aWFtVmpkQ0JzYVhSbGNtRnNJR052Ym5SaGFXNXBibWNnZEdobElIQnlaWFpwYjNWeklISmxjWFZsYzNRdVhHNGdJQ0FxSUVCaGNHa2djSEpwZG1GMFpWeHVJQ0FnS2k5Y2JpQWdhVzVwZEdsaGJHbDZaVG9nWm5WdVkzUnBiMjRnYVc1cGRHbGhiR2w2WlNoaGNHa3NJR3hwYm1zcElIdGNiaUFnSUNBZ1JXMXBkSFJsY2k1cGJtbDBhV0ZzYVhwbExtTmhiR3dvZEdocGN5d2dlMzBwTzF4dUlDQmNiaUFnSUNBZ2RtRnlJRzl3ZEhNZ1BTQm5iRzlpWVd4UGNIUnBiMjV6TzF4dVhHNGdJQ0FnSUdsbUlDZ2hZWEJwYzF0aGNHbGRLU0I3SUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduU1c1MllXeHBaQ0JCVUVrZ1hDSW5JQ3NnWVhCcElDc2dKMXdpSnlrN0lIMWNiaUFnSUNCY2JpQWdJQ0FnZEdocGN5NWhjR2tnSUNBZ0lDQWdJRDBnYldWeVoyVW9leUFuWTJGc2JDYzZJR0Z3YVNCOUxDQmhjR2x6VzJGd2FWMHBPeUFnSUNCY2JpQWdJQ0FnZEdocGN5NXNhVzVySUNBZ0lDQWdJRDBnYkdsdWF5QjhmQ0I3ZlR0Y2JpQWdJQ0FnZEdocGN5NXhJQ0FnSUNBZ0lDQWdJRDBnZEdocGN5NXNhVzVyTG5GMVpYVmxJSHg4SUc1bGR5QlJkV1YxWlNncE8xeHVJQ0FnSUNCMGFHbHpMbVJsWm1WeWNtVmtJQ0FnUFNCMGFHbHpMbXhwYm1zdVpHVm1aWEp5WldRZ2ZId2dSQ2dwTzF4dUlDQWdJQ0IwYUdsekxtTnZiMnRwWlhNZ0lDQWdQU0IwYUdsekxteHBibXN1WTI5dmEybGxjenRjYmlBZ0lDQWdkR2hwY3k1c2IyZG5aWElnSUNBZ0lEMGdURzluWjJWeUxtZGxkQ2hoY0drc0lFeHZaMmRsY2k1UFJrWXBPeUF2THlCMGNtRnVjMkZqZEdsdmJpMXNaWFpsYkNCc2IyZG5hVzVuWEc0Z0lDQWdJSFJvYVhNdWNHRnlZVzF6SUNBZ0lDQTlJSHQ5TzF4dUlDQWdJQ0IwYUdsekxtbHVjSFYwY3lBZ0lDQWdQU0JiWFRzZ0x5OGdjbWx1Y0hWMGN5QnNhWE4wSUZ4dUlDQWdJQ0IwYUdsekxtOTFkSEIxZEhNZ0lDQWdQU0JiWFRzZ0x5OGdjbTkxZEhCMWRDQnZZbXBsWTNRZ2JHbHpkRnh1SUNBZ0lDQjBhR2x6TG5KemRISmxZVzBnSUNBZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0FnZEdocGN5NWtaV3hoZVdWa0lDQWdJRDBnWm1Gc2MyVTdYRzRnSUNBZ0lIUm9hWE11WjJ4dlltRnNSWFowY3lBOUlIUnlkV1U3SUM4dklITjFjSEJ5WlhOemZISmhhWE5sSUdkc2IySmhiQ0JsZG1WdWRITWdabTkwSUhSb2FYTWdZR2x2WUNBZ0lDQWdYRzRnSUNBZ0lIUm9hWE11Wm1sc1pTQWdJQ0FnSUNBOUlHNTFiR3c3SUZ4dUlDQWdJQ0IwYUdsekxtWnBiSFJsY2lBZ0lDQWdQU0J1ZFd4c095QmNibHh1SUNBZ0lDQXZMeUJ3Y21WelpYUWdaR1Z3Ykc5NWNpZHpJR0Z6YzJsbmJtVmtJSEpsYzNCdmJuTmxJR1p2Y20xaGRDQm1iM0lnWUhSb2FYTmdJR0Z3YVZ4dUlDQWdJQ0IwYUdsekxtUmhkR0VvZXlCbWIzSnRZWFE2SUhSb2FYTXVZWEJwTG1admNtMWhkQ0I5S1R0Y2JseHVJQ0FnSUNBdkx5QjNjbUZ3SUhOMWNHVnlZV2RsYm5RZ1ptOXlJSFJvWlNCb1pXRjJlU0JzYVdaMGFXNW5JQ0FnSUNCY2JpQWdJQ0FnZEdocGN5NXlaWEVnUFNCY2JpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEZ0MGFHbHpMbUZ3YVM1dFpYUm9iMlF1ZEc5TWIzZGxja05oYzJVb0tWMG9iM0IwY3k1b2IzTjBJQ3NnSnk5a1pYQnNiM2x5SnlBcklHRndhU2s3WEc0Z0lDQWdJSFJvYVhNdWNtVnhMblJwYldWdmRYUW9NakFnS2lBMk1DQXFJREV3TURBcE95QXZMeUJrWldaaGRXeDBJSFJwYldWdmRYUWdMUzArSURJd0lHMXBiblYwWlhOY2JseHVJQ0FnSUNBdkx5QkJiR3dnUTA5U1V5QmtaWEJzYjNseUlHTmhiR3h6SUhKbGNYVnBjbVVnYzNScFkydDVJSE5sYzNOcGIyNXpYRzRnSUNBZ0lHbG1JQ2gzYVc0Z0ppWWdaMnh2WW1Gc1QzQjBhVzl1Y3k1amIzSnpLU0I3SUhSb2FYTXVjbVZ4TG5kcGRHaERjbVZrWlc1MGFXRnNjeWdwT3lCOVhHNWNiaUFnSUNBZ0x5OGdUbTlrWlM1cWN5QXRJR0ZqWTJWemN5QmhiaUJUVTB3Z1pXNWtjRzlwYm5RZ2QybDBhQ0J6Wld4bUlITnBaMjVsWkNCalpYSjBjeUJtYjNJZ2RHVnpkR2x1WjN4a1pYWmNiaUFnSUNBZ2FXWWdLQ0YzYVc0Z0ppWWdaMnh2WW1Gc1QzQjBhVzl1Y3k1aGJHeHZkMU5sYkdaVGFXZHVaV1JUVTB4RFpYSjBLU0I3WEc0Z0lDQWdJQ0FnSUhCeWIyTmxjM011Wlc1MkxrNVBSRVZmVkV4VFgxSkZTa1ZEVkY5VlRrRlZWRWhQVWtsYVJVUWdQU0FuTUNjN0lDQWdJQ0FnSUNCY2JpQWdJQ0FnZlZ4dUlDQjlMRnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQkNhVzVrY3lCMGFHVWdjMk52Y0dVZ1kyOXVkR1Y0ZENCbWIzSWdkR2hsSUdOdmJtWnBaM1Z5WldRZ1lDNWxibVFvS1dBZ1lXNWtJR0F1WlhKeWIzSW9LV0FnWlhabGJuUWdJQ0FnWEc0Z0lDQXFJR2hoYm1Sc1pYSWdZMkZzYkdKaFkydHpJRzl1SUhSb2FYTWdjbVZ4ZFdWemRDNWNiaUFnSUNwY2JpQWdJQ29nUUcxbGRHaHZaQ0JqZEhoY2JpQWdJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJR052Ym5SbGVIUWdWR2hsSUdCMGFHbHpZQ0J2WW1wbFkzUWdabTl5SUhSb1pTQmpiMjVtYVdkMWNtVmtJR0F1Wlc1a0tDbGdJR0Z1WkZ4dUlDQWdLaUJnTG1WeWNtOXlLQ2xnSUdWMlpXNTBJR2hoYm1Sc1pYSnpJRzl1SUhSb2FYTWdjbVZ4ZFdWemRDNWNiaUFnSUNvZ1FHRndhU0J3ZFdKc2FXTWdJQ0JjYmlBZ0lDb3ZJRnh1SUNCamRIZzZJR1oxYm1OMGFXOXVJQ2hqYjI1MFpYaDBLU0I3WEc0Z0lDQWdkR2hwY3k1elkyOXdaU0E5SUdOdmJuUmxlSFFnZkh3Z2RHaHBjenRjYmx4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQjlMRnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQlRkWEJ3Y21WemN5QnZjaUJ5WVdselpTQm5iRzlpWVd3Z1pYWmxiblJ6SUdadmNpQjBhR2x6SUdCcGIyQWdjbVZ4ZFdWemRDNWNiaUFnSUNwY2JpQWdJQ29nUUcxbGRHaHZaQ0JuYkc5aVlXeGNiaUFnSUNvZ1FIQmhjbUZ0SUh0Q2IyOXNaV0Z1ZlNCeVlXbHpaU0JnZEhKMVpXQWdkRzhnY21GcGMyVWdaMnh2WW1Gc0lHVjJaVzUwY3l3Z1lHWmhiSE5sWUNCMGJ5QnpkWEJ5WlhOeklGeHVJQ0FnS2lCbGRtVnVkQ0JtYVhKcGJtY2daMnh2WW1Gc2JIa3VYRzRnSUNBcUlFQnlaWFIxY200Z2UwUmxjR3h2ZVZKOUlHWnZjaUJqYUdGcGJtbHVaeTVjYmlBZ0lDb2dRR0Z3YVNCd2RXSnNhV05jYmlBZ0lDb3ZJQ0JjYmlBZ1oyeHZZbUZzT2lCbWRXNWpkR2x2YmloeVlXbHpaU2tnZTF4dUlDQWdJSFJvYVhNdVoyeHZZbUZzUlhaMGN5QTlJRXhoYm1jdWFYTkNiMjlzWldGdUtISmhhWE5sS1NBL0lISmhhWE5sSURvZ2RHaHBjeTVuYkc5aVlXeEZkblJ6TzF4dVhHNGdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJSDBzSUNCY2JseHVJQ0F2S2lwY2JpQWdJQ29nVW1WMGNtbGxkbVVnWkdWMFlXbHNjeUJoWW05MWRDQjFjMlZ5TGx4dUlDQWdLaUFnSUZ4dUlDQWdLaUJBYldWMGFHOWtJR0ZpYjNWMFhHNGdJQ0FxSUVCeVpYUjFjbTRnZTA5aWFtVmpkSDBnWkdWMFlXbHNjeUJoWW05MWRDQjFjMlZ5SUc5MGFHVnlkMmxsY3lCZ2JuVnNiR0F1WEc0Z0lDQXFJRUJoY0drZ2NIVmliR2xqSUNBZ1hHNGdJQ0FxTDF4dUlDQmhZbTkxZERvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ2RtRnlJSEpsYzNCdmJuTmxJRDBnZEdocGN5NXlaWEV1Y21Wek8xeHVYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXVZWEJwV3lkallXeHNKMTBnUFQwOUlDY3ZjaTkxYzJWeUwyeHZaMmx1SnlBbUppQnlaWE53YjI1elpTQS9JRnh1SUNBZ0lDQWdJQ0FnSUNCeVpYTndiMjV6WlM1aWIyUjVMbWRsZENnbmRYTmxjaWNwSURvZ2JuVnNiRHRjYmlBZ2ZTd2dJRnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQlRhR0Z5WlhNZ2RHaGxJR052YjJ0cFpYTWdabkp2YlNCaElHUnBabVp5Wlc1MElHQXVhVzhvS1dBZ1lXZGxiblFnZEc4Z2NISmxjMlZ5ZG1VZ2MyVnpjMmx2YmlCemRHRjBaVnh1SUNBZ0tpQmhZM0p2YzNNZ1lIUm9hWE5nSUhKbGNYVmxjM1FnWVc1a0lHRnNiQ0J5WlhGMVpYTjBjeUJqYUdGcGJtVmtJSFJ2SUdsMExseHVJQ0FnS2x4dUlDQWdLaUJBYldWMGFHOWtJSE5vWVhKbFhHNGdJQ0FxSUVCeVpYUjFjbTRnZTBSbGNHeHZlVko5SUdadmNpQmphR0ZwYm1sdVp5NWNiaUFnSUNvZ1FHRndhU0J3ZFdKc2FXTWdJQ0JjYmlBZ0lDb3ZJQ0JjYmlBZ2MyaGhjbVU2SUdaMWJtTjBhVzl1SUNoamIyOXJhV1Z6S1NCN1hHNGdJQ0FnYVdZZ0tHZHNiMkpoYkU5d2RHbHZibk11YzNScFkydDVLU0I3WEc0Z0lDQWdJQ0JwWmlBb1oyeHZZbUZzVDNCMGFXOXVjeTVqYjI5cmFXVnpLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVZMjl2YTJsbGN5QTlJR2RzYjJKaGJFOXdkR2x2Ym5NdVkyOXZhMmxsY3k1emJHbGpaU2d3S1RzZ1hHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCcFppQW9ZMjl2YTJsbGN5a2dleUJjYmlBZ0lDQWdJQ0FnSUNCMGFHbHpMbU52YjJ0cFpYTWdQU0JqYjI5cmFXVnpMbk5zYVdObEtEQXBPeUJjYmlBZ0lDQWdJQ0FnSUNCbmJHOWlZV3hQY0hScGIyNXpMbk5sZENnblkyOXZhMmxsY3ljc0lIUm9hWE11WTI5dmEybGxjeWs3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JpQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdkR2hwY3k1amIyOXJhV1Z6SUQwZ0tHTnZiMnRwWlhNZ1B5QmpiMjlyYVdWekxuTnNhV05sS0RBcElEb2dkR2hwY3k1amIyOXJhV1Z6S1R0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdmU3hjYmx4dUlDQXZLaXBjYmlBZ0lDb2dVbVYwZFhKdWN5QjBhR1VnU0ZSVVVDQmpiMjlyYVdVZ2NISmxkbWx2ZFhOc2VTQnpaVzUwSUdKNUlIUm9aU0J6WlhKMlpYSWdkMmwwYUNCVFpYUXRRMjl2YTJsbExseHVJQ0FnS2lCVWFHbHpJSFpoYkhWbElHTmhiaUJpWlNCd1lYTnpaV1FnZEc4Z1lDNXphR0Z5WlNoeWRYTmxjaTVuWlhSRGIyOXJhV1Z6S0NrcFlDQnZaaUJoSUdScFptWnlaVzUwWEc0Z0lDQXFJR0F1YVc4b0tXQWdZV2RsYm5RZ2RHOGdjSEpsYzJWeWRtVWdjMlZ6YzJsdmJpQnpkR0YwWlNCaFkzSnZjM01nY21WeGRXVnpkSE11WEc0Z0lDQXFYRzRnSUNBcUlFQnRaWFJvYjJRZ1oyVjBRMjl2YTJsbGMxeHVJQ0FnS2lCQWNtVjBkWEp1SUh0QmNuSmhlWDBnVkdobElFaFVWRkFnWTI5dmEybGxJSEJ5WlhacGIzVnpiSGtnYzJWdWRDQmllU0IwYUdVZ2MyVnlkbVZ5SUhkcGRHZ2dYRzRnSUNBcUlGTmxkQzFEYjI5cmFXVXVYRzRnSUNBcUlFQmhjR2tnY0hWaWJHbGpJQ0FnWEc0Z0lDQXFMeUFnWEc0Z0lHZGxkRU52YjJ0cFpYTTZJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3k1amIyOXJhV1Z6TzF4dUlDQjlMQ0JjYmx4dUlDQmtaV3hoZVRvZ1puVnVZM1JwYjI0Z0tHMXpLU0I3WEc0Z0lDQWdMeThnVkU5RVR6b2djM1Z3Y0c5eWRDQmtaV3hoZVdWa0lISmxjWFZsYzNSeklHSmhjMlZrSUc5dUlHMXpJR1p2Y2lCdWIzY2dkR2hwY3lCcGN5QnFkWE4wSUdFZ2NHRjFjMlV1WEc0Z0lDQWdkR2hwY3k1a1pXeGhlV1ZrSUQwZ0lXbHpUbUZPS0hCaGNuTmxSbXh2WVhRb2JYTXBLU0FtSmlCcGMwWnBibWwwWlNodGN5a2dQeUJ0Y3lBNklIUnlkV1U3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdmU3dnSUNCY2JseHVJQ0F2S2lwY2JpQWdJQ29nVlc1M2FXNWtJSFJvWlNCeGRXVjFaU0JqYUdGcGJpQmpiR1ZoY21sdVp5QnlaWEYxWlhOMGN5QjBhR0YwSUcxcFoyaDBJR2hoZG1VZ1pHVnNZWGx6SUdGMGRHRmphR1ZrTGx4dUlDQWdLbHh1SUNBZ0tpQkFiV1YwYUc5a0lHUnlZV2x1WEc0Z0lDQXFJRUJ5WlhSMWNtNGdlMUJ5YjIxcGMyVjlJRUVnY0hKdmJXbHpaU0IzY21Gd2NHbHVaeUIwYUdVZ2NtVnpiMngxZEdsdmJpQnZaaUJsYVhSb1pYSWdYQ0p5WlhOdmJIWmxYQ0lnYjNKY2JpQWdJQ29nWENKeVpXcGxZM1JjSWlCallXeHNZbUZqYXk1Y2JpQWdJQ29nUUdGd2FTQndkV0pzYVdNZ0lDQmNiaUFnSUNvdlhHNGdJR1J5WVdsdU9pQm1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lDQWdkR2hwY3k1a1pXeGhlV1ZrSUQwZ1ptRnNjMlU3WEc0Z0lDQWdkR2hwY3k1eExtWnNkWE5vS0NrN0lGeHVYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTXVaR1ZtWlhKeVpXUXVjSEp2YldselpUdGNiaUFnZlN3Z0lDQmNibHh1SUNBdktpcGNiaUFnSUNvZ1ZHaGxJR0F1Y0hKdmJXbHpaU2dwWUNCdFpYUm9iMlFnY21WMGRYSnVjeUJoSUdSNWJtRnRhV05oYkd4NUlHZGxibVZ5WVhSbFpDQlFjbTl0YVhObElIUm9ZWFFnYVhNZ1hHNGdJQ0FxSUhKbGMyOXNkbVZrSUc5dVkyVWdZV3hzSUVSbGNHeHZlVklnWUM1cGJ5Z3BZQ0J5WlhGMVpYTjBjeUJvWVhabElHVnVaR1ZrTGx4dUlDQWdLaUFnSUZ4dUlDQWdLaUJBYldWMGFHOWtJSEJ5YjIxcGMyVmNiaUFnSUNvZ1FISmxkSFZ5YmlCN1VISnZiV2x6WlgwZ1FTQndjbTl0YVhObElIZHlZWEJ3YVc1bklIUm9aU0J5WlhOdmJIVjBhVzl1SUc5bUlHVnBkR2hsY2lCY0luSmxjMjlzZG1WY0lpQnZjbHh1SUNBZ0tpQmNJbkpsYW1WamRGd2lJR05oYkd4aVlXTnJMbHh1SUNBZ0tpQkFZWEJwSUhCMVlteHBZMXh1SUNBZ0tpOGdJQ0FnSUZ4dUlDQndjbTl0YVhObE9pQm1kVzVqZEdsdmJpQW9LU0I3WEc0Z0lDQWdkR2hwY3k1bGJtUW9LVHRjYmx4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TG1SbFptVnljbVZrTG5CeWIyMXBjMlU3WEc0Z0lIMHNYRzVjYmlBZ0x5b3FYRzRnSUNBcUlFRmliM0owSUhSb1pTQkVaWEJzYjNsU0lISmxjWFZsYzNRdVhHNGdJQ0FxWEc0Z0lDQXFJRUJ0WlhSb2IyUWdZV0p2Y25RZ0lGeHVJQ0FnS2lCQWNtVjBkWEp1SUh0RVpYQnNiM2xTZlNCbWIzSWdZMmhoYVc1cGJtY3VYRzRnSUNBcUlFQmhjR2tnY0hWaWJHbGpYRzRnSUNBcUx5QWdYRzRnSUdGaWIzSjBPaUJtZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnZEdocGN5NXlaWEV1WVdKdmNuUW9LVHRjYmlBZ0lDQjBhR2x6TG1WdGFYUW9KMkZpYjNKMEp5azdYRzRnSUNBZ2RHaHBjeTVrWldabGNuSmxaQzV5WldwbFkzUW9kR2hwY3k1ZmFHRnVaR3hsUlhKeWIzSW9leUJjYmlBZ0lDQWdJQ0FnYzNSaGRIVnpPaUFuWVdKdmNuUW5MRnh1SUNBZ0lDQWdJQ0IwWlhoME9pQW5SR1Z3Ykc5NVVpQnlaWEYxWlhOMElHRmliM0owWldRdUoxeHVJQ0FnSUgwcEtUdGNibHh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpPMXh1SUNCOUxGeHVYRzRnTHlvcVhHNGdJQ29nVTJWMElIUnBiV1Z2ZFhRZ2RHOGdZRzF6WUM1Y2JpQWdLbHh1SUNBcUlFQnRaWFJvYjJRZ2RHbHRaVzkxZENBZ1hHNGdJQ29nUUhCaGNtRnRJSHRPZFcxaVpYSjlJRzF6WEc0Z0lDb2dRSEpsZEhWeWJpQjdSR1Z3Ykc5NVVuMGdabTl5SUdOb1lXbHVhVzVuWEc0Z0lDb2dRR0Z3YVNCd2RXSnNhV05jYmlBZ0tpOGdJRnh1SUNCMGFXMWxiM1YwT2lCbWRXNWpkR2x2YmlBb2JYTXBJSHRjYmlBZ0lDQjBhR2x6TG5KbGNTNTBhVzFsYjNWMEtHMXpLVHRjYmx4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQjlMRnh1WEc0Z0x5b3FYRzRnSUNvZ1ZIVnliaUJzYjJkbmFXNW5JRzl1SUdadmNpQjBhR1VnYzNCbFkybG1hV01nZEhKaGJuTmhZM1JwYjI0dVhHNGdJQ3BjYmlBZ0tpQkFiV1YwYUc5a0lHeHZaMXh1SUNBcUlFQnlaWFIxY200Z2UwUmxjR3h2ZVZKOUlHWnZjaUJqYUdGcGJtbHVaMXh1SUNBcUlFQmhjR2tnY0hWaWJHbGpYRzRnSUNvdklGeHVJQ0JzYjJjNklHWjFibU4wYVc5dUlDaHNaWFpsYkNrZ2UxeHVJQ0FnSUhSb2FYTXViRzluWjJWeUxuTmxkRXhsZG1Wc0tHeGxkbVZzSUh4OElFeHZaMmRsY2k1RVJVSlZSeWs3WEc1Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdmU3hjYmx4dUlDQXZLaXBjYmlBZ0lDb2dSbWxzZEdWeWN5QnpkV05qWlhOelpuVnNJSEpsYzNCdmJuTmxjeUIwYnlCamIyNTBZV2x1SUc5dWJIa2dZU0IwYjNBdGJHVjJaV3dnUkdWd2JHOTVVaUJCVUVrZ1hHNGdJQ0FxSUhKbGMzQnZibk5sSUdWdWRHbDBhV1Z6T2x4dUlDQWdLaUF0SUNkMWMyVnlKMXh1SUNBZ0tpQXRJQ2R3Y205cVpXTjBKMXh1SUNBZ0tpQXRJQ2QzYjNKcmMzQmhZMlVuSUZ4dUlDQWdLaUF0SUNkbGVHVmpkWFJwYjI0bklGeHVJQ0FnS2lBdElDZGthWEpsWTNSdmNua25JRnh1SUNBZ0tpQXRJQ2R5WlhCdmMybDBiM0o1SjF4dUlDQWdLaUF0SUNkd1lXTnJZV2RsY3ljZ1hHNGdJQ0FxSUNBZ1hHNGdJQ0FxSUVCdFpYUm9iMlFnWlc1MGFYUjVYRzRnSUNBcUlFQnlaWFIxY200Z2UwUmxjR3h2ZVZKOUlHWnZjaUJqYUdGcGJtbHVaMXh1SUNBZ0tpQkFZWEJwSUhCMVlteHBZMXh1SUNBZ0tpOWNiaUFnWlc1MGFYUjVPaUJtZFc1amRHbHZiaUFvWlc1MGFYUjVLU0I3WEc0Z0lDQWdkR2hwY3k1bWFXeDBaWElnUFNCMWRHbHNjeTVwYmtGeWNtRjVLRlJQVUV4RlZrVk1YMFZPVkVsVVNVVlRMQ0JsYm5ScGRIa3BPMXh1WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE03WEc0Z0lIMHNYRzVjYmlBZ0x5b3FYRzRnSUNBcUlFUmxabWx1WlhNZ2RHaGxJSEpsY1hWbGMzUWdaR0YwWVNCaVpXbHVaeUJ6Wlc1MElIUnZJR0VnUkdWd2JHOTVVaUJCVUVrdUlGeHVJQ0FnS2x4dUlDQWdLaUJBYldWMGFHOWtJR1JoZEdGY2JpQWdJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJR1JoZEdFZ1ZHaGxJRzlpYW1WamRDQnNhWFJsY21Gc0lHTnZibVpwWjNWeVlYUnBiMjRnYUdGemFDNGdYRzRnSUNBcUlFQnlaWFIxY200Z2UwUmxjR3h2ZVZKOUlHWnZjaUJqYUdGcGJtbHVaMXh1SUNBZ0tpQkFZWEJwSUhCMVlteHBZMXh1SUNBZ0tpOWNiaUFnWkdGMFlUb2dablZ1WTNScGIyNGdLR1JoZEdFcElIdGNiaUFnSUNCa1lYUmhJRDBnWkdGMFlTQjhmQ0I3ZlRzZ0lDQWdYRzVjYmlBZ0lDQXZMeUJ5WlcxdmRtVWdZVzU1SUdsdWJHbHVaV1FnY21sdWNIVjBLSE1wSUdGdVpDQmhkSFJoWTJnZ2RHaGxiU0IwYnlCMGFHVWdjbWx1Y0hWMEtITXBJSEJ5YjNCbGNuUjVYRzRnSUNBZ2FXWWdLR1JoZEdFdWNtbHVjSFYwSUh4OElHUmhkR0V1Y21sdWNIVjBjeWtnZTF4dUlDQWdJQ0FnZEdocGN5NXlhVzV3ZFhRb1pHRjBZUzV5YVc1d2RYUXBPMXh1SUNBZ0lDQWdkR2hwY3k1eWFXNXdkWFJ6S0dSaGRHRXVjbWx1Y0hWMGN5azdYRzRnSUNBZ2ZTQmNibHh1SUNBZ0lDOHZJSEpsYlc5MlpTQmhibmtnWUhKbGMyVnlkbVZrWUNCMllXeDFaWE1nZEdoaGRDQmpiM1ZzWkNCb1lYWmxJR0psWlc0Z2NHRnpjMlZrSUdKNUlHMXBjM1JoYTJWY2JpQWdJQ0IyWVhJZ1FreEJRMHRNU1ZOVUlEMGdXeWR5YVc1d2RYUW5MQ0FuY21sdWNIVjBjeWNzSUNkZlgyTnZiMnRwWlhOZlh5ZGRPMXh1SUNBZ0lFSk1RVU5MVEVsVFZDNW1iM0pGWVdOb0tHWjFibU4wYVc5dUtIQmhjbUZ0S1NCN0lHUmxiR1YwWlNCa1lYUmhXM0JoY21GdFhUc2dmU2s3SUNCY2JseHVJQ0FnSUhSb2FYTXVjR0Z5WVcxeklEMGdiV1Z5WjJVb2RHaHBjeTV3WVhKaGJYTXNJR1JoZEdFcE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTTdYRzRnSUgwc1hHNWNiaUFnTHlvcVhHNGdJQ0FxSUVGMGRHRmphR1Z6SUdFZ1ptbHNaU0IwYnlCaVpTQjFjR3h2WVdSbFpDNGdYRzRnSUNBcVhHNGdJQ0FxSUVCdFpYUm9iMlFnWVhSMFlXTm9YRzRnSUNBcUlFQndZWEpoYlNCN1JtbHNaWHhDYkc5aWZIQmhkR2g5SUdacGJHVWdWR2hsSUdacGJHVWdkRzhnWW1VZ1lYUjBZV05vWldRZ1ptOXlJR0Z1SUhWd2JHOWhaQzRnUm05eUlGeHVJQ0FnS2lCQ2NtOTNjMlZ5SUdWdWRtbHliMjV0Wlc1MGN5QjBhR1VnU0ZSTlREVWdSbWxzWlh4Q2JHOWlJR2x6SUhWelpXUXVJRVp2Y2lCMGFHVWdUbTlrWlM1cWN5QmNiaUFnSUNvZ1pXNTJhWEp2Ym0xbGJuUXNJR0VnWm1sc1pTQndZWFJvSUdseklHRmpZMlZ3ZEdWa0xseHVJQ0FnS2lCQWNHRnlZVzBnZTFOMGNtbHVaMzBnWm1sc1pXNWhiV1VnS0c5d2RHbHZibUZzS1NCMGFHVWdibUZ0WlNCdlppQjBhR1VnWm1sc1pTQjBieUJpWlNCMWNHeHZZV1JsWkM0Z1hHNGdJQ0FxSUZSb2FYTWdibUZ0WlNCa2IyVnpJRzV2ZENCb1lYWmxJSFJ2SUcxaGRHTm9JSFJvWlNCaFkzUjFZV3dnYzI5MWNtTmxJR1pwYkdWdVlXMWxMbHh1SUNBZ0tpQkFjbVYwZFhKdUlIdEVaWEJzYjNsU2ZTQm1iM0lnWTJoaGFXNXBibWRjYmlBZ0lDb2dRR0Z3YVNCd2RXSnNhV05jYmlBZ0lDb3ZYRzRnSUdGMGRHRmphRG9nWm5WdVkzUnBiMjRnS0dacGJHVXNJR1pwYkdWdVlXMWxLU0I3WEc0Z0lDQWdhV1lnS0hSb2FYTXVZWEJwTG5Wd2JHOWhaQ2tnZTF4dUlDQWdJQ0FnZEdocGN5NW1hV3hsSUQwZ1ptbHNaVHRjYmx4dUlDQWdJQ0FnTHk4Z2IzQjBhVzl1WVd3Z1ptbHNaVzVoYldVZ2FHVnlaU0JtYjNJZ1kyOXVkbVZ1YVdWdVkyVmNiaUFnSUNBZ0lHbG1JQ2htYVd4bGJtRnRaU2tnZXlCMGFHbHpMbVJoZEdFb0lIc2dabWxzWlc1aGJXVTZJR1pwYkdWdVlXMWxJSDBnS1RzZ2ZWeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRIVnliaUIwYUdsek8xeHVJQ0I5TEZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJUZFhCd2IzSjBaV1FnYjI1c2VTQnBiaUJPYjJSbExtcHpMQ0IwYUdseklHMWxkR2h2WkNCM2IzSnJjeUJwYmlCamIyNXFkVzVqZEdsdmJpQjNhWFJvSUhSb1pTQmNiaUFnSUNvZ1lYUjBZV05vSUcxbGRHaHZaQ0IwYnlCcGJtUnBZMkYwWlNCMGFHRjBJSFJvWlNCbWFXeGxJSE5vYjNWc1pDQmlaU0J5WldGa0lHbHVJR0Z6SUdFZ2NtVmhaR0ZpYkdVZ1hHNGdJQ0FxSUhOMGNtVmhiU0JrZFhKcGJtY2dZU0JtYVd4bElIVndiRzloWkM1Y2JpQWdJQ3BjYmlBZ0lDb2dRRzFsZEdodlpDQnpkSEpsWVcxY2JpQWdJQ29nUUhCaGNtRnRJSHRQWW1wbFkzUjlJRzl3ZEdsdmJuTWdLRzl3ZEdsdmJtRnNLU0IwYUdVZ1VtVmhaR0ZpYkdVZ1UzUnlaV0Z0SUc5d2RHbHZibk1nYUdGemFDNWNiaUFnSUNvZ0lHQmdZRnh1SUNBZ0tpQWdJQ0I3SUdac1lXZHpPaUFuY2ljc1hHNGdJQ0FxSUNBZ0lDQWdaVzVqYjJScGJtYzZJRzUxYkd3c1hHNGdJQ0FxSUNBZ0lDQWdabVE2SUc1MWJHd3NYRzRnSUNBcUlDQWdJQ0FnYlc5a1pUb2dNRFkyTml4Y2JpQWdJQ29nSUNBZ0lDQmhkWFJ2UTJ4dmMyVTZJSFJ5ZFdWY2JpQWdJQ29nSUNBZ2ZWeHVJQ0FnS2lCZ1lHQmNiaUFnSUNvZ1FISmxkSFZ5YmlCN1JHVndiRzk1VW4wZ1ptOXlJR05vWVdsdWFXNW5YRzRnSUNBcUlFQmhjR2tnY0hWaWJHbGpYRzRnSUNBcUwxeHVJQ0J6ZEhKbFlXMDZJR1oxYm1OMGFXOXVJQ2dwSUh0Y2JpQWdJQ0IwYUdsekxuSnpkSEpsWVcwZ1BTQW9JWGRwYmlBbUppQjBhR2x6TG1Gd2FTNTFjR3h2WVdRcE95QXZMMjV2WkdWcWN5QnZibXg1WEc1Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdmU3hjYmlBZ1hHNGdJQzhxS2x4dUlDQWdLaUJCWTNSeklHRnpJR0VnWm1sdVlXeHNlU0J6ZEdGMFpXMWxiblFnWVd4c2IzZHBibWNnZVc5MUlIUnZJR1Y0WldOMWRHVWdYQ0pqYkdWaGJuVndYQ0lnZEhsd1pTQjBZWE5yY3lCY2JpQWdJQ29nYVc0Z1lTQnlaWEYxWlhOMElHTm9ZV2x1TGlCSmRDQmhjbkpoYm1kbGN5Qm1iM0lnWTJ4bFlXNTFjQ0IwYnlCaVpTQmpZV3hzWldRc0lIZHBkR2dnYm04Z1hHNGdJQ0FxSUdGeVozVnRaVzUwY3l3Z2QyaGxiaUIwYUdVZ1JHVndiRzk1VWlCeVpYRjFaWE4wSUdOb1lXbHVJR2x6SUdWcGRHaGxjaUJqYjIxd2JHVjBaV3g1SUdaMWJHWnBiR3hsWkNCY2JpQWdJQ29nYjNJZ2NtVnFaV04wWldRdVhHNGdJQ0FxWEc0Z0lDQXFJRUJ0WlhSb2IyUWdaVzV6ZFhKbFhHNGdJQ0FxSUVCd1lYSmhiU0I3Um5WdVkzUnBiMjU5SU02N0lIUm9aU0JqWVd4c1ltRmpheUJtZFc1amRHbHZiaTVjYmlBZ0lDb2dRSEpsZEhWeWJpQjdSR1Z3Ykc5NVVuMGdabTl5SUdOb1lXbHVhVzVuWEc0Z0lDQXFJRUJoY0drZ2NIVmliR2xqWEc0Z0lDQXFMeUFnWEc0Z0lHVnVjM1Z5WlRvZ1puVnVZM1JwYjI0Z0tHWnVLU0I3WEc0Z0lDQWdkR2hwY3k1a1pXWmxjbkpsWkM1d2NtOXRhWE5sTG1WdWMzVnlaU2htYmlrN1hHNWNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NWtaV1psY25KbFpDNXdjbTl0YVhObE8xeHVJQ0I5TEZ4dUlDQWdJQ0FnWEc0Z0lDOHFLbHh1SUNBZ0tpQlVhR1VnWjJWdVpYSmhiQ0JtWVdsc2RYSmxJR05oYkd4aVlXTnJMaUJKWmlCallXeHNaV1FzSUdGc2JDQkVaWEJzYjNsU0lHVnljbTl5Y3lCbWIzSWdkR2hwY3lCY2JpQWdJQ29nZEhKaGJuTmhZM1JwYjI0Z2QybHNiQ0JpWlNCeVpYUjFjbTVsWkNCb1pYSmxJSGRvWlc0Z2NtRnBjMlZrTGx4dUlDQWdLbHh1SUNBZ0tpQkFiV1YwYUc5a0lHVnljbTl5WEc0Z0lDQXFJRUJ3WVhKaGJTQjdSblZ1WTNScGIyNTlJTTY3SUhSb1pTQmpZV3hzWW1GamF5Qm1kVzVqZEdsdmJpNWNiaUFnSUNvZ1FISmxkSFZ5YmlCN1JHVndiRzk1VW4wZ1ptOXlJR05vWVdsdWFXNW5YRzRnSUNBcUlFQmhjR2tnY0hWaWJHbGpYRzRnSUNBcUwxeHVJQ0JsY25KdmNqb2dablZ1WTNScGIyNGdLR1p1S1NCN1hHNGdJQ0FnZEdocGN5NXZiaWduWlhKeWIzSW5MQ0JtYmlrN1hHNWNiaUFnSUNCeVpYUjFjbTRnZEdocGN6dGNiaUFnZlN4Y2JseHVJQ0F2S2lwY2JpQWdJQ29nVTNSeVpXRnRJSFJvWlNCRVpYQnNiM2xTSUhKbGMzQnZibk5sSUdsdWRHOGdkR2hsSUhCcGNHVXVJRWwwSUdseklHbHRjRzl5ZEdGdWRDQjBieUJ1YjNSbElIUm9ZWFFnYVdZZ1hHNGdJQ0FxSUhSb1pTQmdMbkJwY0dVb0tXQWdiV1YwYUc5a0lHbHpJRzVsZG1WeUlHTmhiR3hsWkNCMGFHVWdjbVZ4ZFdWemRDQjNhV3hzSUc1dmRDQmlaU0J6Wlc1MExseHVJQ0FnS2x4dUlDQWdLaUJVYUdVZ1lDNXdhWEJsS0NsZ0lHMWxkR2h2WkNCemFHOTFiR1FnWW1VZ1ltVWdkWE5sWkNCaGN5QmhiaUJoYkhSbGNtNWhkR2wyWlNCMGJ5QmdMbVZ1WkNncFlDQmhibVFnWEc0Z0lDQXFJRzVsZG1WeUlHRnNiMjVuSUhOcFpHVWdiMllnYVhRdUlHQXVjR2x3WlNncFlDQmhibVFnWUM1bGJtUW9LV0FnWVhKbElHRnVJR1ZwZEdobGNpMXZjaTVjYmlBZ0lDcGNiaUFnSUNvZ1FHMWxkR2h2WkNCd2FYQmxYRzRnSUNBcUlFQndZWEpoYlNCN1UzUnlaV0Z0ZlNCemRISmxZVzBnUVNCa1pYTjBhVzVoZEdsdmJpQlRkSEpsWVcwdVhHNGdJQ0FxSUVCeVpYUjFjbTRnZTFOMGNtVmhiWDBnVkdobElIQmhjM05sWkNCcGJpQmtaWE4wYVc1aGRHbHZiaUJ6ZEhKbFlXMGdkRzhnWW1VZ2RYTmxaQ0JtYjNJZ1lXUmthWFJwYjI1aGJDQmNiaUFnSUNvZ2NHbHdhVzVuTGx4dUlDQWdLaUJBWVhCcElIQjFZbXhwWTF4dUlDQWdLaTljYmlBZ2NHbHdaVG9nWm5WdVkzUnBiMjRnS0dSbGMzUXBJSHRjYmlBZ0lDQjJZWElnY1NBZ0lEMGdkR2hwY3k1eExGeHVJQ0FnSUNBZ0lDQmhjR2tnUFNCMGFHbHpMbUZ3YVRzZ0lDQWdJQ0FnSUZ4dVhHNGdJQ0FnY1M1aFpHUW9ablZ1WTNScGIyNG9jbVZ6Y0c5dWMyVkRhR0ZwYml3Z1pYSnliM0lzSUhCeVpYWkJjbWR6S1NCN0lDQWdJRnh1SUNBZ0lDQWdMeThnWW5KaGEyVWdkR2hsSUdOaGJHd2dZMmhoYVc0Z2IyNGdaWEp5YjNJZ0lDQWdJQ0JjYmlBZ0lDQWdJR2xtSUNobGNuSnZjaWtnZXlBZ0lDQWdJQ0FnWEc0Z0lDQWdJQ0FnSUhSb2FYTXVaR1ZtWlhKeVpXUXVjbVZxWldOMEtHVnljbTl5S1RzZ0lDQWdJQ0JjYmlBZ0lDQWdJQ0FnY1M1bWJIVnphQ2h5WlhOd2IyNXpaVU5vWVdsdUxDQmxjbkp2Y2l3Z2NISmxka0Z5WjNNcE95QXZMeUJrY21GcGJpQjBhR1VnY1hWbGRXVmNiaUFnSUNBZ0lDQWdkR2hwY3k1ZlkyeGxZWElvS1R0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnWEc0Z0lDQWdJQ0IwYUdsekxsOXdjbVZ3VW1WeGRXVnpkQ2h5WlhOd2IyNXpaVU5vWVdsdUxDQndjbVYyUVhKbmN5azdYRzVjYmlBZ0lDQWdJRXh2WjJkbGNpNXBibVp2S0Nkd2FYQmxLQ2tuTENCaGNHa3NJSFJvYVhNdWNtVnhLVHRjYmlBZ0lDQWdJSFJvYVhNdWJHOW5aMlZ5TG1sdVptOG9KM0JwY0dVb0tTY3NJR0Z3YVN3Z2RHaHBjeTV5WlhFcE95QWdJRnh1WEc0Z0lDQWdJQ0IyWVhJZ2MzUnlaV0Z0SUQwZ2RHaHBjeTV5WlhFdWNHbHdaU2hrWlhOMEtUdGNiaUFnSUNBZ0lIRXVlV2xsYkdRb2RISjFaU2s3WEc0Z0lDQWdJQ0J6ZEhKbFlXMHViMjRvSjJWeWNtOXlKeXdnWm5WdVkzUnBiMjRnS0NrZ2V5QjlLVHNnSUNBZ1hHNGdJQ0FnSUNCemRISmxZVzB1YjI0b0oyVnVaQ2NzSUdaMWJtTjBhVzl1S0NrZ2V5QjlLVHNnSUNBZ0lGeHVJQ0FnSUNBZ2MzUnlaV0Z0TG05dUtDZGtZWFJoSnl3Z1puVnVZM1JwYjI0b0tTQjdJSDBwT3lBZ0lDQWdJRnh1SUNBZ0lIMHNJSFJvYVhNcE8xeHVJQ0JjYmlBZ0lDQnBaaUFvY1M1emFYcGxLQ2tnUEQwZ01Ta2dleUJ4TG1ac2RYTm9LQ2s3SUgxY2JseHVJQ0FnSUhKbGRIVnliaUJrWlhOME8xeHVJQ0I5TEZ4dVhHNGdJQzhxS2x4dUlDQWdLaUJKYm1ScFkyRjBaWE1nZEdoaGRDQjBhR1VnY21WeGRXVnpkQ0JwY3lCeVpXRmtlU0IwYnlCaVpTQnpaVzUwSUhSdklFUmxjR3h2ZVZJdUlFbDBJR2x6SUdsdGNHOXlkR0Z1ZENCY2JpQWdJQ29nZEc4Z2JtOTBaU0IwYUdGMElHbG1JSFJvWlNCZ0xtVnVaQ2dwWUNCdFpYUm9iMlFnYVhNZ2JtVjJaWElnWTJGc2JHVmtJSFJvWlNCeVpYRjFaWE4wSUhkcGJHd2dibTkwSUdKbFhHNGdJQ0FxSUhObGJuUXVYRzRnSUNBcVhHNGdJQ0FxSUVCdFpYUm9iMlFnWlc1a1hHNGdJQ0FxSUVCd1lYSmhiU0I3Um5WdVkzUnBiMjU5SU02N0lIUm9aU0JqWVd4c1ltRmpheUJtZFc1amRHbHZiaTVjYmlBZ0lDb2dRSEpsZEhWeWJpQjdSR1Z3Ykc5NVVuMGdabTl5SUdOb1lXbHVhVzVuTGx4dUlDQWdLaUJBWVhCcElIQjFZbXhwWTF4dUlDQWdLaThnWEc0Z0lHVnVaRG9nWm5WdVkzUnBiMjRnS0dadUtTQjdYRzRnSUNBZ2RtRnlJSE5sYkdZZ0lDQTlJSFJvYVhNc1hHNGdJQ0FnSUNBZ0lIRWdJQ0FnSUNBOUlIUm9hWE11Y1N4Y2JpQWdJQ0FnSUNBZ1lYQnBJQ0FnSUQwZ2RHaHBjeTVoY0drc1hHNGdJQ0FnSUNBZ0lHRnlaM01nSUNBOUlHNTFiR3dzWEc0Z0lDQWdJQ0FnSUdWdWRHbDBlU0E5SUhSb2FYTXVabWxzZEdWeU8xeHVYRzRnSUNBZ2NTNWhaR1FvWm5WdVkzUnBiMjRvY21WemNHOXVjMlZEYUdGcGJpd2daWEp5YjNJc0lIQnlaWFpCY21kektTQjdYRzRnSUNBZ0lDQXZMeUJpY21WaGF5QjBhR1VnWTJGc2JDQmphR0ZwYmlCdmJpQmxjbkp2Y2lBZ0lDQWdJRnh1SUNBZ0lDQWdhV1lnS0dWeWNtOXlLU0I3SUNBZ0lDQWdJQ0JjYmlBZ0lDQWdJQ0FnZEdocGN5NWtaV1psY25KbFpDNXlaV3BsWTNRb1pYSnliM0lwT3lBZ0lDQWdJQ0FnWEc0Z0lDQWdJQ0FnSUhFdVpteDFjMmdvY21WemNHOXVjMlZEYUdGcGJpd2daWEp5YjNJc0lIQnlaWFpCY21kektUc2dMeThnWkhKaGFXNGdkR2hsSUhGMVpYVmxYRzRnSUNBZ0lDQWdJSFJvYVhNdVgyTnNaV0Z5S0NrN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5Ymp0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUZ4dUlDQWdJQ0FnZEdocGN5NWZjSEpsY0ZKbGNYVmxjM1FvY21WemNHOXVjMlZEYUdGcGJpd2djSEpsZGtGeVozTXBPMXh1WEc0Z0lDQWdJQ0JNYjJkblpYSXVhVzVtYnlnbmFXOG9LU2NzSUdGd2FTd2dkR2hwY3k1eVpYRXBPMXh1SUNBZ0lDQWdkR2hwY3k1c2IyZG5aWEl1YVc1bWJ5Z25hVzhvS1Njc0lHRndhU3dnZEdocGN5NXlaWEVwT3lBZ0lDQmNibHh1SUNBZ0lDQWdkR2hwY3k1eVpYRXVaVzVrS0daMWJtTjBhVzl1S0hKbGN5a2dlMXh1SUNBZ0lDQWdJQ0J6Wld4bUxuTm9ZWEpsS0hObGJHWXVZMjl2YTJsbGN5QjhmQ0J5WlhNdWFHVmhaR1Z5YzFzbmMyVjBMV052YjJ0cFpTZGRLVHNnSUNBZ0lDQWdJQ0JjYmx4dUlDQWdJQ0FnSUNBdkx5QXRMU0JzYjJjZ1kyOXZhMmxsY3lCaFkzSnZjM01nY21WeGRXVnpkSE1nTFMxY2JpQWdJQ0FnSUNBZ2FXWWdLSE5sYkdZdVkyOXZhMmxsY3lrZ2UxeHVJQ0FnSUNBZ0lDQWdJRXh2WjJkbGNpNXBibVp2S0NkamIyOXJhV1Z6Snl3Z1lYQnBMQ0J6Wld4bUxtTnZiMnRwWlhNcE95QmNiaUFnSUNBZ0lDQWdJQ0J6Wld4bUxteHZaMmRsY2k1cGJtWnZLQ2RqYjI5cmFXVnpKeXdnWVhCcExDQnpaV3htTG1OdmIydHBaWE1wT3lCY2JpQWdJQ0FnSUNBZ2ZWeHVYRzRnSUNBZ0lDQWdJR1Z5Y205eUlEMGdjMlZzWmk1ZmFHRnVaR3hsUlhKeWIzSW9jbVZ6S1R0Y2JpQWdJQ0FnSUNBZ2RtRnlJR1J5WlhNZ1BTQW9jbVZ6TG1KdlpIa2dKaVlnY21WekxtSnZaSGt1WkdWd2JHOTVjaUEvSUhKbGN5NWliMlI1SURvZ2NtVnpLVHNnSUNBZ0lDQWdJQ0FnSUNBZ1hHNGdJQ0FnSUNCY2JpQWdJQ0FnSUNBZ2MyVnNaaTVwYm5CMWRITWdQU0JiWFR0Y2JpQWdJQ0FnSUNBZ2MyVnNaaTV2ZFhSd2RYUnpJRDBnVzEwN1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0NGbGNuSnZjaWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQXZMeUF0TFNCTWIyY2daMnh2WW1Gc0lDc2dkSEpoYm5OaFkzUnBiMjRnYkc5bklDMHRYRzRnSUNBZ0lDQWdJQ0FnSUV4dloyZGxjaTVwYm1adktDZGxibVFvS1Njc0lHRndhU3dnWkhKbGN5d2djbVZ6S1R0Y2JpQWdJQ0FnSUNBZ0lDQWdjMlZzWmk1c2IyZG5aWEl1YVc1bWJ5Z25aVzVrS0NrbkxDQmhjR2tzSUdSeVpYTXNJSEpsY3lrN1hHNWNiaUFnSUNBZ0lDQWdJQ0FnTHk4Z0xTMGdkMkZzYXlCeVpYTndiMjV6WlNCbWIzSWdkRzl3TFd4bGRtVnNJR1Z1ZEdsMGVTQnlaWE53YjI1elpTQmhjM05wWjI1dFpXNTBJQzB0SUNBZ0lDQWdJQ0JjYmlBZ0lDQWdJQ0FnSUNBZ2FXWWdLR1Z1ZEdsMGVTa2dleUJrY21WeklEMGdaSEpsY3k1a1pYQnNiM2x5TG5KbGMzQnZibk5sVzJWdWRHbDBlVjBnZkh3Z1pISmxjenNnZlZ4dVhHNGdJQ0FnSUNBZ0lDQWdJR1J5WlhNdVoyVjBJRDBnWm5WdVkzUnBiMjRvYTJWNUtTQjdJRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2RYUnBiSE11WjJWMEtHUnlaWE11WkdWd2JHOTVjaTV5WlhOd2IyNXpaU3dnYTJWNUtUc2dYRzRnSUNBZ0lDQWdJQ0FnSUgwN1hHNWNiaUFnSUNBZ0lDQWdJQ0FnWkhKbGN5NTNiM0pyYzNCaFkyVWdQU0JtZFc1amRHbHZiaWh1WVcxbEtTQjdJRnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2RYUnBiSE11ZDI5eWEzTndZV05sS0dSeVpYTXVaR1Z3Ykc5NWNpNXlaWE53YjI1elpTd2dibUZ0WlNrN0lGeHVJQ0FnSUNBZ0lDQWdJQ0I5TzF4dVhHNGdJQ0FnSUNBZ0lDQWdJQzh2SUMwdElHTmhiR3hpWVdOcklDMHRYRzRnSUNBZ0lDQWdJQ0FnSUdsbUlDaG1iaWtnZXlCaGNtZHpJRDBnWm00dVlYQndiSGtvYzJWc1ppNXpZMjl3WlN3Z1cyUnlaWE1zSUhKbGMzQnZibk5sUTJoaGFXNWRLVHQ5WEc1Y2JpQWdJQ0FnSUNBZ0lDQWdMeThnTFMwZ2JtOTBhV1o1SUhSb1lYUWdkR2hsSUhGMVpYVmxJR2hoY3lCaVpXVnVJR1J5WVdsdVpXUXVMaTRnTFMxY2JpQWdJQ0FnSUNBZ0lDQWdhV1lnS0hFdWMybDZaU2dwSUQwOVBTQXdLU0I3SUZ4dUlDQWdJQ0FnSUNBZ0lDQWdJSE5sYkdZdVgyTnNaV0Z5S0NrN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnYzJWc1ppNWtaV1psY25KbFpDNXlaWE52YkhabEtISmxjM0J2Ym5ObFEyaGhhVzRnZkh3Z1pISmxjeWs3WEc0Z0lDQWdJQ0FnSUNBZ0lIMGdJQ0FnSUNBZ0lDQWdYRzVjYmlBZ0lDQWdJQ0FnSUNBZ0x5OGdMUzBnYVc1amJIVmtaU0JqYjI5cmFXVnpJR2x1SUc1bGVIUWdjbVZ4ZFdWemRDQnBiaUIwYUdVZ2NYVmxkV1VnTFMxY2JpQWdJQ0FnSUNBZ0lDQWdZWEpuY3lBOUlHMWxjbWRsS0dGeVozTXNJSHNnWDE5amIyOXJhV1Z6WDE4NklITmxiR1l1WTI5dmEybGxjeUI5S1RzZ0lDQWdJQ0FnSUNBZ1hHNGdJQ0FnSUNBZ0lIMGdJQ0FnSUNBZ0lGeHVYRzRnSUNBZ0lDQWdJSEV1ZVdsbGJHUW9abUZzYzJVcE8xeHVJQ0FnSUNBZ0lDQnhMbVpzZFhOb0tHUnlaWE1zSUdWeWNtOXlMQ0JoY21kektUc2dMeThnY0dGemN5QnlaWE4xYkhSOFpYSnliM0o4WVhKbmN5QjBieUJ1WlhoMElGeHVJQ0FnSUNBZ2ZTazdYRzVjYmlBZ0lDQWdJSEV1ZVdsbGJHUW9kSEoxWlNrN1hHNGdJQ0FnZlN3Z2RHaHBjeXdnZEdocGN5NWtaV3hoZVdWa0tUdGNiaUFnWEc0Z0lDQWdhV1lnS0NGMGFHbHpMbVJsYkdGNVpXUWdKaVlnY1M1emFYcGxLQ2tnUEQwZ01Ta2dleUJ4TG1ac2RYTm9LQ2s3SUgxY2JseHVJQ0FnSUhKbGRIVnliaUIwYUdsek8xeHVJQ0I5TENCY2JseHVJQ0F2S2lvZ1hHNGdJQ0FxSUVGa1pDQmhiaUJoWkdScGRHbHZibUZzSUVsUElISmxjWFZsYzNRZ2RHOGdkR2hsSUdWNGMybHpkR2x1WnlCelpYRjFaVzUwYVdGc0lISmxjWFZsYzNRZ1kyaGhhVzR1WEc0Z0lDQXFYRzRnSUNBcUlFQnRaWFJvYjJRZ2FXOWNiaUFnSUNvZ1FIQmhjbUZ0SUh0VGRISnBibWQ5SUdGd2FTQlBibVVnYjJZZ2RHaGxJSE4xY0hCdmNuUmxaQ0JFWlhCc2IzbFNJRUZRU1hNdVhHNGdJQ0FxSUVCeVpYUjFjbTRnZTBSbGNHeHZlVko5SUdadmNpQmphR0ZwYm1sdVp5NWNiaUFnSUNvZ1FHRndhU0J3ZFdKc2FXTmNiaUFnSUNvdklDQWdYRzRnSUdsdk9pQm1kVzVqZEdsdmJpQW9ZWEJwS1NCN0lDQWdJRnh1SUNBZ0lISmxkSFZ5YmlCRVpYQnNiM2xTTG01bGR5aGhjR2tzSUhzZ1hHNGdJQ0FnSUNCamIyOXJhV1Z6T2lCMGFHbHpMbU52YjJ0cFpYTXNJRnh1SUNBZ0lDQWdjWFZsZFdVNklIUm9hWE11Y1N3Z1hHNGdJQ0FnSUNCa1pXWmxjbkpsWkRvZ2RHaHBjeTVrWldabGNuSmxaRnh1SUNBZ0lIMHBPMXh1SUNCOUxGeHVYRzRnSUM4cUtpQmNiaUFnSUNvZ1EyOXVkbVZ1YVdWdVkyVWdablZ1WTNScGIyNGdabTl5SUdGa1pHbHVaeUJoYmlCaFpHUnBkR2x2Ym1Gc0lITmpjbWx3ZENCbGVHVmpkWFJwYjI0Z2RHOGdkR2hsSUZ4dUlDQWdLaUJsZUhOcGMzUnBibWNnYzJWeGRXVnVkR2xoYkNCeVpYRjFaWE4wSUdOb1lXbHVMbHh1SUNBZ0tseHVJQ0FnS2lCQWJXVjBhRzlrSUhOamNtbHdkRnh1SUNBZ0tpQkFjR0Z5WVcwZ2UwRnlaM1Z0Wlc1MGMzMGdRWEpuZFcxbGJuUnpJSFJ2SUdSbFptbHVaU0IwYUdVZ1puVnNiSGtnY1hWaGJHbG1hV1ZrSUhOamNtbHdkQ0JtYjNJZ1hHNGdJQ0FxSUdWNFpXTjFkR2x2Ymk1Y2JpQWdJQ29nUUhKbGRIVnliaUI3UkdWd2JHOTVVbjBnWm05eUlHTm9ZV2x1YVc1bkxpQWdJRnh1SUNBZ0tpQkFZWEJwSUhCMVlteHBZMXh1SUNBZ0tpOWNiaUFnYzJOeWFYQjBPaUJtZFc1amRHbHZiaWdwSUh0Y2JpQWdJQ0FnZG1GeUlHRnlaM01nUFNCMWRHbHNjeTV6YVdkdVlYUjFjbVVvWVhKbmRXMWxiblJ6S1N4Y2JpQWdJQ0FnSUNBZ0lHOXdkSE1nUFNCaGNtZHpMbTl3ZEhNc1hHNGdJQ0FnSUNBZ0lDQmhjR2tnSUQwZ1lYSm5jeTVoY0drc1hHNGdJQ0FnSUNBZ0lDQnNhVzVySUQwZ2V5QmNiaUFnSUNBZ0lDQWdJQ0JqYjI5cmFXVnpPaUIwYUdsekxtTnZiMnRwWlhNc0lGeHVJQ0FnSUNBZ0lDQWdJSEYxWlhWbE9pQjBhR2x6TG5Fc0lGeHVJQ0FnSUNBZ0lDQWdJR1JsWm1WeWNtVmtPaUIwYUdsekxtUmxabVZ5Y21Wa1hHNGdJQ0FnSUNBZ0lIMDdJQ0JjYmx4dUlDQWdJQzh2SUdOdmJuWmxibWxsYm1ObElDMGdhV1lnZEdobElIQnliMnBsWTNRZ2FYTWdZU0JpYjI5c1pXNGdZSFJ5ZFdWZ0lISmhkR2hsY2lCMGFHRnVJR0VnY0dsa0xDQm1hWEp6ZEZ4dUlDQWdJQzh2SUdOeVpXRjBaU0JoSUc1bGR5QndjbTlxWldOMElHRnVaQ0IwYUdWdUlIQnlaWEJoY21VZ2RHaGxJSEJ5YjJwbFkzUWdZWEJwSUdOaGJHd2dkRzhnWlhobFkzVjBaVnh1SUNBZ0lHbG1JQ2hoY21kekxtTnlaV0YwWlNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUVSbGNHeHZlVkl1Ym1WM0tDY3ZjaTl3Y205cVpXTjBMMk55WldGMFpTY3NJR3hwYm1zcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdVpXNWtLR1oxYm1OMGFXOXVLSEpsY3lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIc2djSEp2YW1WamREb2djbVZ6TG1kbGRDZ25jSEp2YW1WamRDY3BMbkJ5YjJwbFkzUWdmVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0I5S1Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnTG1sdktHRndhU2xjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQzVrWVhSaEtHOXdkSE1wTzF4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1JHVndiRzk1VWk1dVpYY29ZWEJwTENCc2FXNXJLUzVrWVhSaEtHOXdkSE1wTzF4dUlDQWdJSDBnSUNBZ1hHNGdJSDBzWEc1Y2JpQWdMeW9xSUZ4dUlDQWdLaUJEYjI1MlpXNXBaVzVqWlNCbWRXNWpkR2x2YmlCbWIzSWdZV1JrYVc1bklHRnVJR0ZrWkdsMGFXOXVZV3dnY21Wd2IzTnBkRzl5ZVMxdFlXNWhaMlZrSUhOb1pXeHNJRnh1SUNBZ0tpQnpZM0pwY0hRZ1pYaGxZM1YwYVc5dUlIUnZJSFJvWlNCbGVITnBjM1JwYm1jZ2MyVnhkV1Z1ZEdsaGJDQnlaWEYxWlhOMElHTm9ZV2x1TGx4dUlDQWdLbHh1SUNBZ0tpQlVhR2x6SUdOaGJHd2daWGhsWTNWMFpYTWdjbVZ3YjNOcGRHOXllUzF0WVc1aFoyVmtJSE5vWld4c0lITmpjbWx3ZEhNZ0xuTm9MQ0F1WTNOb0xDQXVZbUZ6YUN3Z0xtSmhkQ0JjYmlBZ0lDb2diMjRnZEdobElFUmxjR3h2ZVZJZ2MyVnlkbVZ5TGlCRWRXVWdkRzhnZEdobElITndaV05wWVd3Z2MyVmpkWEpwZEhrZ1kyOXVZMlZ5Ym5NZ1lYTnpiMk5wWVhSbFpDQjNhWFJvSUZ4dUlDQWdLaUJsZUdOMWRHbHVaeUJ6YUdWc2JDQnpZM0pwY0hSeklHOXVJSFJvWlNCRVpYQnNiM2xTSUhObGNuWmxjaXdnYjI1c2VTQnphR1ZzYkNCelkzSnBjSFJ6SUc5M2JtVmtJR0o1SUZ4dUlDQWdLaUJmUVVSTlNVNUpVMVJTUVZSUFVsOGdkWE5sY25NZ1kyRnVJR0psSUdWNFpXTjFkR1ZrSUc5dUlIUm9hWE1nUVZCSklHTmhiR3d1SUVGdWVTQmhkSFJsYlhCMElIUnZJRnh1SUNBZ0tpQmxlR1ZqZFhSbElHRWdjMmhsYkd3Z2MyTnlhWEIwSUhOMGIzSmxaQ0JwYmlCMGFHVWdjbVZ3YjNOcGRHOXllU0IwYUdGMElHbHpJRzV2ZENCdmQyNWxaQ0JpZVNCaGJpQmNiaUFnSUNvZ1gwRkVUVWxPU1ZOVVVrRlVUMUpmSUhWelpYSWdkMmxzYkNCaVpTQnlaV3BsWTNSbFpDNWNiaUFnSUNwY2JpQWdJQ29nVkc4Z1pYaGxZM1YwWlNCaElISmxjRzl6YVhSdmNua3RiV0Z1WVdkbFpDQnphR1ZzYkNCelkzSnBjSFFnZEdobElHTmhiR3hsY2lCdGRYTjBJSEJ5YjNacFpHVWdYRzRnSUNBcUlIQmhjbUZ0WlhSbGNpQjJZV3gxWlhNZ1ptOXlJRjloZFhSb2IzSmZMQ0JmWkdseVpXTjBiM0o1WHl3Z1gyWnBiR1Z1WVcxbFh5NGdWR2hwY3lCallXNGdZbVZjYmlBZ0lDb2dZV05vYVdWMlpXUWdZbmtnY0hKdmRtbGthVzVuSUdFZ1puVnNiSGtnY1hWaGJHbG1hV1ZrSUhOb1pXeHNJSE5qY21sd2RDQmNiaUFnSUNvZ1lDODhZWFYwYUc5eVBpODhaR2x5WldOMGIzSjVQaTg4Wm1sc1pXNWhiV1UrWUN3Z1ptOXlJR1Y0WVcxd2JHVTZYRzRnSUNBcVhHNGdJQ0FxSUNCZ1lHQmNiaUFnSUNvZ0lDNXphR1ZzYkNnbkwyRmtiV2x1TDJWNGRHVnlibUZzT25CMVlteHBZenBoWkcxcGJpOWxZMmh2TG5Ob0p5d2dKMlZqYUc4dWMyZ2dZWEpuY3lCMGJ5QndZWE56TGljcFhHNGdJQ0FxSUNCZ1lHQmNiaUFnSUNwY2JpQWdJQ29nUUcxbGRHaHZaQ0J6YUdWc2JGeHVJQ0FnS2lCQWNHRnlZVzBnZTFOMGNtbHVaMzBnWm1sc1pYQmhkR2dnZEc4Z1pHVm1hVzVsSUhSb1pTQm1kV3hzZVNCeGRXRnNhV1pwWldRZ2MyaGxiR3dnYzJOeWFYQjBJR1p2Y2x4dUlDQWdLaUJsZUdWamRYUnBiMjR1SUZ4dUlDQWdLaUJBY0dGeVlXMGdlMU4wY21sdVozMGdZWEpuY3lBb2IzQjBhVzl1WVd3cElHRnlaM1Z0Wlc1MGN5QjBieUJpWlNCd1lYTnpaV1FnYVc1MGJ5QjBhR1VnYzJobGJHd2dYRzRnSUNBcUlITmpjbWx3ZENCdmJpQmxlR1ZqZFhScGIyNHVYRzRnSUNBcUlFQnlaWFIxY200Z2UwUmxjR3h2ZVZKOUlHWnZjaUJqYUdGcGJtbHVaeTRnSUNCY2JpQWdJQ29nUUdGd2FTQndkV0pzYVdOY2JpQWdJQ292WEc0Z0lITm9aV3hzT2lCbWRXNWpkR2x2Ymlod1lYUm9MQ0JoY21kektTQjdJQ0FnWEc0Z0lDQWdkbUZ5SUd4cGJtc2dQU0I3SUZ4dUlDQWdJQ0FnSUNBZ0lHTnZiMnRwWlhNNklIUm9hWE11WTI5dmEybGxjeXdnWEc0Z0lDQWdJQ0FnSUNBZ2NYVmxkV1U2SUhSb2FYTXVjU3dnWEc0Z0lDQWdJQ0FnSUNBZ1pHVm1aWEp5WldRNklIUm9hWE11WkdWbVpYSnlaV1JjYmlBZ0lDQWdJQ0FnZlN4Y2JpQWdJQ0FnSUNBZ2RHOXJaVzV6SUQwZ1RHRnVaeTVwYzFOMGNtbHVaeWh3WVhSb0tTQS9JSEJoZEdndWMzQnNhWFFvSjF4Y0x5Y3BJRG9nVzEwN1hHNWNiaUFnSUNBdkx5Qm9ZVzVrYkdVZ1ltOTBhRG9nWUM5aGRYUm9iM0l2WkdseVpXTjBiM0o1TDJacGJHVnVZVzFsWUNBbUlHQmhkWFJvYjNJdlpHbHlaV04wYjNKNUwyWnBiR1Z1WVcxbFlGeHVJQ0FnSUdsbUlDaDBiMnRsYm5NdWJHVnVaM1JvSUQ0Z015a2dleUIwYjJ0bGJuTWdQU0IwYjJ0bGJuTXVjMnhwWTJVb01TazdJSDFjYmx4dUlDQWdJSEpsZEhWeWJpQkVaWEJzYjNsU0xtNWxkeWduTDNJdmNtVndiM05wZEc5eWVTOXphR1ZzYkM5bGVHVmpkWFJsSnl3Z2JHbHVheWt1WkdGMFlTaDdYRzRnSUNBZ0lDQmhkWFJvYjNJNklIUnZhMlZ1YzFzd1hTeGNiaUFnSUNBZ0lHUnBjbVZqZEc5eWVUb2dkRzlyWlc1eld6RmRMRnh1SUNBZ0lDQWdabWxzWlc1aGJXVTZJSFJ2YTJWdWMxc3lYU3hjYmlBZ0lDQWdJR0Z5WjNNNklHRnlaM05jYmlBZ0lDQjlLVHRjYmlBZ2ZTeGNibHh1SUNBdktpb2dYRzRnSUNBcUlFTnZiblpsYm1sbGJtTmxJR1oxYm1OMGFXOXVJR1p2Y2lCbGVHVmpkWFJwYm1jZ1lTQmliRzlqYXlCdlppQlNJR052WkdVZ2IyNGdkR2hsSUZJZ2MyVnpjMmx2Ymk1Y2JseHVJQ0FnS2lCRmVHRnRjR3hsT2x4dUlDQWdLaUFnWUdCZ1hHNGdJQ0FxSUNBdVkyOWtaU2duZUR3dE5TY3BYRzRnSUNBcUlDQXZMeUF0TFNCdmNpQXRMVnh1SUNBZ0tpQWdMbU52WkdVb0ozZzhMVFVuTENCd2NtOXFaV04wU1dRcFhHNGdJQ0FxSUNCZ1lHQmNiaUFnSUNvZ0lDQmNiaUFnSUNvZ1FHMWxkR2h2WkNCamIyUmxYRzRnSUNBcUlFQndZWEpoYlNCN1UzUnlhVzVuZlNCeUlDMGdWR2hsSUdKc2IyTnJJRzltSUZJZ1kyOWtaU0IwYnlCbGVHVmpkWFJsTGx4dUlDQWdLaUJBY0dGeVlXMGdlMU4wY21sdVozMGdjSEp2YW1WamRDQXRJQ2h2Y0hScGIyNWhiQ2tnYVdZZ2IyMXBkSFJsWkNCaElHNWxkeUJ3Y205cVpXTjBJSGRwYkd3Z1ptbHljM1FnWW1VZ1hHNGdJQ0FxSUdOeVpXRjBaV1FnWVc1a0lIVnpaV1FzSUc5MGFHVnlkMmx6WlNCcGRDQjNhV3hzSUdWNFpXTjFkR1VnYjI0Z2RHaGxJRklnYzJWemMybHZiaUJwWkdWdWRHbG1hV1ZrSUdKNUlGeHVJQ0FnS2lCMGFHbHpJR0J3Y205cVpXTjBZQzVjYmlBZ0lDb2dRSEpsZEhWeWJpQjdSR1Z3Ykc5NVVuMGdabTl5SUdOb1lXbHVhVzVuTGlBZ0lGeHVJQ0FnS2lCQVlYQnBJSEIxWW14cFkxeHVJQ0FnS2k5Y2JpQWdZMjlrWlRvZ1puVnVZM1JwYjI0b2Npd2djSEp2YW1WamRDa2dlMXh1SUNBZ0lDQjJZWElnYkdsdWF5QTlJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjlyYVdWek9pQjBhR2x6TG1OdmIydHBaWE1zWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdjWFZsZFdVNklIUm9hWE11Y1N4Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0JrWldabGNuSmxaRG9nZEdocGN5NWtaV1psY25KbFpGeHVJQ0FnSUNBZ0lDQWdmU3hjYmlBZ0lDQWdJQ0FnSUdGd2FTQTlJQ2N2Y2k5d2NtOXFaV04wTDJWNFpXTjFkR1V2WTI5a1pTYzdYRzVjYmlBZ0lDQWdhV1lnS0NGd2NtOXFaV04wS1NCN1hHNGdJQ0FnSUNBZ0lDQnlaWFIxY200Z1JHVndiRzk1VWk1dVpYY29KeTl5TDNCeWIycGxZM1F2WTNKbFlYUmxKeXdnYkdsdWF5bGNiaUFnSUNBZ0lDQWdJQ0FnSUNBdVpXNWtLR1oxYm1OMGFXOXVLSEpsY3lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnlaWFIxY200Z2V5QndjbTlxWldOME9pQnlaWE11WjJWMEtDZHdjbTlxWldOMEp5a3VjSEp2YW1WamRDQjlPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lIMHBYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0xtbHZLR0Z3YVNsY2JpQWdJQ0FnSUNBZ0lDQWdJQ0F1WkdGMFlTaDdJR052WkdVNklISWdmU2s3WEc0Z0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdSR1Z3Ykc5NVVpNXVaWGNvWVhCcExDQnNhVzVyS1M1a1lYUmhLSHNnWTI5a1pUb2djaXdnY0hKdmFtVmpkRG9nY0hKdmFtVmpkQ0I5S1R0Y2JpQWdJQ0FnZlZ4dUlDQjlMRnh1SUNCY2JpQWdMeW9xSUZ4dUlDQWdLaUJTWld4bFlYTmxJR0Z1ZVNCeVpYTnBaSFZoYkNCd2NtOXFaV04wSUhKbGMyOTFjbU5sY3lCaGMzTnZZMmxoZEdWa0lIZHBkR2dnZEdobElHRndjR3hwWTJGMGFXOXVJRnh1SUNBZ0tpQnBibk4wWVc1alpTQjNhR1Z1WlhabGNpQmhJR05zYVdWdWRDQmhjSEJzYVdOaGRHbHZiaUIwWlhKdGFXNWhkR1Z6TGlCVWFHbHpJR2x1WTJ4MVpHVnpJR05zYjNOcGJtY2dYRzRnSUNBcUlHRnVlU0J6ZFhCd2JHbGxaQ0J3Y205cVpXTjBjeUJrYjNkdUlHRnVaQ0JzYjJkbmFXNW5JRzkxZEM1Y2JpQWdJQ3BjYmlBZ0lDb2dRRzFsZEdodlpDQnlaV3hsWVhObFhHNGdJQ0FxSUVCd1lYSmhiU0I3VTNSeWFXNW5mRUZ5Y21GNWZTQndjbTlxWldOMGN5QlVhR1VnY0hKdmFtVmpkQ0J2Y2lCc2FYTjBJRzltSUhCeWIycGxZM1J6SUhSdklHTnNiM05sTGx4dUlDQWdLaUJBY0dGeVlXMGdlMEp2YjJ4bFlXNTlJR0YxZEdnZ0tHOXdkR2x2Ym1Gc0tTQjBieUJ5WlcxaGFXNGdZWFYwYUdWdWRHbGpZWFJsWkM1Y2JpQWdJQ29nUUhKbGRIVnliaUI3UkdWd2JHOTVVbjBnWm05eUlHTm9ZV2x1YVc1bkxpQWdJRnh1SUNBZ0tpQkFZWEJwSUhCMVlteHBZMXh1SUNBZ0tpOWNiaUFnY21Wc1pXRnpaVG9nWm5WdVkzUnBiMjRvY0hKdmFtVmpkSE1zSUdGMWRHZ3BJSHRjYmlBZ0lDQWdjSEp2YW1WamRITWdQU0JNWVc1bkxtbHpRWEp5WVhrb2NISnZhbVZqZEhNcElEOGdjSEp2YW1WamRITWdPaUJiY0hKdmFtVmpkSE5kTzF4dVhHNGdJQ0FnSUhaaGNpQnpaV3htSUNBZ0lDQTlJSFJvYVhNc1hHNGdJQ0FnSUNBZ0lDQmtaV1psY25KbFpDQTlJRVFvS1N4Y2JpQWdJQ0FnSUNBZ0lHVnRjSFI1SUNBZ0lEMGdJWEJ5YjJwbFkzUnpJSHg4SUNGd2NtOXFaV04wYzFzd1hTeGNiaUFnSUNBZ0lDQWdJR052ZFc1MElDQWdJRDBnTUN4Y2JpQWdJQ0FnSUNBZ0lHeGhjM1FnSUNBZ0lEMGdJV1Z0Y0hSNUlEOGdjSEp2YW1WamRITXViR1Z1WjNSb0lDMGdNU0E2SUdOdmRXNTBMRnh1SUNBZ0lDQWdJQ0FnWTI5dmEybGxjeUFnUFNCMGFHbHpMbWRsZEVOdmIydHBaWE1vS1RzZ0lDQWdJQ0FnSUNBZ0lGeHVYRzRnSUNBZ1puVnVZM1JwYjI0Z2JHOW5iM1YwS0dsdVpHVjRLU0I3WEc0Z0lDQWdJQ0JwWmlBb2FXNWtaWGdnUFQwOUlHeGhjM1FwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0ZoZFhSb0tTQjdYRzRnSUNBZ0lDQWdJQ0FnUkdWd2JHOTVVaTV1Wlhjb0p5OXlMM1Z6WlhJdmJHOW5iM1YwSnlsY2JpQWdJQ0FnSUNBZ0lDQXVjMmhoY21Vb1kyOXZhMmxsY3lsY2JpQWdJQ0FnSUNBZ0lDQXVaWEp5YjNJb1puVnVZM1JwYjI0b0tTQjdJQ0FnSUNBZ0lDQWdJRnh1SUNBZ0lDQWdJQ0FnSUNBZ1pHVm1aWEp5WldRdWNtVnFaV04wS0daaGJITmxLVHRjYmlBZ0lDQWdJQ0FnSUNCOUtTQWdJQ0FnSUZ4dUlDQWdJQ0FnSUNBZ0lDNWxibVFvWm5WdVkzUnBiMjRvS1NCN0lGeHVJQ0FnSUNBZ0lDQWdJQ0FnWkdWbVpYSnlaV1F1Y21WemIyeDJaU2gwY25WbEtUdGNiaUFnSUNBZ0lDQWdJQ0I5S1Z4dUlDQWdJQ0FnSUNBZ0lDNWxibk4xY21Vb1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCelpXeG1MbVJsYzNSeWIza29LVHRjYmlBZ0lDQWdJQ0FnSUNCOUtUdGNiaUFnSUNBZ0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lDQWdJQ0JrWldabGNuSmxaQzV5WlhOdmJIWmxLSFJ5ZFdVcE8xeHVJQ0FnSUNBZ0lDQWdJSE5sYkdZdVpHVnpkSEp2ZVNncE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlJRnh1SUNBZ0lIMWNibHh1SUNBZ0lHbG1JQ2doWlcxd2RIa3BJSHRjYmlBZ0lDQWdJSEJ5YjJwbFkzUnpMbVp2Y2tWaFkyZ29ablZ1WTNScGIyNG9jSEp2YW1WamRDa2dlMXh1SUNBZ0lDQWdJQ0JFWlhCc2IzbFNMbTVsZHlnbkwzSXZjSEp2YW1WamRDOWpiRzl6WlNjcFhHNGdJQ0FnSUNBZ0lDNWtZWFJoS0hzZ2NISnZhbVZqZERvZ2NISnZhbVZqZENCOUtWeHVJQ0FnSUNBZ0lDQXVjMmhoY21Vb1kyOXZhMmxsY3lsY2JpQWdJQ0FnSUNBZ0xtVnVaQ2dwWEc0Z0lDQWdJQ0FnSUM1bGJuTjFjbVVvWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNBZ0lDQWdiRzluYjNWMEtHTnZkVzUwS1R0Y2JpQWdJQ0FnSUNBZ0lDQmpiM1Z1ZENzck8xeHVJQ0FnSUNBZ0lDQjlLVHRjYmlBZ0lDQWdJSDBwT3lBZ0lGeHVJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0JzYjJkdmRYUW9ZMjkxYm5RcE8xeHVJQ0FnSUgxY2JseHVJQ0FnSUhKbGRIVnliaUJrWldabGNuSmxaQzV3Y205dGFYTmxPeUFnWEc0Z0lIMHNJQ0JjYmx4dUlDQXZLaW9nWEc0Z0lDQXFJRUVnWTI5dWRtVnVhV1Z1WTJVZ1lXeDBaWEp1WVhScGRtVWdkRzhnYlhWc2RHbHdiR1VnWUM1eWFXNXdkWFFvS1dBZ1kyRnNiSE11SUVSbFptbHVaWE1nWVNCdVlXMWxJRnh1SUNBZ0tpQnNhWE4wSUc5bUlGSWdiMkpxWldOMGN5QjBhR0YwSUhkcGJHd2dZbVVnY21WMGRYSnVaV1FnWVhNZ1JHVndiRzk1VWkxbGJtTnZaR1ZrSUZJZ2IySnFaV04wY3lCdmJpQjBhR1VnWEc0Z0lDQXFJSEpsYzNCdmJuTmxJRzFoY210MWNDNWNiaUFnSUNwY2JpQWdJQ29nUTJGc2JHbHVaeUIwYUdseklHMWxkR2h2WkNCK0xuSnZkWFJ3ZFhSektGc2dMaTR1SUYwcFlDQnBjeUJsY1hWcGRtRnNaVzUwSUhSdklHbHVkbTlyYVc1bklHMTFiSFJwY0d4bElGeHVJQ0FnS2lCZ0xuSnZkWFJ3ZFhRb0xpNHVLV0FnWTJGc2JITXVYRzRnSUNBcVhHNGdJQ0FxSUVCdFpYUm9iMlFnY205MWRIQjFkSE5jYmlBZ0lDb2dRSEJoY21GdElIdEJjbkpoZVgwZ2NtOWlhbVZqZEhNZ1FTQnVZVzFsSUd4cGMzUWdiMllnVWlCdlltcGxZM1J6SUhSb1lYUWdkMmxzYkNCaVpTQnlaWFIxY201bFpDNWNiaUFnSUNvZ1FISmxkSFZ5YmlCN1JHVndiRzk1VW4wZ1ptOXlJR05vWVdsdWFXNW5MaUFnSUZ4dUlDQWdLaUJBWVhCcElIQjFZbXhwWTF4dUlDQWdLaTljYmlBZ2NtOTFkSEIxZEhNNklHWjFibU4wYVc5dUlDaHliM1YwY0hWMGN5a2dlMXh1SUNBZ0lHbG1JQ2h5YjNWMGNIVjBjeWtnZXlCMGFHbHpMbTkxZEhCMWRITWdQU0IwYUdsekxtOTFkSEIxZEhNdVkyOXVZMkYwS0hKdmRYUndkWFJ6S1RzZ2ZWeHVYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTTdYRzRnSUgwc1hHNGdJRnh1SUNBdktpb2dYRzRnSUNBcUlFUmxabWx1WlhNZ2RHaGxJRzVoYldVZ2IyWWdkR2hsSUZJZ2IySnFaV04wSUhSb1lYUWdkMmxzYkNCaVpTQnlaWFIxY201bFpDQmhjeUJoSUVSbGNHeHZlVkl0Wlc1amIyUmxaQ0JjYmlBZ0lDb2dVaUJ2WW1wbFkzUWdiMjRnZEdobElISmxjM0J2Ym5ObElHMWhjbXQxY0M1Y2JpQWdJQ3BjYmlBZ0lDb2dRRzFsZEdodlpDQnliM1YwY0hWMFhHNGdJQ0FxSUVCd1lYSmhiU0I3VTNSeWFXNW5mU0J5YjJKcVpXTjBJRlJvWlNCdVlXMWxJRzltSUhSb1pTQlNJRzlpYW1WamRDQjBhR0YwSUhkcGJHd2dZbVVnY21WMGRYSnVaV1F1WEc0Z0lDQXFJRUJ5WlhSMWNtNGdlMFJsY0d4dmVWSjlJR1p2Y2lCamFHRnBibWx1Wnk0Z0lDQmNiaUFnSUNvZ1FHRndhU0J3ZFdKc2FXTmNiaUFnSUNvdlhHNGdJSEp2ZFhSd2RYUTZJR1oxYm1OMGFXOXVJQ2h5YjNWMGNIVjBLU0I3WEc0Z0lDQWdhV1lnS0hKdmRYUndkWFFwSUhzZ2RHaHBjeTV5YjNWMGNIVjBjeWhiY205MWRIQjFkRjBwT3lCOVhHNWNiaUFnSUNCeVpYUjFjbTRnZEdocGN6dGNiaUFnZlN4Y2JseHVJQ0F2S2lvZ1hHNGdJQ0FxSUZWelpXUWdkRzhnY0dGemN5QnRkV3gwYVhCc1pTQnBibkIxZEhNZ1lYUWdiMjVqWlNCbWNtOXRJRXBoZG1GVFkzSnBjSFFnZEc4Z1lXNGdVaUJ6WTNKcGNIUWdkWE5wYm1jZ1hHNGdJQ0FxSUc5dVpTQnZaaUIwYUdVZ1pHVm1hVzVsWkNCZ1VrbHVjSFYwWUNCbVlXTjBiM0pwWlhNdVhHNGdJQ0FxWEc0Z0lDQXFJRUJ0WlhSb2IyUWdjbWx1Y0hWMGMxeHVJQ0FnS2lCQWNHRnlZVzBnZTBGeWNtRjVmU0J5YVc1d2RYUnpJRlJvWlNCZ1VrbHVjSFYwWUNCc2FYTjBJRzltSUVSbGNHeHZlVkl0YzNCbFkybG1hV01nWlc1amIyUmxaQ0JTSUZ4dUlDQWdLaUJ2WW1wbFkzUWdaR0YwWVNCbWIzSWdkWE5sSUc5dUlHRnVJRUZRU1NCallXeHNMbHh1SUNBZ0tpQkFjbVYwZFhKdUlIdEVaWEJzYjNsU2ZTQm1iM0lnWTJoaGFXNXBibWN1SUNBZ1hHNGdJQ0FxSUVCaGNHa2djSFZpYkdsalhHNGdJQ0FxTDF4dUlDQnlhVzV3ZFhSek9pQm1kVzVqZEdsdmJpQW9jbWx1Y0hWMGN5a2dlMXh1SUNBZ0lHbG1JQ2h5YVc1d2RYUnpLU0I3SUhSb2FYTXVhVzV3ZFhSeklEMGdkR2hwY3k1cGJuQjFkSE11WTI5dVkyRjBLSEpwYm5CMWRITXBPeUI5WEc1Y2JpQWdJQ0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdmU3hjYmx4dUlDQXZLaW9nWEc0Z0lDQXFJRlZ6WldRZ2RHOGdjR0Z6Y3lCdGRXeDBhWEJzWlNCcGJuQjFkSE1nWVhRZ2IyNWpaU0JtY205dElFcGhkbUZUWTNKcGNIUWdkRzhnWVc0Z1VpQnpZM0pwY0hRZ2RYTnBibWNnWEc0Z0lDQXFJRzl1WlNCdlppQjBhR1VnWkdWbWFXNWxaQ0JnVWtsdWNIVjBZQ0JtWVdOMGIzSnBaWE11WEc0Z0lDQXFYRzRnSUNBcUlFQnRaWFJvYjJRZ2NtbHVjSFYwWEc0Z0lDQXFJRUJ3WVhKaGJTQjdVa2x1Y0hWMGZTQnlhVzV3ZFhRZ1ZHaGxJRVJsY0d4dmVWSXRjM0JsWTJsbWFXTWdaVzVqYjJSbFpDQlNJRzlpYW1WamRDQmtZWFJoSUdadmNpQjFjMlVnWEc0Z0lDQXFJRzl1SUdGdUlFRlFTU0JqWVd4c0xpQWdJRnh1SUNBZ0tpQkFjbVYwZFhKdUlIdEVaWEJzYjNsU2ZTQm1iM0lnWTJoaGFXNXBibWN1SUNBZ1hHNGdJQ0FxSUVCaGNHa2djSFZpYkdsalhHNGdJQ0FxTDF4dUlDQnlhVzV3ZFhRNklHWjFibU4wYVc5dUlDaHlhVzV3ZFhRcElIdGNiaUFnSUNCcFppQW9jbWx1Y0hWMEtTQjdJSFJvYVhNdWFXNXdkWFJ6TG5CMWMyZ29jbWx1Y0hWMEtUc2dmVnh1WEc0Z0lDQWdjbVYwZFhKdUlIUm9hWE03WEc0Z0lIMHNYRzVjYmlBZ0x5b3FYRzRnSUNBcUlFUmxjM1J5YjNrZ2JHbG1aV041WTJ4bElHMWxkR2h2WkM0Z1JtbHlaWE1nZEdobElHQmtaWE4wY205NVlDQmxkbVZ1ZEN3Z2NISnBiM0lnZEc4Z2FXNTJiMnRwYm1jZ1hHNGdJQ0FxSUdSbGMzUnlkV04wYjNKeklHWnZjaUIwYUdVZ1kyeGhjM01nYUdsbGNtRnlZMmg1TGlCRFlXeHNaV1FnYVc1MFpYSnVZV3hzZVNCM2FHVnVJR0F1Y21Wc1pXRnpaU2dwWUZ4dUlDQWdLaUJwY3lCallXeHNaV1F1WEc0Z0lDQXFYRzRnSUNBcUlFQnRaWFJvYjJRZ1pHVnpkSEp2ZVZ4dUlDQWdLaUJBWVhCcElIQjFZbXhwWXlBZ0lGeHVJQ0FnS2k5Y2JpQWdaR1Z6ZEhKdmVUb2dablZ1WTNScGIyNGdLQ2tnZTF4dUlDQWdJSFJ5ZVNCN1hHNGdJQ0FnSUNCMGFHbHpMbVZ0YVhRb0oyUmxjM1J5YjNrbktUdGNiaUFnSUNBZ0lIUm9hWE11YjJabVFXeHNLQ2s3WEc0Z0lDQWdYRzRnSUNBZ0lDQm1iM0lnS0haaGNpQnJaWGtnYVc0Z2RHaHBjeWtnZTF4dUlDQWdJQ0FnSUNCcFppQW9kR2hwY3k1b1lYTlBkMjVRY205d1pYSjBlU2hyWlhrcEtTQjdJRnh1SUNBZ0lDQWdJQ0FnSUhSb2FYTmJhMlY1WFNBOUlHNTFiR3c3SUZ4dUlDQWdJQ0FnSUNBZ0lHUmxiR1YwWlNCMGFHbHpXMnRsZVYwN1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNCOUlHTmhkR05vS0dWeWNpa2dlMzFjYmlBZ2ZTd2dJRnh1WEc0Z0lDOHZJQzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0WEc0Z0lDOHZJRkJ5YVhaaGRHVWdiV1YwYUc5a2MxeHVJQ0F2THlBdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdExWeHVYRzRnSUM4cUtseHVJQ0FnS2lCQVlYQnBJSEJ5YVhaaGRHVmNiaUFnSUNvdlhHNGdJRjlqYkdWaGNqb2dablZ1WTNScGIyNG9LU0I3SUNBZ0lGeHVJQ0FnSUhSb2FYTXVjR0Z5WVcxeklDQTlJSHQ5TzF4dUlDQWdJSFJvYVhNdWFXNXdkWFJ6SUNBOUlGdGRPMXh1SUNBZ0lIUm9hWE11YjNWMGNIVjBjeUE5SUZ0ZE8xeHVJQ0FnSUhSb2FYTXVjbk4wY21WaGJTQTlJR1poYkhObE8xeHVJQ0FnSUhSb2FYTXVaR1ZzWVhsbFpDQTlJR1poYkhObE8xeHVJQ0FnSUhSb2FYTXVZWEJwSUNBZ0lDQTlJRzUxYkd3N0lDQWdJRnh1SUNBZ0lIUm9hWE11Wm1sc1pTQWdJQ0E5SUc1MWJHdzdJQ0JjYmlBZ0lDQjBhR2x6TG1acGJIUmxjaUFnUFNCdWRXeHNPMXh1SUNCOUxDQmNibHh1SUNBdktpcGNiaUFnSUNvZ1FHRndhU0J3Y21sMllYUmxYRzRnSUNBcUwxeHVJQ0JmY0hKbGNGSmxjWFZsYzNRNklHWjFibU4wYVc5dUlDaHlaWE53YjI1elpVTm9ZV2x1TENCaGNtZHpLU0I3WEc0Z0lDQWdkbUZ5SUhKbGNTQWdQU0IwYUdsekxuSmxjU3hjYmlBZ0lDQWdJQ0FnWm1sc1pTQTlJSFJvYVhNdVptbHNaVHRjYmx4dUlDQWdJQzh2SUhObGRDQjBhR1VnY21WeGRXVnpkQ0IwZVhCbElDQWdJRnh1SUNBZ0lHbG1JQ2gwYUdsekxtRndhUzUxY0d4dllXUXBJSHRjYmlBZ0lDQWdJQ0F2THlCSlppQjBhR1VnWlc1MklHbHpJSFJvWlNCQ2NtOTNjMlZ5SUhSb1pYSmxJR2x6SUc1dklHNWxaV1FnZEc4Z2JXRnVkV0ZzYkhrZ2MyVjBJSFJvWlZ4dUlDQWdJQ0FnSUM4dklFTnZiblJsYm5RdFZIbHdaUzRnVkdobElHSnliM2R6WlhJZ2QybHNiQ0JoZFhSdmJXRjBhV05oYkd4NUlITmxkQ0IwYUdVZ1hHNGdJQ0FnSUNBZ0x5OGdYQ0p0ZFd4MGFYQmhjblF2Wm05eWJTMWtZWFJoT3lCaWIzVnVaR0Z5ZVQwdUxpNWNJaUIyWVd4MVpTNGdTV1lnZEdobElHVnVkaUJwY3lCT2IyUmxJSGRsSUc1bFpXUmNiaUFnSUNBZ0lDQXZMeUIwYnlCelpYUWdhWFFnYldGdWRXRnNiSGt1WEc0Z0lDQWdJQ0FnYVdZZ0tDRjNhVzRwSUhzZ2RHaHBjeTV5WlhFdWRIbHdaU2duYlhWc2RHbHdZWEowTDJadmNtMHRaR0YwWVNjcE95QjlJQ0FnSUZ4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnlaWEV1ZEhsd1pTZ25abTl5YlNjcE8xeHVJQ0FnSUgwZ0lDQWdYRzVjYmlBZ0lDQnlaWEV1YjI0b0oyVnljbTl5Snl3Z1puVnVZM1JwYjI0b1pYSnlLU0I3SUZ4dUlDQWdJQ0FnWlhKeUlEMGdaWEp5SUh4OElIc2dJR052WkdVNklDZFZUa3RPVDFkT0lFTlBSRVVuTENCMFpYaDBPaUFuVlU1TFRrOVhUaUJGVWxKUFVpY2dmVHRjYmx4dUlDQWdJQ0FnZEdocGN5NWZhR0Z1Wkd4bFJYSnliM0lvZXlCY2JpQWdJQ0FnSUNBZ2MzUmhkSFZ6T2lCbGNuSXVZMjlrWlNCOGZDQW5WVTVMVGs5WFRpQkRUMFJGSnl4Y2JpQWdJQ0FnSUNBZ2RHVjRkRG9nWlhKeVhHNGdJQ0FnSUNCOUtUdGNiaUFnSUNCOUxtSnBibVFvZEdocGN5a3BPeUFnSUNCY2JseHVJQ0FnSUhSb2FYTXVjMmhoY21Vb1lYSm5jeUEvSUdGeVozTXVYMTlqYjI5cmFXVnpYMThnT2lCdWRXeHNLVHRjYmx4dUlDQWdJQzh2SUdGeVozVnRaVzUwY3lCeVpYUjFjbTVsWkNCbWNtOXRJSEJ5WlhZZ2NtVnhkV1Z6ZENkeklHbHZLQ2t1Wlc1a0tHWjFibU4wYVc5dUtDa2dleUJ5WlhSMWNtNGdlRHNnZlNsY2JpQWdJQ0JwWmlBb1lYSm5jeWtnZXlCY2JpQWdJQ0FnSUNCMGFHbHpMbVJoZEdFb1lYSm5jeWs3WEc0Z0lDQWdmU0JjYmx4dUlDQWdJR2xtSUNoMGFHbHpMbWx1Y0hWMGN5NXNaVzVuZEdnZ1BpQXdLU0I3SUZ4dUlDQWdJQ0FnZEdocGN5NWtZWFJoS0hzZ2FXNXdkWFJ6T2lCbGJtTnZaR1Z5TG1WdVkyOWtaU2gwYUdsekxtbHVjSFYwY3lrZ2ZTazdJRnh1SUNBZ0lIMWNiaUFnWEc0Z0lDQWdhV1lnS0hSb2FYTXViM1YwY0hWMGN5NXNaVzVuZEdnZ1BpQXdLU0I3SUZ4dUlDQWdJQ0FnZEdocGN5NWtZWFJoS0hzZ2NtOWlhbVZqZEhNNklIUm9hWE11YjNWMGNIVjBjeTVxYjJsdUtDa2dmU2s3SUZ4dUlDQWdJSDBnSUNBZ1hHNWNiaUFnSUNCcFppQW9kR2hwY3k1amIyOXJhV1Z6S1NCN0lDQWdJQ0JjYmlBZ0lDQWdJSFJvYVhNdVkyOXZhMmxsY3k1bWIzSkZZV05vS0NCbWRXNWpkR2x2YmloaktTQjdJSEpsY1M1elpYUW9KME52YjJ0cFpTY3NJR01wT3lCOUtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCcFppQW9kR2hwY3k1aGNHa3VkWEJzYjJGa0tTQjdJQ0FnSUZ4dUlDQWdJQ0FnWm05eUtIWmhjaUJ3SUdsdUlIUm9hWE11Y0dGeVlXMXpLU0I3WEc0Z0lDQWdJQ0FnY21WeExtWnBaV3hrS0hBc0lIUm9hWE11Y0dGeVlXMXpXM0JkSUQ4Z2RHaHBjeTV3WVhKaGJYTmJjRjBnS3lBbkp5QTZJQ2NuS1RzZ0lGeHVJQ0FnSUNBZ2ZTQmNiaUFnSUNBZ0lISmxjUzVoZEhSaFkyZ29KMlpwYkdVbkxDQjBhR2x6TG5KemRISmxZVzBnUHlCbWN5NWpjbVZoZEdWU1pXRmtVM1J5WldGdEtHWnBiR1VwSURvZ1ptbHNaU2s3WEc0Z0lDQWdmU0JsYkhObElIdGNiaUFnSUNBZ0lISmxjVnQwYUdsekxtRndhUzV0WlhSb2IyUWdQVDA5SUNkSFJWUW5JRDhnSjNGMVpYSjVKeUE2SUNkelpXNWtKMTBvZEdocGN5NXdZWEpoYlhNcE8xeHVJQ0FnSUgwZ1hHNGdJSDBzWEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRUJoY0drZ2NISnBkbUYwWlZ4dUlDQWdLaTljYmlBZ1gyaGhibVJzWlVWeWNtOXlPaUJtZFc1amRHbHZiaUFvY21GM0tTQjdYRzRnSUNBZ2RtRnlJSE4wWVhRZ0lEMGdjbUYzTG5OMFlYUjFjeXhjYmlBZ0lDQWdJQ0FnY21WeklDQWdQU0FvY21GM0xtSnZaSGtnSmlZZ2NtRjNMbUp2WkhrdVpHVndiRzk1Y2lBL0lISmhkeTVpYjJSNUlEb2djbUYzS1N4Y2JpQWdJQ0FnSUNBZ1pYSnliM0lnUFNBb0tITjBZWFFnSVQwOUlESXdNQ2tnZkh3Z2NtVnpMbVJsY0d4dmVYSWdKaVlnSVhKbGN5NWtaWEJzYjNseUxuSmxjM0J2Ym5ObExuTjFZMk5sYzNNcE8xeHVYRzRnSUNBZ0x5OGdMUzBnU0dGdVpHeGxJR1Z5Y205eWN5QXRMVnh1SUNBZ0lHbG1JQ2hsY25KdmNpa2dlMXh1SUNBZ0lDQWdjbVZ6SUQwZ2UxeHVJQ0FnSUNBZ0lDQm5aWFE2SUdaMWJtTjBhVzl1S0d0bGVTa2dleUJjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnZFhScGJITXVaMlYwS0hSb2FYTXVaR1Z3Ykc5NWNpNXlaWE53YjI1elpTd2dhMlY1S1RzZ1hHNGdJQ0FnSUNBZ0lIMHNYRzRnSUNBZ0lDQWdJR1JsY0d4dmVYSTZJSHNnSUNBZ0lDQWdJQ0FnWEc0Z0lDQWdJQ0FnSUNBZ2NtVnpjRzl1YzJVNklIdGNiaUFnSUNBZ0lDQWdJQ0FnSUhOMVkyTmxjM002SUdaaGJITmxMRnh1SUNBZ0lDQWdJQ0FnSUNBZ1kyRnNiRG9nZEdocGN5NWhjR2xiSjJOaGJHd25YU3hjYmlBZ0lDQWdJQ0FnSUNBZ0lHVnljbTl5UTI5a1pUb2djbVZ6TG1SbGNHeHZlWElnUHlCeVpYTXVaR1Z3Ykc5NWNpNXlaWE53YjI1elpTNWxjbkp2Y2tOdlpHVWdPaUJ6ZEdGMExGeHVJQ0FnSUNBZ0lDQWdJQ0FnWlhKeWIzSTZJSEpsY3k1a1pYQnNiM2x5SUQ4Z2NtVnpMbVJsY0d4dmVYSXVjbVZ6Y0c5dWMyVXVaWEp5YjNJZ09pQnlaWE11ZEdWNGRGeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlR0Y2JseHVJQ0FnSUNBZ1RHOW5aMlZ5TG1WeWNtOXlLQ2RsY25KdmNpZ3BKeXdnZEdocGN5NWhjR2tzSUhKbGN5d2djbUYzS1R0Y2JpQWdJQ0FnSUhSb2FYTXViRzluWjJWeUxtVnljbTl5S0NkbGNuSnZjaWdwSnl3Z2RHaHBjeTVoY0drc0lISmxjeXdnY21GM0tUdGNibHh1SUNBZ0lDQWdMeThnTFMwZ2JtOTBhV1o1SUdkc2IySmhiQ0JsY25KdmNuTWdabWx5YzNRZ0tHbG1JR0Z1ZVNrZ1ptOXlJSFJvYVhNZ1kyRnNiQ0F0TFNBZ0lDQWdJRnh1SUNBZ0lDQWdhV1lnS0hSb2FYTXVaMnh2WW1Gc1JYWjBjeWtnZTF4dUlDQWdJQ0FnSUNCeVlXbHpaVWRzYjJKaGJFVnljbTl5Y3loMGFHbHpMbUZ3YVZzblkyRnNiQ2RkTENCeVpYTXBPeUFnSUNBZ0lDQWdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQzh2SUMwdElIUnlZVzVoWTNScGIyNGdiR1YyWld3Z1NGUlVVQ0J2Y2lCRVpYQnNiM2xTSUdWeWNtOXljeUJqYjIxbElHNWxlSFFnTFMwZ0lDQWdYRzRnSUNBZ0lDQjBhR2x6TG1WdGFYUW9KMlZ5Y205eUp5d2djbVZ6S1R0Y2JpQWdJQ0FnSUhSb2FYTXVaVzFwZENnblpHVndiRzk1Y2kxcGJ6b25JQ3NnY21WekxtUmxjR3h2ZVhJdWNtVnpjRzl1YzJVdVpYSnliM0pEYjJSbExDQnlaWE1wTzF4dUlDQWdJQ0FnZEdocGN5NWtaV1psY25KbFpDNXlaV3BsWTNRb2NtVnpLVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQnlaWFIxY200Z1pYSnliM0k3WEc0Z0lIMWNibjBwTzF4dVhHNHZLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvdlhHNHZLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvdlhHNHZLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvdlhHNWNiaTh2SUVsdVkyeDFaR1VnZEdobElHQmtaWEJ5WldOaGRHVmtZQ0JxYzBSbGNHeHZlVklnWm05eUlHNXZkeTVjYm1sbUlDaDNhVzRwSUh0Y2JpQWdkMmx1Wkc5M0xsSmxkbTlzZFhScGIyNGdQU0IzYVc1a2IzY3VVbVYyYjJ4MWRHbHZiaUI4ZkNCeVpYRjFhWEpsS0NjdUwyeHBZaTlrWlhCeVpXTmhkR1ZrSnlrN1hHNTlYRzVjYmk4cUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaTljYmk4cUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaTljYmk4cUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaTljYmx4dUx5b3FYRzRnS2lCRmVIQnZjMlVnWm05eUlHRWdZMnhsWVc1bGNpQmpiR2xsYm5RZ1lYQnBJR2x1ZEc4Z1JHVndiRzk1VWx4dUlDb3ZYRzV0YjJSMWJHVXVaWGh3YjNKMGN5QTlJSHRjYmx4dUlDQXZLaXBjYmlBZ0lDb2dSWGh3YjNObGN5QjBhR1VnWUVSbGNHeHZlVkpnSUc5aWFtVmpkQ0JtYjNJZ1pYaDBaVzVrYVc1bkxseHVJQ0FnS2x4dUlDQWdLaUJnWUdCMllYSWdSR1Z3Ykc5NVVpQTlJSEpsY1hWcGNtVW9KMlJsY0d4dmVYSW5LUzVFWlhCc2IzbFNPMkJnWUZ4dUlDQWdLbHh1SUNBZ0tpQkFjM1JoZEdsalhHNGdJQ0FxSUVCaGNHa2djSFZpYkdsalhHNGdJQ0FxSUVCeVpYUjFjbTRnZTBSbGNHeHZlVko5SUZSb1pTQmdSR1Z3Ykc5NVVtQWdiMkpxWldOMExseHVJQ0FnS2k4Z0lDQmNiaUFnUkdWd2JHOTVVam9nUkdWd2JHOTVVaXhjYmx4dUlDQXZLaXBjYmlBZ0lDb2dSWGh3YjNObGN5QjBhR1VnYzNWd2NHOXlkR1ZrSUVSbGNHeHZlVklnUVZCSmN5NWNiaUFnSUNwY2JpQWdJQ29nUUcxbGRHaHZaQ0JoY0dselhHNGdJQ0FxSUVCd1lYSmhiU0I3UW05dmJHVmhibjBnWm14aGRDQW9iM0IwYVc5dVlXd3BJR2xtSUdCMGNuVmxZQ0IzYVd4c0lISmxkSFZ5YmlCaGJpQmhjbkpoZVNCdlppQnFkWE4wSUhSb1pTQmNiaUFnSUNvZ1FWQkpKM01nWlc1a2NHOXBiblFnY0hKdmNHVnlkR2xsY3l3Z1ptOXlJR1Y0WVcxd2JHVTZJRnh1SUNBZ0tpQmdZR0JjYmlBZ0lDb2dXeWN2Y2k5MWMyVnlMMnh2WjJsdUp5d2dKeTl5TDNWelpYSXZiRzluYjNWMEp5d2dKeTl5TDNWelpYSXZZV0p2ZFhRbkxDQXVMaTVkWEc0Z0lDQXFJR0JnWUZ4dUlDQWdLaUJBYzNSaGRHbGpYRzRnSUNBcUlFQmhjR2tnY0hWaWJHbGpYRzRnSUNBcUlFQnlaWFIxY200Z2UwOWlhbVZqZEh4QmNuSmhlWDBnVkdobElFaFVWRkFnY21WeGRXVnpkQ0IwYnlCMGFHVWdSR1Z3Ykc5NVVpQnpaWEoyWlhJdUlDQWdJQ0FnWEc0Z0lDQXFMeUFnWEc0Z0lHRndhWE02SUdaMWJtTjBhVzl1S0dac1lYUXBJSHRjYmlBZ0lDQnlaWFIxY200Z1pteGhkQ0EvSUU5aWFtVmpkQzVyWlhsektHRndhWE1wSURvZ1lYQnBjenRjYmlBZ2ZTeGNibHh1SUNBdktpcGNiaUFnSUNvZ1VtVndjbVZ6Wlc1MGN5QmhJSE4wWVhScFl5QnRaWFJvYjJRZ1ptOXlJR052Ym1acFozVnlhVzVuSUdGc2JDQkVaWEJzYjNsU0lISmxjWFZsYzNSekxpQlRaWFIwYVc1bmN5QmNiaUFnSUNvZ2JXRmtaU0JvWlhKbElHRnlaU0JoY0hCc2FXVmtJR2RzYjJKaGJHeDVJR0ZqY205emN5QmxkbVZ5ZVNCeVpYRjFaWE4wTGx4dUlDQWdLbHh1SUNBZ0tpQkFiV1YwYUc5a0lHTnZibVpwWjNWeVpWeHVJQ0FnS2lCQWNHRnlZVzBnZTA5aWFtVmpkSDBnYjNCMGFXOXVjeUJVYUdVZ2IySnFaV04wSUd4cGRHVnlZV3dnWTI5dVptbG5kWEpoZEdsdmJpQm9ZWE5vTGlCY2JpQWdJQ29nUUhOMFlYUnBZMXh1SUNBZ0tpQkFZMmhoYVc1aFlteGxYRzRnSUNBcUlFQmhjR2tnY0hWaWJHbGpYRzRnSUNBcUwxeHVJQ0JqYjI1bWFXZDFjbVU2SUdaMWJtTjBhVzl1S0c5d2RHbHZibk1wSUh0Y2JpQWdJQ0J2Y0hScGIyNXpJRDBnYjNCMGFXOXVjeUI4ZkNCN2ZUdGNibHh1SUNBZ0lHWnZjaUFvZG1GeUlHa2dhVzRnYjNCMGFXOXVjeWtnZXlCbmJHOWlZV3hQY0hScGIyNXpMbk5sZENocExDQnZjSFJwYjI1elcybGRLVHNnZlZ4dVhHNGdJQ0FnTHk4Z1lYTnpaWEowSUdkc2IySmhiQ0JqYjI5cmFXVnpJR0Z5WlNCbGJYQjBlU0JwWmlCbmJHOWlZV3dnWUhOMGFXTnJlV0FnYW5ObGMzTnBiMjVwWkNCcGN5QnZabVpjYmlBZ0lDQnBaaUFvSVdkc2IySmhiRTl3ZEdsdmJuTXVjM1JwWTJ0NUtTQWdleUJuYkc5aVlXeFBjSFJwYjI1ekxuTmxkQ2duWTI5dmEybGxjeWNzSUc1MWJHd3BPeUI5WEc1Y2JpQWdJQ0F2THlCMGRYSnVJR2RzYjJKaGJDQnNiMmRuYVc1bklHOXVmRzltWmlBb2IyWm1JR0o1SUdSbFptRjFiSFFwWEc0Z0lDQWdURzluWjJWeUxuTmxkRXhsZG1Wc0tHZHNiMkpoYkU5d2RHbHZibk11Ykc5bloybHVaeUEvSUV4dloyZGxjaTVFUlVKVlJ5QTZJRXh2WjJkbGNpNVBSa1lwTzF4dVhHNGdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJSDBzWEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRVpoWTNSdmNua2dabTl5SUdOeVpXRjBhVzVuSUc1bGR5QkpUeUJ5WlhGMVpYTjBjeUIwYnlCZ1JHVndiRzk1VW1BdVhHNGdJQ0FxWEc0Z0lDQXFJRVY0WVcxd2JHVTZYRzRnSUNBcUlHQmdZQ0FnSUZ4dUlDQWdLaUFnSUNCa1pYQnNiM2x5TG1sdktDY3ZjaTkxYzJWeUwyRmliM1YwSnlrdVpXNWtLR05oYkd4aVlXTnJLVHRjYmlBZ0lDb2dZR0JnWEc0Z0lDQXFYRzRnSUNBcUlFQnRaWFJvYjJRZ2FXOWNiaUFnSUNvZ1FIQmhjbUZ0SUh0VGRISnBibWQ5SUdGd2FTQlBibVVnYjJZZ2RHaGxJSE4xY0hCdmNuUmxaQ0JFWlhCc2IzbFNJRUZRU1hNdVhHNGdJQ0FxSUVCemRHRjBhV05jYmlBZ0lDb2dRSEpsZEhWeWJpQjdSR1Z3Ykc5NVVuMGdWR2hsSUVoVVZGQWdjbVZ4ZFdWemRDQjBieUIwYUdVZ1JHVndiRzk1VWlCelpYSjJaWEl1WEc0Z0lDQXFJRUJoY0drZ2NIVmliR2xqSUNBZ1hHNGdJQ0FxTDF4dUlDQnBiem9nWm5WdVkzUnBiMjRvWVhCcEtTQjdJQ0JjYmlBZ0lDQnlaWFIxY200Z1JHVndiRzk1VWk1dVpYY29ZWEJwS1R0Y2JpQWdmU3hjYmx4dUlDQXZLaXBjYmlBZ0lDb2dRMjl1ZG1WdWFXVnVZMlVnWm5WdVkzUnBiMjRnZEc4Z2MybG5iaUIwYUdVZ2RYTmxjaUJwYmlCaWVTQmhkWFJvWlc1MGFXTmhkR2x1WnlCMGFHVWdZM0psWkdWdWRHbGhiSE1nWEc0Z0lDQXFJSGRwZEdnZ2RHaGxJRVJsY0d4dmVWSWdjMlZ5ZG1WeUxpQWdJRnh1SUNBZ0tseHVJQ0FnS2lCQWJXVjBhRzlrSUdGMWRHaGNiaUFnSUNvZ1FIQmhjbUZ0SUh0VGRISnBibWQ5SUhWelpYSnVZVzFsSUZOd1pXTnBabWxsY3lCMGFHVWdkWE5sY201aGJXVXVYRzRnSUNBcUlFQndZWEpoYlNCN1UzUnlhVzVuZlNCd1lYTnpkMjl5WkNCVGNHVmphV1pwWlhNZ2RHaGxJSEJoYzNOM2IzSmtMbHh1SUNBZ0tpQkFjM1JoZEdsalhHNGdJQ0FxSUVCeVpYUjFjbTRnZTBSbGNHeHZlVko5SUZSb1pTQklWRlJRSUhKbGNYVmxjM1FnZEc4Z2RHaGxJRVJsY0d4dmVWSWdjMlZ5ZG1WeUxpQWdJRnh1SUNBZ0tpQkFZWEJwSUhCMVlteHBZeUFnSUZ4dUlDQWdLaThnSUNCY2JpQWdZWFYwYURvZ1puVnVZM1JwYjI0b2RXNHNJSEIzS1NCN1hHNGdJQ0FnZG1GeUlHUmhkR0VnUFNCN0lIVnpaWEp1WVcxbE9pQjFiaXdnY0dGemMzZHZjbVE2SUhCM0lIMDdYRzRnSUNBZ2NtVjBkWEp1SUVSbGNHeHZlVkl1Ym1WM0tDY3ZjaTkxYzJWeUwyeHZaMmx1SnlrdVpHRjBZU2hrWVhSaEtTNWxibVFvS1RzZ0lDQWdYRzRnSUgwc1hHNWNiaUFnTHlvcVhHNGdJQ0FxSUVOdmJuWmxibWxsYm1ObElHWjFibU4wYVc5dUlIUnZJSE5wWjI0Z2RHaGxJSFZ6WlhJZ2FXNGdZbmtnWVhWMGFHVnVkR2xqWVhScGJtY2dkR2hsSUdOeVpXUmxiblJwWVd4eklGeHVJQ0FnS2lCM2FYUm9JSFJvWlNCRVpYQnNiM2xTSUhObGNuWmxjaTRnSUNCY2JpQWdJQ3BjYmlBZ0lDb2dSWGhoYlhCc1pUcGNiaUFnSUNvZ1lHQmdYRzRnSUNBcUlDQWdJR1JsY0d4dmVYSXVjMk55YVhCMEtDY3ZkR1Z6ZEhWelpYSXZjbTl2ZEM5eVpXUjFZMlV1VWljcFhHNGdJQ0FxSUNBZ0lHUmxjR3h2ZVhJdWMyTnlhWEIwS0hzZ1ptbHNaVzVoYldVNklDZHlaV1IxWTJVdVVpY3NJR0YxZEdodmNqb2dKM1JsYzNSMWMyVnlKeXhjYmlBZ0lDb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JrYVhKbFkzUnZjbms2SUNkeWIyOTBKMzBwWEc0Z0lDQXFJQ0FnSUdSbGNHeHZlWEl1YzJOeWFYQjBLQ2R5WldSMVkyVXVVaWNzSUNkMFpYTjBkWE5sY2ljc0lDZHliMjkwSnlsY2JpQWdJQ29nSUNBZ1pHVndiRzk1Y2k1elkzSnBjSFFvSnk5MFpYTjBkWE5sY2k5eWIyOTBMM0psWkhWalpTNVNKeXdnY0hKdmFtVmpkQ2tnSUNBZ0lGeHVJQ0FnS2lCZ1lHQWdJQ0JjYmlBZ0lDcGNiaUFnSUNvZ1FHMWxkR2h2WkNCelkzSnBjSFJjYmlBZ0lDb2dRSEJoY21GdElIdEJjbWQxYldWdWRITjlJR0Z5WjNWdFpXNTBjeUJCY21kMWJXVnVkSE1nZEc4Z1pHVm1hVzVsSUhSb1pTQm1kV3hzZVNCeGRXRnNhV1pwWldRZ2MyTnlhWEIwSUZ4dUlDQWdLaUJtYjNJZ1pYaGxZM1YwYVc5dUxseHVJQ0FnS2lCQWMzUmhkR2xqWEc0Z0lDQXFJRUJ5WlhSMWNtNGdlMFJsY0d4dmVWSjlJRlJvWlNCSVZGUlFJSEpsY1hWbGMzUWdkRzhnZEdobElFUmxjR3h2ZVZJZ2MyVnlkbVZ5TGlBZ0lGeHVJQ0FnS2lCQVlYQnBJSEIxWW14cFl5QWdJRnh1SUNBZ0tpOGdJQ0FnSUZ4dUlDQnpZM0pwY0hRNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lIWmhjaUJoY21keklEMGdkWFJwYkhNdWMybG5ibUYwZFhKbEtHRnlaM1Z0Wlc1MGN5a3NYRzRnSUNBZ0lDQWdJRzl3ZEhNZ1BTQmhjbWR6TG05d2RITXNYRzRnSUNBZ0lDQWdJR0Z3YVNBZ1BTQmhjbWR6TG1Gd2FUc2dJRnh1WEc0Z0lDQWdMeThnWTI5dWRtVnVhV1Z1WTJVZ0xTQnBaaUIwYUdVZ2NISnZhbVZqZENCcGN5QmhJR0p2YjJ4bGJpQmdkSEoxWldBZ2NtRjBhR1Z5SUhSb1lXNGdZU0J3YVdRc0lHWnBjbk4wWEc0Z0lDQWdMeThnWTNKbFlYUmxJR0VnYm1WM0lIQnliMnBsWTNRZ1lXNWtJSFJvWlc0Z2NISmxjR0Z5WlNCMGFHVWdjSEp2YW1WamRDQmhjR2tnWTJGc2JDQjBieUJsZUdWamRYUmxYRzRnSUNBZ2FXWWdLR0Z5WjNNdVkzSmxZWFJsS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnUkdWd2JHOTVVaTV1Wlhjb0p5OXlMM0J5YjJwbFkzUXZZM0psWVhSbEp5bGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDNWxibVFvWm5WdVkzUnBiMjRvY21WektTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdleUJ3Y205cVpXTjBPaUJ5WlhNdVoyVjBLQ2R3Y205cVpXTjBKeWt1Y0hKdmFtVmpkQ0I5TzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUgwcFhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdWFXOG9ZWEJwS1Z4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnTG1SaGRHRW9iM0IwY3lrN1hHNGdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQkVaWEJzYjNsU0xtNWxkeWhoY0drcExtUmhkR0VvYjNCMGN5azdYRzRnSUNBZ2ZWeHVJQ0I5TENBZ1hHNWNiaUFnTHlvcVhHNGdJQ0FxSUZKMWJpQmhiaUJ6WlhKcFpYTWdiMllnWTJoaGFXNWxaQ0JFWlhCc2IzbFNJSEpsY1hWbGMzUnpJR2x1SUhObGNYVmxibU5sSUdGdVpDQjNhWFJvYjNWMElHOTJaWEpzWVhBdUlDQWdJQ0FnSUZ4dUlDQWdLbHh1SUNBZ0tpQkFiV1YwYUc5a0lIQnBjR3hwYm1WY2JpQWdJQ29nUUhCaGNtRnRJSHRCY25KaGVYMGdkR0Z6YTNNZ1UzQmxZMmxtYVdWeklIUm9aU0JzYVhOMElHOW1JR0JHZFc1amRHbHZibUFnZEdGemEzTXVYRzRnSUNBcUlFQnpkR0YwYVdOY2JpQWdJQ29nUUhKbGRIVnliaUI3VUhKdmJXbHpaWDBnUVNCd2NtOXRhWE5sSUhkeVlYQndhVzVuSUhSb1pTQnlaWE52YkhWMGFXOXVJRzltSUdWcGRHaGxjaUJjSW5KbGMyOXNkbVZjSWlCdmNseHVJQ0FnS2lCY0luSmxhbVZqZEZ3aUlHTmhiR3hpWVdOckxseHVJQ0FnS2lCQVlYQnBJSEIxWW14cFl5QWdJRnh1SUNBZ0tpOWNiaUFnY0dsd1pXeHBibVU2SUdaMWJtTjBhVzl1S0dOb1lXbHVjeWtnZXlBZ0lDQWdJRnh1SUNBZ0lIWmhjaUJrWlhCc2IzbHlJQ0E5SUhSb2FYTXNYRzRnSUNBZ0lDQWdJR1JsWm1WeWNtVmtJRDBnUkNncExGeHVJQ0FnSUNBZ0lDQnhJQ0FnSUNBZ0lDQTlJRzVsZHlCUmRXVjFaU2dwTEZ4dUlDQWdJQ0FnSUNCeVpYTjFiSFJ6SUNBOUlGdGRMRnh1SUNBZ0lDQWdJQ0JsY25KdmNuTWdJQ0E5SUZ0ZExGeHVJQ0FnSUNBZ0lDQk9UMDlRSUNBZ0lDQTlJRzUxYkd3c0lDOHZJRTVQVDFBZ1pYSnliM0p6ZkhKbGMzVnNkSE1nWm05eUlGdGhYU0JpWVhSamFDQnlaWEYxWlhOMElHTm9ZV2x1WEc0Z0lDQWdJQ0FnSUc5eWFXY2dJQ0FnSUQwZ2UxeHVJQ0FnSUNBZ0lDQWdJSE4wYVdOcmVUb2daMnh2WW1Gc1QzQjBhVzl1Y3k1emRHbGphM2tzWEc0Z0lDQWdJQ0FnSUNBZ1kyOXZhMmxsY3pvZ1oyeHZZbUZzVDNCMGFXOXVjeTVqYjI5cmFXVnpYRzRnSUNBZ0lDQWdJSDA3WEc1Y2JpQWdJQ0F2THlCdFlXdGxJR0VnWTI5d2VWeHVJQ0FnSUdOb1lXbHVjeUE5SUdOb1lXbHVjeTV6YkdsalpTZ3dLVHRjYmx4dUlDQWdJQzh2SUhSMWNtNGdjM1JwWTJ0NUlITmxjM05wYjI0Z1ptOXlJSFJvWlhObElISmxjWFZsYzNRZ0tHaGhZMnQ1S1Z4dUlDQWdJR1JsY0d4dmVYSXVZMjl1Wm1sbmRYSmxLQ0I3SUhOMGFXTnJlVG9nZEhKMVpTQjlLVHRjYmx4dUlDQWdJR1oxYm1OMGFXOXVJR0ZrWkNncElIdGNiaUFnSUNBZ0lIRXVZV1JrS0daMWJtTjBhVzl1S0NrZ2V5QmNiaUFnSUNBZ0lDQWdZMmhoYVc1ekxuTm9hV1owS0NrdVpISmhhVzRvS1Z4dUlDQWdJQ0FnSUNBdWRHaGxiaWhtZFc1amRHbHZiaWhqYUdGcGJpa2dlMXh1SUNBZ0lDQWdJQ0FnSUhKbGMzVnNkSE11Y0hWemFDaGphR0ZwYmlrN0lDQmNiaUFnSUNBZ0lDQWdJQ0JsY25KdmNuTXVjSFZ6YUNoT1QwOVFLVHNnSUNBZ0lDQWdJQ0FnSUZ4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h4TG1selJXMXdkSGtvS1NrZ2V5QmNiaUFnSUNBZ0lDQWdJQ0FnSUdSbGNHeHZlWEl1WTI5dVptbG5kWEpsS0c5eWFXY3BPeUF2THlCeVpYTmxkRnh1SUNBZ0lDQWdJQ0FnSUNBZ1pHVm1aWEp5WldRdWNtVnpiMngyWlNoN0lISmxjM1ZzZEhNNklISmxjM1ZzZEhNc0lHVnljbTl5Y3pvZ1pYSnliM0p6SUgwcE95QmNiaUFnSUNBZ0lDQWdJQ0I5SUNCY2JseHVJQ0FnSUNBZ0lDQWdJSEV1ZEdGclpTZ3BPMXh1SUNBZ0lDQWdJQ0I5TENCbWRXNWpkR2x2YmlobGNuSXBJSHNnSUNBZ0lDQWdJQ0FnWEc0Z0lDQWdJQ0FnSUNBZ2NtVnpkV3gwY3k1d2RYTm9LRTVQVDFBcE95QmNiaUFnSUNBZ0lDQWdJQ0JsY25KdmNuTXVjSFZ6YUNobGNuSXBPMXh1SUNBZ0lDQWdJQ0FnSUM4dklISmxhbVZqZEdsdmJuTWdZWEpsSUc5dWJIa2diV1YwSUhkb1pXNGdkR2hsZVNCYllXeHNYU0JtWVdsc1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0hFdWFYTkZiWEIwZVNncElDWW1JSEpsYzNWc2RITXViR1Z1WjNSb0lEMDlQU0F3S1NCN0lGeHVJQ0FnSUNBZ0lDQWdJQ0FnWkdWd2JHOTVjaTVqYjI1bWFXZDFjbVVvYjNKcFp5azdJQzh2SUhKbGMyVjBYRzRnSUNBZ0lDQWdJQ0FnSUNCa1pXWmxjbkpsWkM1eVpXcGxZM1FvWlhKeWIzSnpLVHNnWEc0Z0lDQWdJQ0FnSUNBZ2ZTQWdYRzRnSUNBZ0lDQWdJQ0FnY1M1MFlXdGxLQ2s3WEc0Z0lDQWdJQ0FnSUgwcE95QWdJQ0FnSUNCY2JpQWdJQ0FnSUgwc0lHNTFiR3dzSUhSeWRXVXBPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJR052Ym5abGNuUWdkRzhnWVNCelpYRWdjWFZsZFdVZ1ptOXlJR0psZEhSbGNpQm9ZVzVrYkdsdVoxeHVJQ0FnSUdadmNpaDJZWElnYVNBOUlEQTdJR2tnUENCamFHRnBibk11YkdWdVozUm9PeUJwS3lzcElIc2dZV1JrS0NrN0lIMWNibHh1SUNBZ0lDOHZJSE4wWVhKME9pQmtaWEYxWlhWbElHWnBjbk4wSUdsMFpXMGdZVzVrSUhKMWJpQnBkRnh1SUNBZ0lIRXVkR0ZyWlNncE8xeHVYRzRnSUNBZ2NtVjBkWEp1SUdSbFptVnljbVZrTG5CeWIyMXBjMlU3WEc0Z0lIMHNYRzVjYmlBZ0x5b3FYRzRnSUNBcUlGUm9aU0JsZG1WdWRDQnpkSEpsWVcwZ1FWQkpJR2x6SUhWdWFYRjFaU0IzYVhSb2FXNGdkR2hsSUVSbGNHeHZlVklnUVZCSklHRnpJR2wwSUhOMWNIQnZjblJ6SUhCMWMyZ2dYRzRnSUNBcUlHNXZkR2xtYVdOaGRHbHZibk1nWm5KdmJTQjBhR1VnUkdWd2JHOTVVaUJ6WlhKMlpYSWdkRzhnWTJ4cFpXNTBJR0Z3Y0d4cFkyRjBhVzl1Y3k0Z1RtOTBhV1pwWTJGMGFXOXVjeUJjYmlBZ0lDb2dZMjl5Y21WemNHOXVaQ0IwYnlCa2FYTmpjbVYwWlNCbGRtVnVkSE1nZEdoaGRDQnZZMk4xY2lCM2FYUm9hVzRnZEdobElFUmxjR3h2ZVZJZ2MyVnlkbVZ5TGlCVWFHVnlaU0JjYmlBZ0lDb2dZWEpsSUdadmRYSWdaR2x6ZEdsdVkzUWdaWFpsYm5RZ1kyRjBaV2R2Y21sbGN6cGNiaUFnSUNvZ1hHNGdJQ0FxSUMwZ1UzUnlaV0Z0SUV4cFptVmplV05zWlNCbGRtVnVkSE5jYmlBZ0lDb2dMU0JGZUdWamRYUnBiMjRnWlhabGJuUnpYRzRnSUNBcUlDMGdTbTlpSUV4cFptVmplV05zWlNCbGRtVnVkSE5jYmlBZ0lDb2dMU0JOWVc1aFoyVnRaVzUwSUdWMlpXNTBjMXh1SUNBZ0tseHVJQ0FnS2lCRmVHRnRjR3hsT2x4dUlDQWdLaUJnWUdCY2JpQWdJQ29nWkdWd2JHOTVjaTVsY3loN0lIVnpaWEp1WVcxbE9pQW5kR1Z6ZEhWelpYSW5MQ0J3WVhOemQyOXlaRG9nSjNObFkzSmxkQ2NnZlNsY2JpQWdJQ29nSUNBZ0x5OGdMUzBnWTI5dWJtVmpkR2x2YmlCamFHOXBZMlZ6SUdadmNpQmxkbVZ1ZENCMGVYQmxjeUF0TFZ4dUlDQWdLaUFnSUNBdWJXRnVZV2RsYldWdWRDZ3BJQ0F2THk1elpYTnphVzl1S0NrZ2ZDQXVZV3hzS0NrZ2ZDQXVjSEp2YW1WamRDaHBaQ2tnZkNBdWFtOWlLR2xrS1Z4dUlDQWdLaUFnSUNBdWIyNG9KMlZ6T21keWFXUklaV0Z5ZEdKbFlYUW5MQ0JtZFc1amRHbHZiaWhrWVhSaEtTQjdYRzRnSUNBcUlDQWdJQ0FnSUNCamIyNXpiMnhsTG14dlp5Z25QVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQU2NwTzF4dUlDQWdLaUFnSUNBZ0lDQWdZMjl1YzI5c1pTNXNiMmNvSjJWek9tZHlhV1JJWldGeWRHSmxZWFFuS1R0Y2JpQWdJQ29nSUNBZ0lDQWdJR052Ym5OdmJHVXViRzluS0NjOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOUp5azdJQ0FnSUNBZ0lDQWdJRnh1SUNBZ0tpQWdJQ0FnZlNsY2JpQWdJQ29nSUNBZ0lDNXZjR1Z1S0NrN1hHNGdJQ0FxSUdCZ1lGeHVJQ0FnS2lCY2JpQWdJQ29nUUcxbGRHaHZaQ0JsYzF4dUlDQWdLaUJBY0dGeVlXMGdlMDlpYW1WamRIMGdiM0IwYVc5dWN5QlVhR1VnYjJKcVpXTjBJR3hwZEdWeVlXd2dZMjl1Wm1sbmRYSmhkR2x2YmlCb1lYTm9MaUJjYmlBZ0lDb2dRSE4wWVhScFkxeHVJQ0FnS2lCQWNtVjBkWEp1SUh0RmRtVnVkRk4wY21WaGJYMGdZU0J1WlhjZ1lFVjJaVzUwVTNSeVpXRnRZQ0JtYjNJZ1ltbHVaR2x1Wnk1Y2JpQWdJQ29nUUdGd2FTQndkV0pzYVdNZ0lDQmNiaUFnSUNvdklDQmNiaUFnWlhNNklHWjFibU4wYVc5dUtHOXdkR2x2Ym5NcElIc2dJQ0FnWEc0Z0lDQWdkbUZ5SUhOMGNtVmhiU0E5SUVWMlpXNTBVM1J5WldGdExtNWxkeWhuYkc5aVlXeFBjSFJwYjI1ekxtaHZjM1FzSUc5d2RHbHZibk1wTzF4dVhHNGdJQ0FnYVdZZ0tHOXdkR2x2Ym5NZ0ppWWdiM0IwYVc5dWN5NTFjMlZ5Ym1GdFpTQW1KaUJ2Y0hScGIyNXpMbkJoYzNOM2IzSmtLU0I3WEc0Z0lDQWdJQ0IyWVhJZ2NuVnpaWElnUFNCMGFHbHpMbUYxZEdnb2IzQjBhVzl1Y3k1MWMyVnlibUZ0WlN3Z2IzQjBhVzl1Y3k1d1lYTnpkMjl5WkNrN1hHNGdJQ0FnSUNCeWRYTmxjaTVsYm5OMWNtVW9ablZ1WTNScGIyNG9LU0I3SUZ4dUlDQWdJQ0FnSUNCemRISmxZVzB1YzJoaGNtVW9jblZ6WlhJdVoyVjBRMjl2YTJsbGN5Z3BLVHRjYmlBZ0lDQWdJQ0FnYzNSeVpXRnRMbVpzZFhOb0tDazdJRnh1SUNBZ0lDQWdmU2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdjbVYwZFhKdUlITjBjbVZoYlR0Y2JpQWdmU3hjYmx4dUlDQXZLaXBjYmlBZ0lDb2dSR1ZtYVc1bGN5QjBhR1VnWm1GamRHOXllU0JtYjNJZ1kzSmxZWFJwYm1jZ1lTQkVaWEJzYjNsU0xYTndaV05wWm1saklHVnVZMjlrWldRZ1VpQnZZbXBsWTNRZ2RHOGdZbVVnWEc0Z0lDQXFJSE5sYm5RZ1lYTWdhVzV3ZFhRZ2NHRnlZVzFsZEdWeWN5QjBieUJoYmlCU0lITmpjbWx3ZEM1Y2JpQWdJQ3BjYmlBZ0lDb2dSWGhoYlhCc1pUcGNiaUFnSUNvZ1lHQmdYRzRnSUNBcUlDQWdJSFpoY2lCeWFXNXdkWFFnUFNCa1pYQnNiM2x5TGxKSmJuQjFkQzVzYjJkcFkyRnNLQ2RzYjJkcFkyRnNYMjVoYldVbkxDQjBjblZsS1R0Y2JpQWdJQ29nSUNBZ2RtRnlJSEpwYm5CMWRDQTlJR1JsY0d4dmVYSXVVa2x1Y0hWMExtNTFiV1Z5YVdNb0oyNTFiV1Z5YVdOZmJtRnRaU2NzSURFd0xqVXBPMXh1SUNBZ0tpQWdJQ0IyWVhJZ2NtbHVjSFYwSUQwZ1pHVndiRzk1Y2k1U1NXNXdkWFF1YVc1MFpXZGxjaWduYVc1MFpXZGxjbDl1WVcxbEp5d2dOU2s3WEc0Z0lDQXFJQ0FnSUhaaGNpQnlhVzV3ZFhRZ1BTQmtaWEJzYjNseUxsSkpibkIxZEM1amFHRnlZV04wWlhJb0oyTm9ZWEpoWTNSbGNsOXVZVzFsSnl3Z0owaGxiR3h2SnlrN1hHNGdJQ0FxSUNBZ0lDOHZJR1ZqZEM0dUxseHVJQ0FnS2lCZ1lHQmNiaUFnSUNvZ1FIQnliM0JsY25SNUlGSkpibkIxZEZ4dUlDQWdLaUJBYzNSaGRHbGpYRzRnSUNBcUlFQmhjR2tnY0hWaWJHbGpYRzRnSUNBcUwxeHVJQ0JTU1c1d2RYUTZJSHRjYmlBZ0lDQnVkVzFsY21sak9pQm1kVzVqZEdsdmJpQW9ibUZ0WlN3Z2RtRnNkV1VwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJTU1c1d2RYUXVibVYzS0c1aGJXVXNJSFpoYkhWbEtTNXVkVzFsY21saktDazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lHbHVkR1ZuWlhJNklHWjFibU4wYVc5dUlDaHVZVzFsTENCMllXeDFaU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJRkpKYm5CMWRDNXVaWGNvYm1GdFpTd2dkbUZzZFdVcExtbHVkR1ZuWlhJb0tUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2JHOW5hV05oYkRvZ1puVnVZM1JwYjI0Z0tHNWhiV1VzSUhaaGJIVmxLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdVa2x1Y0hWMExtNWxkeWh1WVcxbExDQjJZV3gxWlNrdWJHOW5hV05oYkNncE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNCamFHRnlZV04wWlhJNklHWjFibU4wYVc5dUlDaHVZVzFsTENCMllXeDFaU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJRkpKYm5CMWRDNXVaWGNvYm1GdFpTd2dkbUZzZFdVcExtTm9ZWEpoWTNSbGNpZ3BPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQmtZWFJsT2lCbWRXNWpkR2x2YmlBb2JtRnRaU3dnZG1Gc2RXVXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQlNTVzV3ZFhRdWJtVjNLRzVoYldVc0lIWmhiSFZsS1M1a1lYUmxLQ2s3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJSEJ2YzJsNFkzUTZJR1oxYm1OMGFXOXVJQ2h1WVcxbExDQjJZV3gxWlNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUZKSmJuQjFkQzV1Wlhjb2JtRnRaU3dnZG1Gc2RXVXBMbkJ2YzJsNFkzUW9LVHRjYmlBZ0lDQjlMQ0FnWEc1Y2JpQWdJQ0J1ZFcxbGNtbGpWbVZqZEc5eU9pQm1kVzVqZEdsdmJpaHVZVzFsTENCMllXeDFaU2tnZTF4dUlDQWdJQ0FnY21WMGRYSnVJRkpKYm5CMWRDNXVaWGNvYm1GdFpTd2dkbUZzZFdVcExtNTFiV1Z5YVdOV1pXTjBiM0lvS1R0Y2JpQWdJQ0I5TENCY2JseHVJQ0FnSUdsdWRHVm5aWEpXWldOMGIzSTZJR1oxYm1OMGFXOXVJQ2h1WVcxbExDQjJZV3gxWlNrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUZKSmJuQjFkQzV1Wlhjb2JtRnRaU3dnZG1Gc2RXVXBMbWx1ZEdWblpYSldaV04wYjNJb0tUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2JHOW5hV05oYkZabFkzUnZjam9nWm5WdVkzUnBiMjRnS0c1aGJXVXNJSFpoYkhWbEtTQjdJRnh1SUNBZ0lDQWdjbVYwZFhKdUlGSkpibkIxZEM1dVpYY29ibUZ0WlN3Z2RtRnNkV1VwTG14dloybGpZV3hXWldOMGIzSW9LVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdZMmhoY21GamRHVnlWbVZqZEc5eU9pQm1kVzVqZEdsdmJpQW9ibUZ0WlN3Z2RtRnNkV1VwSUhzZ1hHNGdJQ0FnSUNCeVpYUjFjbTRnVWtsdWNIVjBMbTVsZHlodVlXMWxMQ0IyWVd4MVpTa3VZMmhoY21GamRHVnlWbVZqZEc5eUtDazdYRzRnSUNBZ2ZTd2dJRnh1WEc0Z0lDQWdaR0YwWlZabFkzUnZjam9nWm5WdVkzUnBiMjRnS0c1aGJXVXNJSFpoYkhWbEtTQjdJRnh1SUNBZ0lDQWdjbVYwZFhKdUlGSkpibkIxZEM1dVpYY29ibUZ0WlN3Z2RtRnNkV1VwTG1SaGRHVldaV04wYjNJb0tUdGNiaUFnSUNCOUxDQWdYRzVjYmlBZ0lDQndiM05wZUdOMFZtVmpkRzl5T2lCbWRXNWpkR2x2YmlBb2JtRnRaU3dnZG1Gc2RXVXBJSHNnWEc0Z0lDQWdJQ0J5WlhSMWNtNGdVa2x1Y0hWMExtNWxkeWh1WVcxbExDQjJZV3gxWlNrdWNHOXphWGhqZEZabFkzUnZjaWdwTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0JzYVhOME9pQm1kVzVqZEdsdmJpQW9ibUZ0WlN3Z2RtRnNkV1VwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJTU1c1d2RYUXVibVYzS0c1aGJXVXNJSFpoYkhWbEtTNXNhWE4wS0NrN0lGeHVJQ0FnSUgwc1hHNWNiaUFnSUNCa1lYUmhabkpoYldVNklHWjFibU4wYVc5dUlDaHVZVzFsTENCMllXeDFaU2tnZXlCY2JpQWdJQ0FnSUhKbGRIVnliaUJTU1c1d2RYUXVibVYzS0c1aGJXVXNJSFpoYkhWbEtTNWtZWFJoWm5KaGJXVW9LVHRjYmlBZ0lDQjlMRnh1SUNCY2JpQWdJQ0JtWVdOMGIzSTZJR1oxYm1OMGFXOXVJQ2h1WVcxbExDQjJZV3gxWlN3Z2JHVjJaV3h6TENCc1lXSmxiSE1wSUh0Y2JpQWdJQ0FnSUhaaGNpQnZjSFJ6SUQwZ2V5QnNaWFpsYkhNNklHeGxkbVZzY3l3Z2JHRmlaV3h6T2lCc1lXSmxiSE1nZlR0Y2JpQWdJQ0FnSUhKbGRIVnliaUJTU1c1d2RYUXVibVYzS0c1aGJXVXNJSFpoYkhWbExDQnZjSFJ6S1M1bVlXTjBiM0lvS1R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnYjNKa1pYSmxaRG9nWm5WdVkzUnBiMjRnS0c1aGJXVXNJSFpoYkhWbExDQnNaWFpsYkhNc0lHeGhZbVZzY3lrZ2UxeHVJQ0FnSUNBZ2RtRnlJRzl3ZEhNZ1BTQjdJR3hsZG1Wc2N6b2diR1YyWld4ekxDQnNZV0psYkhNNklHeGhZbVZzY3lCOU8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUZKSmJuQjFkQzV1Wlhjb2JtRnRaU3dnZG1Gc2RXVXNJRzl3ZEhNcExtOXlaR1Z5WldRb0tUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2JuVnRaWEpwWTAxaGRISnBlRG9nWm5WdVkzUnBiMjRnS0c1aGJXVXNJSFpoYkhWbEtTQjdJRnh1SUNBZ0lDQWdjbVYwZFhKdUlGSkpibkIxZEM1dVpYY29ibUZ0WlN3Z2RtRnNkV1VwTG01MWJXVnlhV05OWVhSeWFYZ29LVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdhVzUwWldkbGNrMWhkSEpwZURvZ1puVnVZM1JwYjI0Z0tHNWhiV1VzSUhaaGJIVmxLU0I3SUZ4dUlDQWdJQ0FnY21WMGRYSnVJRkpKYm5CMWRDNXVaWGNvYm1GdFpTd2dkbUZzZFdVcExtbHVkR1ZuWlhKTllYUnlhWGdvS1R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnYkc5bmFXTmhiRTFoZEhKcGVEb2dablZ1WTNScGIyNGdLRzVoYldVc0lIWmhiSFZsS1NCN0lGeHVJQ0FnSUNBZ2NtVjBkWEp1SUZKSmJuQjFkQzV1Wlhjb2JtRnRaU3dnZG1Gc2RXVXBMbXh2WjJsallXeE5ZWFJ5YVhnb0tUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ1kyaGhjbUZqZEdWeVRXRjBjbWw0T2lCbWRXNWpkR2x2YmlBb2JtRnRaU3dnZG1Gc2RXVXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQlNTVzV3ZFhRdWJtVjNLRzVoYldVc0lIWmhiSFZsS1M1amFHRnlZV04wWlhKTllYUnlhWGdvS1R0Y2JpQWdJQ0I5WEc0Z0lIMWNibjA3SWwxOSIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlXG4gKiBkZXRhaWxzLlxuICovXG52YXIgTGFuZyA9IHJlcXVpcmUoJy4vbGFuZycpLFxuICAgIEJhc2UgPSByZXF1aXJlKCcuL3NlbGZpc2gnKS5CYXNlLFxuICAgIFJJbnB1dCA9IHJlcXVpcmUoJy4vcmlucHV0Jyk7XG5cbnZhciBEZXByZWNhdGVkLFxuICAgIGVtaXR0ZXIsXG4gICAgX2NvbmZpZyA9IHt9LFxuICAgIFRPUExFVkVMX0VOVElUSUVTID0gW1xuICAgICAgICAndXNlcicsXG4gICAgICAgICdwcm9qZWN0JyxcbiAgICAgICAgJ3dvcmtzcGFjZScsXG4gICAgICAgICdleGVjdXRpb24nLFxuICAgICAgICAnZGlyZWN0b3J5JyxcbiAgICAgICAgJ3JlcG9zaXRvcnknLFxuICAgICAgICAncGFja2FnZXMnXG4gICAgXTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgU2Vzc2lvbk1hbmFnZXIgPSB7XG4gICAgRU5EUE9JTlRfV0hJVEVMSVNUOiB7XG4gICAgICAgIGxvZ2luOiAnL3IvdXNlci9sb2dpbicsXG4gICAgICAgIGxvZ291dDogJy9yL3VzZXIvbG9nb3V0JyxcbiAgICAgICAgcHJvamVjdENyZWF0ZTogJy9yL3Byb2plY3QvY3JlYXRlJyxcbiAgICAgICAgcHJvamVjdENsb3NlOiAnL3IvcHJvamVjdC9jbG9zZScsXG4gICAgICAgIHByb2plY3RBYm91dFVwZGF0ZTogJy9yL3Byb2plY3QvYWJvdXQvdXBkYXRlJyxcbiAgICAgICAgcHJvamVjdFNhdmU6ICcvci9wcm9qZWN0L3NhdmUnLFxuICAgICAgICBwcm9qZWN0U2F2ZUFzOiAnL3IvcHJvamVjdC9zYXZlYXMnLFxuICAgICAgICAvLyAtLS0gcHJpdmF0ZSBBUElTIC0tLVxuICAgICAgICBjbGllbnRQcm9qZWN0U2F2ZTogJy9yL2NsaWVudC9wcm9qZWN0L3NhdmUnLFxuICAgICAgICBjbGllbnRQcm9qZWN0Q2xvc2U6ICcvci9jbGllbnQvcHJvamVjdC9jbG9zZSdcbiAgICB9LFxuXG4gICAgc2Vzc2lvbjoge30sXG5cbiAgICBjb25maWc6IHt9LFxuXG4gICAgc2V0VW5sb2FkQ29uZmlnOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIGRpc2FibGVhdXRvc2F2ZTogY29uZmlnLmRpc2FibGVhdXRvc2F2ZSB8fCB0cnVlLFxuICAgICAgICAgICAgZHJvcHdvcmtzcGFjZTogY29uZmlnLmRyb3B3b3Jrc3BhY2UgfHwgdHJ1ZSxcbiAgICAgICAgICAgIGRyb3BkaXJlY3Rvcnk6IGNvbmZpZy5kcm9wZGlyZWN0b3J5IHx8IHRydWUsXG4gICAgICAgICAgICBkcm9waGlzdG9yeTogY29uZmlnLmRyb3BoaXN0b3J5IHx8IHRydWUsXG4gICAgICAgICAgICBmbHVzaGhpc3Rvcnk6IGNvbmZpZy5mbHVzaGhpc3RvcnkgfHwgdHJ1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc2V0U2Vzc2lvbjogZnVuY3Rpb24oc2Vzc2lvbikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIH0sXG4gICAgc2V0UHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCkge1xuICAgICAgICB0aGlzLnNlc3Npb24ucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfSxcbiAgICBjbGVhclNlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB9LFxuICAgIGNsZWFyUHJvamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5wcm9qZWN0ID0gbnVsbDtcbiAgICB9LFxuICAgIHVubG9hZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHByb2plY3QgPSB0aGlzLnNlc3Npb24ucHJvamVjdDtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2NvbmZpZztcbiAgICAgICAgICAgICAgICBkYXRhLnByb2plY3QgPSBwcm9qZWN0LmlkO1xuICAgICAgICAgICAgICAgIGRhdGEucHJvamVjdGNvb2tpZSA9IHByb2plY3QuY29va2llO1xuXG4gICAgICAgICAgICAgICAgZGVwbG95ci5pbygnL3IvcHJvamVjdC9jbG9zZScpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5zeW5jKClcbiAgICAgICAgICAgICAgICAgICAgLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIGZvcm1hdChyZXNwb25zZSwgdHJhbnNFbnRpdHkpIHtcbiAgICAvLyAtLSB0cmFuc2FjdGlvbiBlbnRpdHkgZm9ybWF0cyBvdmVycmlkZSBnbG9iYWwgZW50aXR5IGZvcm1hdHMgLS0gIFxuICAgIC8vdmFyIGZvcm1hdCA9IHRyYW5zRW50aXR5IHx8IF9jb25maWcuZW50aXR5O1xuICAgIHZhciBmb3JtYXQgPSB0cmFuc0VudGl0eSB8fCBnbG9iYWxDb25maWcuZW50aXR5O1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICB2YXIgcmVzT2JqID0gcmVzcG9uc2UuZGVwbG95ci5yZXNwb25zZSxcbiAgICAgICAgICAgIC8vIC0tIHRvcC1sZXZlbCBlbnRpdGllcyAtLVxuICAgICAgICAgICAgZW50aXRpZXMgPSBUT1BMRVZFTF9FTlRJVElFUztcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZW50aXRpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gZW50aXRpZXNbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAocmVzT2JqW2VudGl0eV0gJiYgZm9ybWF0W2VudGl0eV0pIHsgLy8gcmVzcG9uc2UgZW50aXR5IGhpdFxuICAgICAgICAgICAgICAgIC8vIC0tIHVzZXItZGVmaW5lZCBwYXJzZSBmb3IgdG9wLWxldmVsIGVudGl0eSAtLSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0W2VudGl0eV0ucGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXRTY29wZSA9IGZvcm1hdFtlbnRpdHldLnNjb3BlIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJlc09ialtlbnRpdHldID0gZm9ybWF0W2VudGl0eV0ucGFyc2VyLmNhbGwoZm9ybWF0U2NvcGUsIHJlc09ialtlbnRpdHldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZUVuZHBvaW50KHJlc3BvbnNlLCBlbmRwb2ludCwgYXJncykge1xuXG4gICAgdmFyIHJlc09iaiA9IHJlc3BvbnNlLmRlcGxveXIucmVzcG9uc2UsXG4gICAgICAgIEVORFBPSU5UID0gU2Vzc2lvbk1hbmFnZXIuRU5EUE9JTlRfV0hJVEVMSVNUO1xuXG4gICAgc3dpdGNoIChlbmRwb2ludCkge1xuXG4gICAgICAgIGNhc2UgRU5EUE9JTlQubG9naW46XG5cbiAgICAgICAgICAgIFNlc3Npb25NYW5hZ2VyLnNldFNlc3Npb24oe1xuICAgICAgICAgICAgICAgIGh0dHBjb29raWU6IHJlc09iai5odHRwY29va2llLFxuICAgICAgICAgICAgICAgIHVzZXI6IHJlc09iai51c2VyLFxuICAgICAgICAgICAgICAgIGxpbWl0czogcmVzT2JqLmxpbWl0cyxcbiAgICAgICAgICAgICAgICBwcm9qZWN0OiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRU5EUE9JTlQubG9nb3V0OlxuICAgICAgICAgICAgU2Vzc2lvbk1hbmFnZXIuY2xlYXJTZXNzaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEVORFBPSU5ULnByb2plY3RDbG9zZTpcbiAgICAgICAgY2FzZSBFTkRQT0lOVC5jbGllbnRQcm9qZWN0Q2xvc2U6XG4gICAgICAgICAgICBTZXNzaW9uTWFuYWdlci5jbGVhclByb2plY3QoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRU5EUE9JTlQucHJvamVjdENyZWF0ZTpcbiAgICAgICAgY2FzZSBFTkRQT0lOVC5wcm9qZWN0QWJvdXRVcGRhdGU6XG4gICAgICAgIGNhc2UgRU5EUE9JTlQucHJvamVjdFNhdmU6XG4gICAgICAgIGNhc2UgRU5EUE9JTlQucHJvamVjdFNhdmVBczpcbiAgICAgICAgY2FzZSBFTkRQT0lOVC5jbGllbnRQcm9qZWN0U2F2ZTpcbiAgICAgICAgICAgIHZhciBwcm9qZWN0ID0gcmVzT2JqLnByb2plY3Q7XG4gICAgICAgICAgICBTZXNzaW9uTWFuYWdlci5zZXRQcm9qZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogcHJvamVjdC5wcm9qZWN0LFxuICAgICAgICAgICAgICAgIGNvb2tpZTogcHJvamVjdC5jb29raWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICB9IC8vIGVuZCBzd2l0Y2hcblxuICAgIERlcHJlY2F0ZWQuRXZlbnQuZmlyZSgnRGVwbG95UjplbmRwb2ludENoYW5nZScsIHtcbiAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICBlbmRwb2ludDogZW5kcG9pbnQsXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KTtcbn1cblxuXG5mdW5jdGlvbiBjYW1lbENhc2UoaW5wdXQpIHtcbiAgICAvLyBjb252ZXJ0IGZvcm1hdDogJy9yL3VzZXIvbG9naW4nIC0tPiAndXNlckxvZ2luJ1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgnXFwvclxcLycsICcnKTtcbiAgICByZXR1cm4gaW5wdXQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC8oLikvZywgZnVuY3Rpb24obWF0Y2gsIHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbn1cblxuLy8gdHVybiB0aGUgb2xkIGRlcHJlY2F0ZWQgaW5wdXRzIGludG8gbmV3IGlucHV0c1xuZnVuY3Rpb24gbm9ybWFsaXplSW5wdXRzKGlucHV0cykge1xuICAgIHZhciByaW5wdXRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByaW5wdXRzLnB1c2goaW5wdXRzW2ldLm5vcm1hbGl6ZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmlucHV0cztcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIFRoZSBEZXByZWNhdGVkIGludGVyZmFjZS5cbiAqL1xudmFyIFJEYXRhID0gQmFzZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHR5cGUsIHJjbGFzcywgcmlucHV0KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucmNsYXNzID0gcmNsYXNzO1xuICAgICAgICB0aGlzLnJpbnB1dCA9IHJpbnB1dDtcbiAgICB9LFxuXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfSxcblxuICAgIGdldFJDbGFzczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJjbGFzcztcbiAgICB9LFxuXG4gICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpbnB1dC5uYW1lO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpbnB1dC52YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0TGV2ZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlucHV0LmxldmVscztcbiAgICB9LFxuXG4gICAgZ2V0TGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlucHV0LmxhYmVscztcbiAgICB9LFxuXG4gICAgZ2V0T3JkZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJpbnB1dC5vcmRlcmVkO1xuICAgIH0sXG5cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yaW5wdXQ7XG4gICAgfVxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHsgIFxuICBcbn1cblxuZnVuY3Rpb24gZGVidWcobXNnKSB7ICBcbn1cblxuRW1pdHRlci5wcm90b3R5cGUgPSB7XG5cbiAgZXZlbnRzOiB7fSxcblxuICBzY29wZTogbnVsbCxcblxuICAvKipcbiAgICogQWRkcyBhIGxpc3RlbmVyLiAgTXVsdGlwbGUgY2FuIGJlIGFkZGVkIHBlciBuYW1lLiAgQWxpYXNlZCBhcyBgb25gLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAqL1xuICBvbjogZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgIGlmIChuYW1lIGluIHRoaXMuZXZlbnRzID09PSBmYWxzZSkgeyB0aGlzLmV2ZW50c1tuYW1lXSA9IFtdOyB9ICAgICAgICBcblxuICAgIHRoaXMuZXZlbnRzW25hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgZGVidWcoJ0VtaXR0ZXIub24oXCInICsgbmFtZSArICdcIiknKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhbGwgbWF0Y2hpbmcgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBhbiBldmVudCBmaXJlZFxuICAgKi9cbiAgZW1pdDogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuZXZlbnRzID09PSBmYWxzZSkgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50c1tuYW1lXS5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoJ0ZpcmVkIGV2ZW50OiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgICB0aGlzLmV2ZW50c1tuYW1lXVtpXS5hcHBseSh0aGlzLnNjb3BlIHx8IHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpOyAgICAgICBcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgbWF0Y2hpbmcgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBhbiBldmVudCB3YXMgcmVtb3ZlZFxuICAgKi9cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBmb3IgKHZhciBlIGluIHRoaXMuZXZlbnRzKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tlXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5hbWUgaW4gdGhpcy5ldmVudHMgPT09IGZhbHNlKSB7IHJldHVybiB0aGlzOyB9XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNbbmFtZV07ICAgICAgICBcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZW1vdmVMaXN0ZW5lckF0OiBmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuZXZlbnRzW25hbWVdLFxuICAgICAgICByZXN0ID0gYXJyYXkuc2xpY2UoaW5kZXggKyAxKTtcblxuICAgIGFycmF5Lmxlbmd0aCA9IGluZGV4O1xuICAgIGFycmF5LnB1c2guYXBwbHkoYXJyYXksIHJlc3QpO1xuICAgIHRoaXMuZXZlbnRzW25hbWVdID0gYXJyYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBiYXNlZCBvbiB0aGUgaGFuZGxlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIGhhbmRsZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgYW4gZXZlbnQgd2FzIHJlbW92ZWRcbiAgICovXG4gIG9mZjogZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgIGlmIChuYW1lIGluIHRoaXMuZXZlbnRzID09PSBmYWxzZSkgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBldmVudHMgaGFuZGxlcnMgYnkgdGhpcyBuYW1lXG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMobmFtZSk7XG4gICAgfSBlbHNlIHsgLy8gcmVtb3ZlIGFsbCBldmVudHMgaGFuZGxlcnMgPT0gJ2hhbmRsZXInIGJ5IHRoaXMgbmFtZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50c1tuYW1lXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5ldmVudHNbbmFtZV1baV0gPT0gaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJBdChuYW1lLCBpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuXG5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcblxuLyoqXG4gKiBQcm92aWRlcyBzaW1wbGUgYWRhcHRlciBtZXRob2RzIHdoaWNoIHdyYXAgdGhlIHJhdyA8Y29kZT5SZXZvbHV0aW9uLkRlcGxveVIuaW8oLi4uKTwvY29kZT5cbiAqIHJlbW90ZSBEZXBsb3lSIEFQSSBBSkFYIHRyYW5zYWN0aW9ucy4gVGhlc2UgbWV0aG9kcyBhcmUgYW4gb3B0LWluIGZlYXR1cmUgdG9cbiAqIGNvbXBsZW1lbnQgdGhlIGxvdyBsZXZlbCBEZXBsb3lSIElPIGNvbW11bmljYXRpb24uXG4gKlxuICogQGNsYXNzIFJldm9sdXRpb24uRGVwbG95Ui5QdWJsaWNBZGFwdGVyXG4gKiBAZXh0ZW5zaW9uZm9yIFJldm9sdXRpb24uRGVwbG95UlxuICovXG5cbkRlcHJlY2F0ZWQgPSB7XG4gICAgdmVyc2lvbjogcmVxdWlyZSgnLi4vcGFja2FnZScpLnZlcnNpb24sXG5cbiAgICBFdmVudDoge1xuICAgICAgICBvbjogZnVuY3Rpb24odHlwZSwgZm4sIHNjb3BlKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKHR5cGUsIGZuLCBzY29wZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbih0eXBlLCBmbiwgb2JqKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9mZih0eXBlLCBmbik7ICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgUkRhdGFGYWN0b3J5OiB7XG4gICAgICAgIGNyZWF0ZU51bWVyaWM6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gUkRhdGEubmV3KCdwcmltaXRpdmUnLCAnbnVtZXJpYycsIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLm51bWVyaWMoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlSW50ZWdlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBSRGF0YS5uZXcoJ3ByaW1pdGl2ZScsICdpbnRlZ2VyJywgUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkuaW50ZWdlcigpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVCb29sZWFuOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJEYXRhLm5ldygncHJpbWl0aXZlJywgJ251bWVyaWMnLCBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5sb2dpY2FsKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVN0cmluZzogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBSRGF0YS5uZXcoJ3ByaW1pdGl2ZScsICdjaGFyYWN0ZXInLCBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5jaGFyYWN0ZXIoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlRGF0ZTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBSRGF0YS5uZXcoJ2RhdGUnLCAnRGF0ZScsIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmRhdGUoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUE9TSVhEYXRlOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJEYXRhLm5ldygnZGF0ZScsICdQT1NJWGN0JywgUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkucG9zaXhjdCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVOdW1lcmljVmVjdG9yOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJEYXRhLm5ldygndmVjdG9yJywgJ251bWVyaWMnLCBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5udW1lcmljVmVjdG9yKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUludGVnZXJWZWN0b3I6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gUkRhdGEubmV3KCd2ZWN0b3InLCAnaW50ZWdlcicsIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmludGVnZXJWZWN0b3IoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQm9vbGVhblZlY3RvcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBSRGF0YS5uZXcoJ3ZlY3RvcicsICdsb2dpY2FsJywgUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkubG9naWNhbFZlY3RvcigpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVTdHJpbmdWZWN0b3I6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gUkRhdGEubmV3KCd2ZWN0b3InLCAnY2hhcmFjdGVyJywgUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkuY2hhcmFjdGVyVmVjdG9yKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZURhdGVWZWN0b3I6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gUkRhdGEubmV3KCd0eXBlJywgJ0RhdGUnLCBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5kYXRlVmVjdG9yKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVBPU0lYRGF0ZVZlY3RvcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBSRGF0YS5uZXcoJ3ZlY3RvcicsICdQT1NJWGN0JywgUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkucG9zaXhjdFZlY3RvcigpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMaXN0OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJEYXRhLm5ldygnbGlzdCcsICdsaXN0JywgUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkubGlzdCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVEYXRhZnJhbWU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gUkRhdGEubmV3KCdkYXRhZnJhbWUnLCAnZGF0YS5mcmFtZScsIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmRhdGFmcmFtZSgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVGYWN0b3I6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBvcmRlcmVkLCBsZXZlbHMsIGxhYmVscykge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxzOiBsZXZlbHMsXG4gICAgICAgICAgICAgICAgbGFiZWxzOiBsYWJlbHNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChvcmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJEYXRhLm5ldygnZmFjdG9yJywgJ2ZhY3RvcicsIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUsIG9wdHMpLm9yZGVyZWQoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBSRGF0YS5uZXcoJ2ZhY3RvcicsICdmYWN0b3InLCBSSW5wdXQubmV3KG5hbWUsIHZhbHVlLCBvcHRzKS5mYWN0b3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTnVtZXJpY01hdHJpeDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBSRGF0YS5uZXcoJ21hdHJpeCcsICdtYXRyaXgnLCBSSW5wdXQubmV3KG5hbWUsIHZhbHVlKS5udW1lcmljTWF0cml4KCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUludGVnZXJNYXRyaXg6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gUkRhdGEubmV3KCdtYXRyaXgnLCAnbWF0cml4JywgUklucHV0Lm5ldyhuYW1lLCB2YWx1ZSkuaW50ZWdlck1hdHJpeCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVCb29sZWFuTWF0cml4OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJEYXRhLm5ldygnbWF0cml4JywgJ21hdHJpeCcsIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmxvZ2ljYWxNYXRyaXgoKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlU3RyaW5nTWF0cml4OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJEYXRhLm5ldygnbWF0cml4JywgJ21hdHJpeCcsIFJJbnB1dC5uZXcobmFtZSwgdmFsdWUpLmNoYXJhY3Rlck1hdHJpeCgpKTtcbiAgICAgICAgfVxuICAgIH0sIC8vIFJEYXRhRmFjdG9yeVxuXG4gICAgRGVwbG95Ujoge1xuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyAtLS0gQXNzZXJ0IEpTRGVwbG95IGNvbXBhdGFiaWxpdHkgYWdhaW5zdCB0aGUgY29ubmVjdGVkIERlcGxveVIgdmVyc2lvbiAtLS1cbiAgICAgICAgICAgIGlmIChjb25maWcuY29tcGF0aWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIC8vY29tcGF0aWJpbGl0eUNoZWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLSBFdmVudCByZWdpc3RyYXRpb24gLS0tXG4gICAgICAgICAgICBpZiAoY29uZmlnLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSBjb25maWcuZXZlbnRzO1xuXG4gICAgICAgICAgICAgICAgLy8gLS0gTWFuYWdlIGNsZWFudXAgb24gYnJvd3NlciBjbG9zZSAoY2xvc2UgcHJvamVjdCwgbG9nb3V0LCBlY3QuLi4pLS1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLnVubG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBTZXNzaW9uTWFuYWdlci5zZXRVbmxvYWRDb25maWcoZXZlbnRzLnVubG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIERlcHJlY2F0ZWQuRXZlbnQub24oJ2RlcGxveVI6dW5sb2FkJywgU2Vzc2lvbk1hbmFnZXIudW5sb2FkSGFuZGxlciwgU2Vzc2lvbk1hbmFnZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIC0tIElPIEdsb2JhbCBFdmVudHMgLS1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmdsb2JhbElPKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY29wZSA9IGV2ZW50cy5nbG9iYWxJTy5zY29wZSB8fCB3aW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWZlY3ljbGUgPSBldmVudHMuZ2xvYmFsSU8ubGlmZWN5Y2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IGV2ZW50cy5nbG9iYWxJTy5zdGF0dXNDb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaWZlY3ljbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBsaWZlY3ljbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZXByZWNhdGVkLkV2ZW50Lm9uKCdkZXBsb3lSLWlvOicgKyBldmVudE5hbWUsIGxpZmVjeWNsZVtldmVudE5hbWVdLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZXByZWNhdGVkLkV2ZW50Lm9uKCdkZXBsb3lSLWlvOicgKyBldmVudE5hbWUsIHN0YXR1c0NvZGVbZXZlbnROYW1lXSwgc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOZXcgQVBJXG4gICAgICAgICAgICBkZXBsb3lyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgaG9zdDogY29uZmlnLmRlcGxveXJVUkksXG4gICAgICAgICAgICAgICAgY29yczogY29uZmlnLmRlcGxveXJVUkkgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9nZ2luZzogY29uZmlnLmxvZ2dpbmcsXG4gICAgICAgICAgICAgICAgc3RpY2t5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbzogZnVuY3Rpb24oYXBpLCBjb25maWcsIGNiKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignXCInICsgY2FtZWxDYXNlKGFwaSkgKyAnKClcIiBBUEkgaXMgbm93IGRlcHJlY2F0ZWQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNiID0gY2IgfHwge307XG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGNvbmZpZy50cmFuc2FjdGlvbiB8fCB7fSxcbiAgICAgICAgICAgICAgICB0cmFuc0FyZ3MgPSB0cmFuc2FjdGlvblsnYXJndW1lbnRzJ10sXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IHRyYW5zYWN0aW9uLnN0YXR1c0NvZGUgfHwge30sXG4gICAgICAgICAgICAgICAgc2NvcGUgPSBjYi5zY29wZSB8fCB3aW5kb3csXG4gICAgICAgICAgICAgICAgcm91dHB1dHMgPSBjb25maWcucm9iamVjdHMsXG4gICAgICAgICAgICAgICAgcmlucHV0cyA9IGNvbmZpZy5pbnB1dHM7IC8vIGNvbmZpZy5pbnB1dHMgPSBSLkRlcGxveVIucGFyc2VJbnB1dHMoY29uZmlnLmlucHV0cyk7XG5cbiAgICAgICAgICAgIC8vIC0tLSBvbWl0IGRlcHJlY2F0ZWQgcHJvcHMgLS0tXG4gICAgICAgICAgICBpZiAoY29uZmlnLnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5tZXRob2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm9uKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5vbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5mb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLmlucHV0cykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuaW5wdXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5yb2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucm9iamVjdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLSBtYWtlIHRoZSBuZXcgcmVxdWVzdCAtLS1cbiAgICAgICAgICAgIHZhciBpbyA9IGRlcGxveXIuaW8oYXBpKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNvbmZpZyB8fCB7fSlcbiAgICAgICAgICAgICAgICAuZXJyb3IoZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYmFsLWZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdkZXBsb3lSLWlvOmZhaWx1cmUnLCBbcmVzcG9uc2UsIGFwaSwgdHJhbnNBcmdzXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24tZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2IuZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IuZmFpbHVyZS5hcHBseShzY29wZSwgW3Jlc3BvbnNlLCBhcGksIHRyYW5zQXJnc10pOyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYmFsLXN0YXR1c0Vycm9yXG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgoJ2RlcGxveVItaW86JyArIGNvZGUpLCBbcmVzcG9uc2UsIGFwaSwgdHJhbnNBcmdzXSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgaW8ucmlucHV0cyhub3JtYWxpemVJbnB1dHMocmlucHV0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgaW8ucm91dHB1dHMocm91dHB1dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnN5bmMpIHtcbiAgICAgICAgICAgICAgICBpby5zeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24udGltZW91dCkge1xuICAgICAgICAgICAgICAgIGlvLnRpbWVvdXQodHJhbnNhY3Rpb24udGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIC0tLSBFcnJvciBzdGF0dXMgY29kZSAtLS0gLy9cbiAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gc3RhdHVzQ29kZSkgeyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlvLm9uKCdkZXBsb3lyLWlvOicgKyBldmVudE5hbWUsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBzdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1c1RleHQgPSByZXNwb25zZS5kZXBsb3lyLnJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3BvbnNlLmRlcGxveXIucmVzcG9uc2UuZXJyb3JDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2Jbc3RhdHVzXS5hcHBseShzY29wZSwgW3Jlc3BvbnNlLCBzdGF0dXMsIHN0YXR1c1RleHQsIGFwaSwgdHJhbnNBcmdzXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAvLyBAQEBAVE9ETyBAQEBAQEBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ2xvYmFsLXN0YXJ0XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2RlcGxveVItaW86c3RhcnQnKTtcblxuICAgICAgICAgICAgLy8vIHRyYW5zYWN0aW9uLXN0YXJ0XG4gICAgICAgICAgICBpZiAoY2Iuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjYi5zdGFydC5hcHBseShzY29wZSwgW2FwaSwgdHJhbnNBcmdzXSk7IFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpby5lbmQoZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBnbG9iYWwtY29tcGxldGVcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2RlcGxveVItaW86Y29tcGxldGUnKTtcblxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uLWNvbXBsZXRlXG4gICAgICAgICAgICAgICAgaWYgKGNiLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNvbXBsZXRlLmFwcGx5KHNjb3BlLCBbcmVzcG9uc2UsIGFwaSwgdHJhbnNBcmdzXSk7IFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGVudGl0eSBtYW5pcHVsYXRpb24gb2YgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmVudGl0eSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGZvcm1hdChyZXNwb25zZSwgdHJhbnNhY3Rpb24uZW50aXR5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBnbG9iYWwtc3VjY2Vzc1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZGVwbG95Ui1pbzpzdWNjZXNzJywgW3Jlc3BvbnNlLCBhcGldKTtcblxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uLXN1Y2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoY2Iuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBjYi5zdWNjZXNzLmFwcGx5KHNjb3BlLCBbcmVzcG9uc2UsIGFwaSwgdHJhbnNBcmdzXSk7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBnbG9iYWwtZW5kXG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdkZXBsb3lSLWlvOmVuZCcsIFtyZXNwb25zZSwgYXBpXSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbi1lbmRcbiAgICAgICAgICAgICAgICBpZiAoY2IuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmVuZC5hcHBseShzY29wZSwgW3Jlc3BvbnNlLCBhcGksIHRyYW5zQXJnc10pOyBcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBpbztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmxhdHRlbnMgYSBnaXZlbiA8Y29kZT5SZXZvbHV0aW9uLlJEYXRhPC9jb2RlPiB0eXBlIGludG8gYSBKU09OXG4gICAgICAgICAqIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV4cGVjdGVkIERlcGxveVIgaW5wdXQgZm9ybWF0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHBhcnNlSW5wdXRzXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcmRhdGEgQW4gQXJyYXkgb2YgUkRhdGEgT2JqZWN0cyB0byBiZSBmbGF0dGVuZWQuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZsYXR0ZW5kIFJEYXRhIEpTT04gc3RyaW5nIHJlcHJlc2VudGluZyB0aGVcbiAgICAgICAgICogRGVwbG95UiBpbnB1dCBmb3JtYXQuXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZUlucHV0czogZnVuY3Rpb24ocmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiByZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vIFByb2plY3QgV29ya3NwYWNlIEFQSXNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGxpc3RzIHRoZSBvYmplY3RzIGluIHRoZSB3b3Jrc3BhY2UgZm9yIHRoZSBwcm9qZWN0IGluZGljYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0V29ya3NwYWNlTGlzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cm9vdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBvYmplY3QgZ3JhcGggcm9vdDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5jbGF6ejwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBSIGNsYXNzIGJhc2VkIGZpbHRlcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWx0ZXI8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgUiBvYmplY3QgbmFtZSBiYXNlZCBmaWx0ZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cmVzdHJpY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZSwgbGltaXRzIHJldHVybmVkIG9iamVjdHMgdG8gb2JqZWN0XG4gICAgICAgICAqICAgICAgIHR5cGVzIHdpdGggc3VwcG9ydGVkIFJldm9EZXBsb3lSLWVuY29kaW5nXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wYWdlc2l6ZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHBhZ2Ugc2l6ZSBmb3IgcGFnaW5nIHJlc3VsdHMgaW4gcmVzcG9uc2VcbiAgICAgICAgICogICAgICAgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wYWdlb2Zmc2V0PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgcGFnZSBvZmZzZXQgZm9yIHBhZ2luZyByZXN1bHRzIGluIHJlc3BvbnNlXG4gICAgICAgICAqICAgICAgIG1hcmt1cFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RXb3Jrc3BhY2VMaXN0OiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC93b3Jrc3BhY2UvbGlzdCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgcmV0cmlldmVzIFJldm9EZXBsb3lSLWVuY29kZWQgb2JqZWN0cyBmcm9tIHRoZSB3b3Jrc3BhY2UgZm9yIHRoZVxuICAgICAgICAgKiBzcGVjaWZpZWQgcHJvamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0V29ya3NwYWNlR2V0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5uYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG9iamVjdCBuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5yb290PC9kdD5cbiAgICAgICAgICogICAgPGRkPm9wdGlvbmFsKSBzcGVjaWZpZXMgb2JqZWN0IGdyYXBoIHJvb3Q8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c3RhcnQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+b3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgb2Zmc2V0IGludG8gb2JqZWN0IGRhdGE8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+bGVuZ3RoPC9kdD5cbiAgICAgICAgICogICAgPGRkPm9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHNlZ21lbnQgb2Ygb2JqZWN0IGRhdGEgdG8gcmV0cmlldmU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5pbmZpbml0eTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgYSBjdXN0b20gdmFsdWUgZm9yIEluZmluaXR5IGFwcGVhcmluZyBpbiBSXG4gICAgICAgICAqICAgICAgIG9iamVjdCBkYXRhIHJldHVybmVkIG9uIHRoZSBjYWxsLCBvdGhlcndpc2UgSW5maW5pdHkgaXMgcmVwcmVzZW50ZWRcbiAgICAgICAgICogICAgICAgYnkgMHg3ZmYwMDAwMDAwMDAwMDAwTFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5uYW48L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgc3BlY2lmaWVzIGN1c3RvbSB2YWx1ZSBmb3IgTmFOIGFwcGVhcmluZyBpbiBSIG9iamVjdCBkYXRhXG4gICAgICAgICAqICAgICAgIHJldHVybmVkIG9uIHRoZSBjYWxsLCBvdGhlcndpc2UgTmFOIGlzIHJlcHJlc2VudGVkIGJ5IG51bGxcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmVuY29kZURhdGFGcmFtZVByaW1pdGl2ZUFzVmVjdG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBkYXRhLmZyYW1lIHByaW1pdGl2ZXMgYXJlIGVuY29kZWRcbiAgICAgICAgICogICAgICAgdmVjdG9ycyBpbiBSIG9iamVjdCBkYXRhIHJldHVybmVkIG9uIGNhbGxcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0V29ya3NwYWNlR2V0OiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC93b3Jrc3BhY2UvZ2V0JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCB1cGxvYWRzIGEgYmluYXJ5IG9iamVjdCBmcm9tIGZpbGUgaW50byB0aGUgd29ya3NwYWNlIGZvciB0aGVcbiAgICAgICAgICogc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdFdvcmtzcGFjZVVwbG9hZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+bmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIG9iamVjdCBmaWxlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmZpbGU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+ZmlsZSBjb250ZW50PC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0V29ya3NwYWNlVXBsb2FkOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25maWcuZm9ybWF0ID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICB2YXIgaW9Db25maWcgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogY29uZmlnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgZm9ybToge1xuICAgICAgICAgICAgICAgICAgICBpZDogY29uZmlnLmZvcm1JZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IGNhbGxiYWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3Qvd29ya3NwYWNlL3VwbG9hZCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgdHJhbnNmZXJzIGEgYmluYXJ5IG9iamVjdCBmcm9tIGEgVVJMIGludG8gdGhlIHdvcmtzcGFjZSBmb3IgdGhlXG4gICAgICAgICAqIHNwZWNpZmllZCBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RXb3Jrc3BhY2VUcmFuc2ZlclxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+bmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIG9iamVjdCBmaWxlIGZvdW5kIG9uIHRoZSBVUkw8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dXJsPC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgVVJMPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0V29ya3NwYWNlVHJhbnNmZXI6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L3dvcmtzcGFjZS90cmFuc2ZlcicsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgcHVzaGVzIGEgUmV2b0RlcGxveVItZW5jb2RlZCBvYmplY3QgaW50byB0aGUgd29ya3NwYWNlIGZvciB0aGVcbiAgICAgICAgICogc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdFdvcmtzcGFjZVB1c2hcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmlucHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIFJldm9EZXBsb3lSLWVuY29kZWQgb2JqZWN0IGlucHV0czwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5jc3ZpbnB1dHM8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBwcmltaXRpdmUgbmFtZS92YWx1ZSBpbnB1dHM8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RXb3Jrc3BhY2VQdXNoOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC93b3Jrc3BhY2UvcHVzaCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgc2F2ZXMgdGhlIHdvcmtzcGFjZSB0byBhIGZpbGUgaW4gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGZvciB0aGVcbiAgICAgICAgICogc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBuYW1lIHBhcmFtZXRlciBpcyBzcGVjaWZpZWQgb24gdGhlIGNhbGwgdGhlbiBvbmx5IHRoZSBuYW1lZCBvYmplY3RcbiAgICAgICAgICogaXMgc2F2ZWQgYXMgYSBiaW5hcnkgb2JqZWN0IGZpbGUgdG8gdGhlIHdvcmtpbmcgZGlyZWN0b3J5LiBPdGhlcndpc2UgdGhlXG4gICAgICAgICAqIGVudGlyZSBjb250ZW50cyBvZiB0aGUgd29ya3NwYWNlIGFyZSBzYXZlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0V29ya3NwYWNlU2F2ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+bmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBhIG5hbWVkIG9iamVjdCBmb3Igc2F2aW5nPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRlc2NyPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIGEgZGVzY3JpcHRpb24gdG8gYWNjb21wYW55IHRoZSBzYXZlZCBmaWxlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIG5ldyBmaWxlIHdpbGwgYmUgcmVuYW1lZCB0byBhdm9pZFxuICAgICAgICAgKiAgICAgICBvdmVyd3JpdGluZ1xuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RXb3Jrc3BhY2VTYXZlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC93b3Jrc3BhY2Uvc2F2ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgc3RvcmVzIHRoZSB3b3Jrc3BhY2UgYXMgYSBiaW5hcnkgb2JqZWN0IHRvIHRoZSByZXBvc2l0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgbmFtZSBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkIG9uIHRoZSBjYWxsLCB0aGVuIG9ubHkgdGhlIG5hbWVkIG9iamVjdFxuICAgICAgICAgKiBpcyBzdG9yZWQgYXMgYSBiaW5hcnkgb2JqZWN0IGluIHRoZSByZXBvc2l0b3J5LiBPdGhlcndpc2UgdGhlIGVudGlyZVxuICAgICAgICAgKiBjb250ZW50cyBvZiB0aGUgd29ya3NwYWNlIGFyZSBzdG9yZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdFdvcmtzcGFjZVN0b3JlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0Pm5hbWU8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBhIG5hbWVkIG9iamVjdCBmb3Igc3RvcmluZzwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmRlc2NyPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgYSBkZXNjcmlwdGlvbiB0byBhY2NvbXBhbnkgdGhlIHNhdmVkIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dGFnczwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGFnIHdvcmRzIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSByZXBvc2l0b3J5IGZpbGVcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJlc3RyaWN0ZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygcm9sZSBuYW1lcywgd2hpY2ggbWFrZXMgdGhlIGZpbGVcbiAgICAgICAgICogICAgICAgdmlzaWJsZSB0byBhdXRoZW50aWNhdGVkIHVzZXJzIHdpdGggdGhlc2Ugcm9sZXNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnNoYXJlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgdGhlIGZpbGUgd2lsbCBiZSBzaGFyZWQsIHdoaWNoXG4gICAgICAgICAqICAgICAgIG1ha2VzIHRoZSBmaWxlIHZpc2libGUgdG8gYXV0aGVudGljYXRlZCB1c2Vyc1xuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHVibGlzaGVkPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCB0aGUgZmlsZSB3aWxsIGJlIHB1Ymxpc2hlZCwgd2hpY2hcbiAgICAgICAgICogICAgICAgbWFrZXMgdGhlIGZpbGUgdmlzaWJsZSB0byBhdXRoZW50aWNhdGVkIGFuZCBhbm9ueW1vdXMgdXNlcnNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+bmV3dmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCB0aGUgbmV3IGZpbGUgd2lsbCBiZSByZW5hbWVkIHRvXG4gICAgICAgICAqICAgICAgIGF2b2lkIG92ZXJ3cml0aW5nXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqICA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RXb3Jrc3BhY2VTdG9yZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3Qvd29ya3NwYWNlL3N0b3JlJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBsb2FkcyBhIGJpbmFyeSBvYmplY3QgZnJvbSBhIGZpbGUgaW4gdGhlIHJlcG9zaXRvcnkgaW50byB0aGVcbiAgICAgICAgICogd29ya3NwYWNlIGZvciB0aGUgc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdFdvcmtzcGFjZUxvYWRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJlcG88L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IG5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPnNwZWNpZmllcyB0aGUgcmVwb3NpdG9yeSBmaWxlIG5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+YXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcmVwb3NpdG9yeSBmaWxlIGF1dGhvcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PnZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgcmVwb3NpdG9yeSBmaWxlIHZlcnNpb248L2RkPlxuICAgICAgICAgKiAgPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0V29ya3NwYWNlTG9hZDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3Qvd29ya3NwYWNlL2xvYWQnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGRlbGV0ZXMgYW4gb2JqZWN0IGZyb20gdGhlIHdvcmtzcGFjZSBmb3IgdGhlIHNwZWNpZmllZCBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RXb3Jrc3BhY2VEZWxldGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBvYmplY3QgbmFtZTwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdFdvcmtzcGFjZURlbGV0ZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykgeyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3Qvd29ya3NwYWNlL2RlbGV0ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gUHJvamVjdCBNYW5hZ2VtZW50IEFQSXNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgY3JlYXRlcyBhIG5ldyBwcm9qZWN0IGZvciB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlci5cbiAgICAgICAgICogSWYgdGhlIHByb2plY3RuYW1lIHBhcmFtZXRlciBpcyBzcGVjaWZpZWQgb24gdGhlIGNhbGwsIHRoZW4gdGhlIG5ld2x5XG4gICAgICAgICAqIGNyZWF0ZWQgcHJvamVjdCB3aWxsIGJlIGEgcGVyc2lzdGVudCBwcm9qZWN0IC4gSWYgdGhlIHByb2plY3RuYW1lIHBhcmFtZXRlclxuICAgICAgICAgKiBpcyBvbWl0dGVkIG9uIHRoZSBjYWxsLCB0aGVuIHRoZSBuZXdseSBjcmVhdGVkIHByb2plY3Qgd2lsbCBiZSBhIHRlbXBvcmFyeVxuICAgICAgICAgKiBwcm9qZWN0LiBUaGUgcHJvamVjdGRlc2NyIHBhcmFtZXRlciBpcyBpZ25vcmVkIGlmIHRoZSBwcm9qZWN0bmFtZSBwYXJhbWV0ZXJcbiAgICAgICAgICogaXMgb21pdHRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGJsYWNrYm94IHBhcmFtZXRlciBlbnN1cmVzIHRoYXQgY2FsbHMgb24gdGhlIHRlbXBvcmFyeSBwcm9qZWN0IGFyZVxuICAgICAgICAgKiBsaW1pdGVkIHRvIHRoZSBCbGFja2JveCBBUEkgQ29udHJvbHMgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2luZyB0aGUgaW5wdXRzICwgcHJlbG9hZGZpbGUgLCBwcmVsb2Fkb2JqZWN0IGFuZCBhZG9wdCBwYXJhbWV0ZXJzIHRoZVxuICAgICAgICAgKiBwcm9qZWN0IGNhbiBiZSBwcmUtaW5pdGlhbGl6ZWQgd2l0aCBkYXRhIGluIHRoZSB3b3Jrc3BhY2UgYW5kL29yIHdvcmtpbmdcbiAgICAgICAgICogZGlyZWN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaW5wdXRzIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBwYXNzIFJldm9EZXBsb3lSLWVuY29kZWQgUiBvYmplY3RcbiAgICAgICAgICogdmFsdWVzIGFzIGlucHV0cy4gVGhlc2UgaW5wdXRzIGFyZSB0dXJuZWQgaW50byBSIG9iamVjdHMgaW4gdGhlIHdvcmtzcGFjZVxuICAgICAgICAgKiBvZiB0aGUgbmV3IFIgc2Vzc2lvbiBiZWZvcmUgdGhlIGNhbGwgcmV0dXJucy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHByZWxvYWRmaWxlIHBhcmFtZXRlcnMgYWxsb3cgdGhlIGNhbGxlciB0byBsb2FkIG9uZSBvciBtb3JlIGZpbGVzIGZyb21cbiAgICAgICAgICogdGhlIHJlcG9zaXRvcnkgaW50byB0aGUgd29ya2luZyBkaXJlY3Rvcnkgb2YgdGhlIG5ldyBSIHNlc3Npb24gYmVmb3JlIHRoZVxuICAgICAgICAgKiBjYWxsIHJldHVybnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwcmVsb2Fkb2JqZWN0IHBhcmFtZXRlcnMgYWxsb3cgdGhlIGNhbGxlciB0byBsb2FkIG9uZSBvciBtb3JlIGJpbmFyeSBSXG4gICAgICAgICAqIG9iamVjdHMgKC5yRGF0YSkgZnJvbSB0aGUgcmVwb3NpdG9yeSBpbnRvIHRoZSB3b3Jrc3BhY2Ugb2YgdGhlIG5ldyBSXG4gICAgICAgICAqIHNlc3Npb24gYmVmb3JlIHRoZSBjYWxsIHJldHVybnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBhZG9wdCBwYXJhbWV0ZXJzIGFsbG93IHRoZSBjYWxsZXIgdG8gbG9hZCBhIHByZS1leGlzdGluZyBwcm9qZWN0XG4gICAgICAgICAqIHdvcmtzcGFjZSwgcHJvamVjdCB3b3JraW5nIGRpcmVjdG9yeSBhbmQvb3IgcHJvamVjdCBwYWNrYWdlIGRlcGVuZGVuY2llc1xuICAgICAgICAgKiBpbnRvIHRoZSBuZXcgUiBzZXNzaW9uIGJlZm9yZSB0aGUgY2FsbCByZXR1cm5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RDcmVhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0bmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIG5hbWVzIGEgbmV3IHBlcnNpc3RlbnQgcHJvamVjdDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0ZGVzY3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBkZXNjcmliZXMgYSBuZXcgcGVyc2lzdGVudCBwcm9qZWN0PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmJsYWNrYm94PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHdoZW4gZW5hYmxlZCwgYSB0ZW1wb3JhcnkgcHJvamVjdCBpcyBsaW1pdGVkIHRvIGJsYWNrYm94XG4gICAgICAgICAqICAgICAgIEFQSSBjb250cm9sc1xuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+aW5wdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgUmV2b0RlcGxveVItZW5jb2RlZCBpbnB1dHM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+Y3N2aW5wdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcHJpbWl0aXZlIG5hbWUvdmFsdWUgaW5wdXRzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRmaWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJlcG9zaXRvcnkgZmlsZW5hbWVzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRmaWxlYXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGF1dGhvcnMsXG4gICAgICAgICAqICAgICAgIGF1dGhvci1wZXItcHJlbG9hZGZpbGVuYW1lXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2FkZmlsZXZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmVyc2lvbnMsXG4gICAgICAgICAqICAgICAgIHZlcnNpb24tcGVyLXByZWxvYWRmaWxlbmFtZVxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdG5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeSBvYmplY3QgKC5yRGF0YSlcbiAgICAgICAgICogICAgICAgZmlsZW5hbWVzXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2Fkb2JqZWN0YXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGF1dGhvcnMsXG4gICAgICAgICAqICAgICAgIGF1dGhvci1wZXItcHJlbG9hZG9iamVjdG5hbWVcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRvYmplY3R2ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZlcnNpb25zLFxuICAgICAgICAgKiAgICAgICB2ZXJzaW9uLXBlci1vYmplY3QtcHJlbG9hZG9iamVjdG5hbWVcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmFkb3B0d29ya3NwYWNlPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlkZW50aWZpZXMgdGhlIHByb2plY3Qgd2hvc2Ugd29ya3NwYWNlIGlzIHRvIGJlIGFkb3B0ZWRcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmFkb3B0ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlkZW50aWZpZXMgdGhlIHByb2plY3Qgd2hvc2UgZGlyZWN0b3J5IGlzIHRvIGJlIGFkb3B0ZWRcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmFkb3B0cGFja2FnZXM8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWRlbnRpZmllcyB0aGUgcHJvamVjdCB3aG9zZSBwYWNrYWdlIGRlcGVuZGVuY2llcyBhcmUgdG9cbiAgICAgICAgICogICAgICAgYmUgYWRvcHRlZFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RDcmVhdGU6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2NyZWF0ZScsIGNvbmZpZywgY2FsbGJhY2spOyAgICAgICAgICAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgY3JlYXRlcyBhIHBvb2wgb2YgdGVtcG9yYXJ5IHByb2plY3RzIGZvciB0aGUgY3VycmVudGx5XG4gICAgICAgICAqIGF1dGhlbnRpY2F0ZWQgdXNlci4gVGhlIGNhbGxlciBjYW4gc3BlY2lmeSB0aGVpciBwcmVmZXJyZWQgbnVtYmVyIG9mXG4gICAgICAgICAqIHByb2plY3RzIHRvIGNyZWF0ZSB1c2luZyB0aGUgcG9vbHNpemUgcGFyYW1ldGVyLiBSZXZvRGVwbG95UiB3aWxsIGF0dGVtcHRcbiAgICAgICAgICogdG8gY3JlYXRlIHVwIHRvIHBvb2xzaXplIG51bWJlciBvZiBwcm9qZWN0cy4gSG93ZXZlciwgc3RhbmRhcmQgY29tXG4gICAgICAgICAqIHBvbGljeSBjb250cmFpbnRzIGFwcGx5IHRvIGluZGl2aWR1YWwgdXNlcnMgYW5kIG9uIHRoZSBncmlkIHNvIHRoZXJlIGlzIG5vXG4gICAgICAgICAqIGd1YXJhbnRlZSB0aGF0IHBvb2xzaXplIHByb2plY3RzIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgICogcHJvamVjdHMgcmV0dXJuZWQgb24gdGhpcyBjYWxsIGlzIGxlc3MgdGhhbiBwb29sc2l6ZSB0aGUgY2FsbGVyIGNhbiBpbnNwZWN0XG4gICAgICAgICAqIHRoZSBlcnJvciBhbmQgZXJyb3JDb2RlIHByb3BlcnRpZXMgaW4gdGhlIHJlc3BvbnNlIG1hcmt1cCB0byBkZXRlcm1pbmVcbiAgICAgICAgICogZXhhY3RseSB3aHkgdGhlaXIgcG9vbCBzaXplIHdhcyBsaW1pdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYmxhY2tib3ggcGFyYW1ldGVyIGVuc3VyZXMgdGhhdCBjYWxscyBvbiBlYWNoIHByb2plY3QgaW4gdGhlIHBvb2wgYXJlXG4gICAgICAgICAqIGxpbWl0ZWQgdG8gdGhlIEJsYWNrYm94IEFQSSBDb250cm9scyAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzaW5nIHRoZSBpbnB1dHMsIHByZWxvYWRmaWxlLCBwcmVsb2Fkb2JqZWN0IGFuZCBhZG9wdCBwYXJhbWV0ZXJzIGVhY2hcbiAgICAgICAgICogcHJvamVjdCBpbiB0aGUgcG9vbCBjYW4gYmUgcHJlLWluaXRpYWxpemVkIHdpdGggZGF0YSBpbiB0aGUgd29ya3NwYWNlXG4gICAgICAgICAqIGFuZC9vciB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGlucHV0cyBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gcGFzcyBSZXZvRGVwbG95Ui1lbmNvZGVkIFIgb2JqZWN0XG4gICAgICAgICAqIHZhbHVlcyBhcyBpbnB1dHMuIFRoZXNlIGlucHV0cyBhcmUgdHVybmVkIGludG8gUiBvYmplY3RzIGluIHRoZSB3b3Jrc3BhY2VcbiAgICAgICAgICogb2YgdGhlIG5ldyBSIHNlc3Npb24gYmVmb3JlIHRoZSBjYWxsIHJldHVybnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwcmVsb2FkZmlsZSBwYXJhbWV0ZXJzIGFsbG93IHRoZSBjYWxsZXIgdG8gbG9hZCBvbmUgb3IgbW9yZSBmaWxlcyBmcm9tXG4gICAgICAgICAqIHRoZSByZXBvc2l0b3J5IGludG8gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHRoZSBuZXcgUiBzZXNzaW9uIGJlZm9yZSB0aGVcbiAgICAgICAgICogY2FsbCByZXR1cm5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcHJlbG9hZG9iamVjdCBwYXJhbWV0ZXJzIGFsbG93IHRoZSBjYWxsZXIgdG8gbG9hZCBvbmUgb3IgbW9yZSBiaW5hcnkgUlxuICAgICAgICAgKiBvYmplY3RzICguckRhdGEpIGZyb20gdGhlIHJlcG9zaXRvcnkgaW50byB0aGUgd29ya3NwYWNlIG9mIHRoZSBuZXcgUlxuICAgICAgICAgKiBzZXNzaW9uIGJlZm9yZSB0aGUgY2FsbCByZXR1cm5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYWRvcHQgcGFyYW1ldGVycyBhbGxvdyB0aGUgY2FsbGVyIHRvIGxvYWQgYSBwcmUtZXhpc3RpbmcgcHJvamVjdFxuICAgICAgICAgKiB3b3Jrc3BhY2UsIHByb2plY3Qgd29ya2luZyBkaXJlY3RvcnkgYW5kL29yIHByb2plY3QgcGFja2FnZSBkZXBlbmRlbmNpZXNcbiAgICAgICAgICogaW50byB0aGUgbmV3IFIgc2Vzc2lvbiBiZWZvcmUgdGhlIGNhbGwgcmV0dXJucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0UG9vbFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnBvb2xzaXplPC9kdD5cbiAgICAgICAgICogICAgPGRkPnRoZSBwcmVmZXJyZWQgc2l6ZSBvZiB0aGUgcG9vbCBvZiB0ZW1wb3JhcnkgcHJvamVjdHM8L2RkPlxuICAgICAgICAgKiAgICA8ZHQ+YmxhY2tib3g8L2RkPlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSB3aGVuIGVuYWJsZWQsIGVhY2ggdGVtcG9yYXJ5IHByb2plY3QgaW4gdGhlIHBvb2wgaXMgbGltaXRlZCB0byBibGFja2JveCBBUEkgY29udHJvbHM8L2RkPlxuICAgICAgICAgKiAgICA8ZHQ+aW5wdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgUmV2b0RlcGxveVItZW5jb2RlZCBpbnB1dHM8L2RkPlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZGZpbGVuYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeSBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZGZpbGVhdXRob3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhdXRob3JzLCBhdXRob3ItcGVyLXByZWxvYWRmaWxlbmFtZTwvZGQ+XG4gICAgICAgICAqICAgIDxkdD5wcmVsb2FkZmlsZXZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2ZXJzaW9ucywgdmVyc2lvbi1wZXItcHJlbG9hZGZpbGVuYW1lPC9kZD5cbiAgICAgICAgICogICAgPGR0PnByZWxvYWRvYmplY3RuYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeSBvYmplY3QgKC5yRGF0YSkgZmlsZW5hbWVzPC9kZD5cbiAgICAgICAgICogICAgPGR0PnByZWxvYWRvYmplY3RhdXRob3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhdXRob3JzLCBhdXRob3ItcGVyLXByZWxvYWRvYmplY3RuYW1lPC9kZD5cbiAgICAgICAgICogICAgPGR0PnByZWxvYWRvYmplY3R2ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmVyc2lvbnMsIHZlcnNpb24tcGVyLW9iamVjdC1wcmVsb2Fkb2JqZWN0bmFtZTwvZGQ+XG4gICAgICAgICAqICAgIDxkdD5hZG9wdHdvcmtzcGFjZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlkZW50aWZpZXMgcHJvamVjdCBmcm9tIHdoaWNoIHdvcmtzcGFjZSBpcyB0byBiZSBhZG9wdGVkPC9kZD5cbiAgICAgICAgICogICAgPGR0PmFkb3B0ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWRlbnRpZmllcyBwcm9qZWN0IGZyb20gd2hpY2ggZGlyZWN0b3J5IGlzIHRvIGJlIGFkb3B0ZWQ8L2RkPlxuICAgICAgICAgKiAgICA8ZHQ+YWRvcHRwYWNrYWdlczwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlkZW50aWZpZXMgcHJvamVjdCBmcm9tIHdoaWNoIHBhY2thZ2UgZGVwZW5kZW5jaWVzIGFyZSB0byBiZSBhZG9wdGVkPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0UG9vbDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvcG9vbCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgcmVjeWNsZXMgdGhlIFIgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHByb2plY3QgYnkgZGVsZXRpbmdcbiAgICAgICAgICogYWxsIFIgb2JqZWN0cyBmcm9tIHRoZSB3b3Jrc3BhY2UgYW5kIGFsbCBmaWxlcyBmcm9tIHRoZSB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogUmVjeWNsaW5nIGEgcHJvamVjdCBpcyBhIGNvbnZlbmllbnQgYW5kIGVmZmljaWVudCBhbHRlcm5hdGl2ZSB0byBzdGFydGluZ1xuICAgICAgICAgKiBvdmVyIGJ5IGNsb3NpbmcgYW4gZXhpc3RpbmcgcHJvamVjdCBhbmQgdGhlbiBjcmVhdGluZyBhIG5ldyBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RSZWN5Y2xlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICogICAgPGR0PnByZXNlcnZld29ya3NwYWNlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIG9iamVjdHMgaW4gdGhlIHdvcmtzcGFjZSBhcmUgcHJlc2VydmVkIG9uIHJlY3ljbGU8L2RkPlxuICAgICAgICAgKiAgICA8ZHQ+cHJlc2VydmVkaXJlY3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgZmlsZXMgaW4gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGFyZSBwcmVzZXJ2ZWQgb24gcmVjeWNsZTwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdFJlY3ljbGU6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L3JlY3ljbGUnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGxpc3RzIGFsbCBwcm9qZWN0cyBvd25lZCBieSB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlclxuICAgICAgICAgKiBhbmQvb3IgYWxsIHByb2plY3RzIHNoYXJlZCBieSBvdGhlciB1c2Vycy5cbiAgICAgICAgICpcbiAgICAgICAgICogU2hhcmVkIHByb2plY3RzIGFyZSBhdmFpbGFibGUgYXMgcmVhZC1vbmx5IHByb2plY3RzIHRvIHRoZSBjYWxsZXIuIFRoZVxuICAgICAgICAgKiBzaGFyZWQgb3IgcHJpdmF0ZSBuYXR1cmUgb2YgYSBwcm9qZWN0IGNhbiBiZSBjb250cm9sbGVkIHVzaW5nIHRoZVxuICAgICAgICAgKiA8Y29kZT4vci9wcm9qZWN0L2Fib3V0L3VwZGF0ZTwvY29kZT4gY2FsbFxuICAgICAgICAgKiA8YSBocmVmPVwiI21ldGhvZF9wcm9qZWN0QWJvdXRVcGRhdGVcIj5wcm9qZWN0QWJvdXRVcGRhdGU8L2E+LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RMaXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+c2hhcmVkcHJvamVjdHNhbHNvPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHdoZW4gdHJ1ZSwgdGhlIHByb2plY3QgcmVzcG9uc2UgbGlzdCBjb250YWlucyB0aGUgY2FsbGVyJ3NcbiAgICAgICAgICogICAgICAgcHJvamVjdHMgcGx1cyBwcm9qZWN0cyBzaGFyZWQgYnkgb3RoZXIgdXNlcnNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnNoYXJlZHByb2plY3Rzb25seTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSB3aGVuIHRydWUsIHRoZSBwcm9qZWN0IHJlc3BvbnNlIGxpc3QgY29udGFpbnMgb25seVxuICAgICAgICAgKiAgICAgICBwcm9qZWN0cyBzaGFyZWQgYnkgb3RoZXIgdXNlcnMgYW5kIG5vdCB0aGUgdXNlcnMncyBvd24gcHJvamVjdHNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pmlzb3JkZXJlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSB3aGVuIHRydWUsIHRoZSBwcm9qZWN0IHJlc3BvbnNlIGxpc3QgaXMgb3JkZXJlZCBpbiBhXG4gICAgICAgICAqICAgICAgIG1vc3QtcmVjZW50bHktbW9kaWZpZWQgZmlyc3Qgb3JkZXIuIE90aGVyd2lzZSB0aGUgbGlzdCBpcyBvcmRlcmVkXG4gICAgICAgICAqICAgICAgIGNocm9ub2xvZ2ljYWxseSBieSBjcmVhdGlvbiBkYXRlXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdExpc3Q6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2xpc3QnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBwaW5ncyB0aGUgc3BlY2lmaWVkIHByb2plY3QgdG8gZGV0ZXJtaW5lIGlmIHRoZSBwcm9qZWN0IGlzIGxpdmVcbiAgICAgICAgICogb24gdGhlIFJldm9EZXBsb3lSIGdyaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdFBpbmdcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiAgPGRsPlxuICAgICAgICAgKiAgICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKiAgPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0UGluZzogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvcGluZycsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgcmV0cmlldmVzIGEgc2V0IG9mIHByb3BlcnRpZXMgdGhhdCBkZXNjcmliZSB0aGUgc3BlY2lmaWVkXG4gICAgICAgICAqIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdEFib3V0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdEFib3V0OiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9hYm91dCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgdXBkYXRlcyBhIHNldCBvZiBwcm9wZXJ0aWVzIHRoYXQgZGVzY3JpYmUgdGhlIHNwZWNpZmllZCBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RBYm91dFVwZGF0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+bmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXNjcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgcHJvamVjdCBkZXNjcmlwdGlvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5sb25nZGVzY3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHByb2plY3QgbG9uZyBkZXNjcmlwdGlvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zaGFyZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIHNwZWNpZmllcyB0aGF0IHRoZSBwcm9qZWN0IGlzIGFcbiAgICAgICAgICogICAgICAgc2hhcmVkIHByb2plY3RcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByb2plY3Rjb29raWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgc3BlY2lmaWVzIGEgY2xpZW50LWFwcGxpY2F0aW9uIHNwZWNpZmljIHByb2plY3QgY29va2llXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqICA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RBYm91dFVwZGF0ZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvYWJvdXQvdXBkYXRlJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBzYXZlcyB0aGUgcGVyc2lzdGVudCBzdGF0ZSBvZiB0aGUgcHJvamVjdCBpbmRpY2F0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzZXQgb2YgZHJvcCBwYXJhbWV0ZXJzIGFsbG93cyB0aGUgY2FsbGVyIHRvIHNlbGVjdGl2ZWx5IGRyb3AgYXNwZWN0cyxcbiAgICAgICAgICogc3VjaCBhcyB3b3Jrc3BhY2UsIHdvcmtpbmcgZGlyZWN0b3J5LCBvciBleGVjdXRpb24gaGlzdG9yeSBvZiB0aGUgcHJvamVjdFxuICAgICAgICAgKiBzdGF0ZSB3aGVuIHNhdmluZy4gVGhlIGZsdXNoaGlzdG9yeSBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gcHJlc2VydmVcbiAgICAgICAgICogdGhlIHByb2plY3QgZXhlY3V0aW9uIGhpc3RvcnkgaXRzZWxmIHdoaWxlIGRlc3Ryb3lpbmcgYWxsIGdlbmVyYXRlZCBjb25zb2xlXG4gICAgICAgICAqIG91dHB1dCBhbmQgcmVzdWx0cyBhc3NvY2lhdGVkIHdpdGggdGhhdCBoaXN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RTYXZlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHByb2plY3QgbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXNjcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgcHJvamVjdCBkZXNjcmlwdGlvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5sb25nZGVzY3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHByb2plY3QgbG9uZyBkZXNjcmlwdGlvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zaGFyZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCBzcGVjaWZpZXMgdGhlIHByb2plY3QgaXMgYSBzaGFyZWQgcHJvamVjdDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0Y29va2llPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIGEgY2xpZW50LWFwcGxpY2F0aW9uIHNwZWNpZmljIHByb2plY3QgY29va2llPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRyb3B3b3Jrc3BhY2U8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgY29udGVudCBvZiB0aGUgcHJvamVjdCdzIHdvcmtzcGFjZSBpcyBkcm9wcGVkIG9uIHNhdmU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZHJvcGRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBjb250ZW50IG9mIHRoZSBwcm9qZWN0J3Mgd29ya2luZyBkaXJlY3RvcnkgaXMgZHJvcHBlZCBvbiBzYXZlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRyb3BoaXN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIHByb2plY3QncyBleGVjdXRpb24gaGlzdG9yeSBpcyBkcm9wcGVkIG9uIHNhdmU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+Zmx1c2hoaXN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIHByb2plY3QncyBleGVjdXRpb24gaGlzdG9yeSBpcyBmbHVzaGVkIG9uIHNhdmU8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RTYXZlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9zYXZlJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBzYXZlcyB0aGUgcGVyc2lzdGVudCBzdGF0ZSBvZiB0aGUgc3BlY2lmaWVkIHByb2plY3QgdG8gYSBuZXdcbiAgICAgICAgICogcGVyc2lzdGVudCBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgc2V0IG9mIGRyb3AgcGFyYW1ldGVycyBhbGxvd3MgdGhlIGNhbGxlciB0byBzZWxlY3RpdmVseSBkcm9wIGFzcGVjdHMsXG4gICAgICAgICAqIHN1Y2ggYXMgd29ya3NwYWNlLCB3b3JraW5nIGRpcmVjdG9yeSwgb3IgZXhlY3V0aW9uIGhpc3Rvcnkgb2YgdGhlIHByb2plY3RcbiAgICAgICAgICogc3RhdGUgd2hlbiBzYXZpbmcgdG8gdGhlIG5ldyBwcm9qZWN0LiBUaGUgZmx1c2hoaXN0b3J5IHBhcmFtZXRlciBhbGxvd3MgdGhlXG4gICAgICAgICAqIGNhbGxlciB0byBwcmVzZXJ2ZSB0aGUgcHJvamVjdCBleGVjdXRpb24gaGlzdG9yeSBpdHNlbGYgZm9yIHRoZSBuZXcgcHJvamVjdFxuICAgICAgICAgKiB3aGlsZSBkcm9wcGluZyBhbGwgZ2VuZXJhdGVkIGNvbnNvbGUgb3V0cHV0IGFuZCByZXN1bHRzIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgICAgICogb3JpZ2luYWwgaGlzdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0U2F2ZWFzXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBuZXcgcHJvamVjdCBuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRlc2NyPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBuZXcgcHJvamVjdCBkZXNjcmlwdGlvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5sb25nZGVzY3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIG5ldyBwcm9qZWN0IGxvbmcgZGVzY3JpcHRpb248L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c2hhcmVkPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgc3BlY2lmaWVzIHRoZSBuZXcgcHJvamVjdCBpcyBhIHNoYXJlZCBwcm9qZWN0PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByb2plY3Rjb29raWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgYSBjbGllbnQtYXBwbGljYXRpb24gc3BlY2lmaWMgY29va2llIGZvciB0aGUgbmV3IHByb2plY3Q8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZHJvcHdvcmtzcGFjZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBjb250ZW50IG9mIHRoZSBvcmlnaW5hbCBwcm9qZWN0J3Mgd29ya3NwYWNlIGlzIGRyb3BwZWQgd2hlbiBzYXZpbmcgdG8gdGhlIG5ldyBwcm9qZWN0PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRyb3BkaXJlY3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgY29udGVudCBvZiB0aGUgcHJvamVjdCdzIHdvcmtpbmcgZGlyZWN0b3J5IGlzIGRyb3BwZWQgd2hlbiBzYXZpbmcgdG8gdGhlIG5ldyBwcm9qZWN0PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRyb3BoaXN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIHByb2plY3QncyBleGVjdXRpb24gaGlzdG9yeSBpcyBkcm9wcGVkIHdoZW4gc2F2aW5nIHRvIHRoZSBuZXcgcHJvamVjdDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5mbHVzaGhpc3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgcHJvamVjdCdzIGV4ZWN1dGlvbiBoaXN0b3J5IGlzIGZsdXNoZWQgd2hlbiBzYXZpbmcgdG8gdGhlIG5ldyBwcm9qZWN0PC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0U2F2ZWFzOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9zYXZlYXMnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGNsb3NlcyB0aGUgcHJvamVjdCBpbmRpY2F0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIENsb3NpbmcgYSBsaXZlIHByb2plY3QgcmVsZWFzZXMgYWxsIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHByb2plY3RcbiAgICAgICAgICogb24gdGhlIFJldm9EZXBsb3lSIGdyaWQuIElmIHRoZSBzcGVjaWZpZWQgcHJvamVjdCBpcyBhIHBlcnNpc3RlbnQgcHJvamVjdFxuICAgICAgICAgKiB0aGVuIHRoZSBkZWZhdWx0IGF1dG9zYXZlIHNlbWFudGljcyB3aWxsIGNhdXNlIHRoZSBwcm9qZWN0IHRvIGJlIHNhdmVkXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkuIFRoZSBjYWxsZXIgY2FuIG92ZXJyaWRlIHRoYXQgZGVmYXVsdCBiZWhhdmlvciB1c2luZyB0aGVcbiAgICAgICAgICogZGlzYWJsZWF1dG9zYXZlIHBhcmFtZXRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHNldCBvZiBkcm9wIHBhcmFtZXRlcnMgYWxsb3cgdGhlIGNhbGxlciB0byBzZWxlY3RpdmVseSBkcm9wIGFzcGVjdHMsXG4gICAgICAgICAqIHN1Y2ggYXMgd29ya3NwYWNlLCB3b3JraW5nIGRpcmVjdG9yeSwgb3IgZXhlY3V0aW9uIGhpc3RvcnksIG9mIHRoZSBwcm9qZWN0XG4gICAgICAgICAqIHN0YXRlIHdoZW4gY2xvc2luZy4gVGhlIGZsdXNoaGlzdG9yeSBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG9cbiAgICAgICAgICogcHJlc2VydmUgdGhlIHByb2plY3QgZXhlY3V0aW9uIGhpc3RvcnkgaXRzZWxmIHdoaWxlIGRlc3Ryb3lpbmcgYWxsXG4gICAgICAgICAqIGdlbmVyYXRlZCBjb25zb2xlIG91dHB1dCBhbmQgcmVzdWx0cyBhc3NvY2lhdGVkIHdpdGggdGhhdCBoaXN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RDbG9zZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kaXNhYmxlYXV0b3NhdmU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgZGVmYXVsdCBhdXRvc2F2ZSBzZW1hbnRpY3MgZm9yIHBlcnNpc3RlbnQgcHJvamVjdHMgYXJlIGRpc2FibGVkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByb2plY3Rjb29raWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgYSBjbGllbnQtYXBwbGljYXRpb24gc3BlY2lmaWMgcHJvamVjdCBjb29raWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZHJvcHdvcmtzcGFjZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBjb250ZW50IG9mIHRoZSBwcm9qZWN0J3Mgd29ya3NwYWNlIGlzIGRyb3BwZWQgb24gY2xvc2U8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZHJvcGRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBjb250ZW50IG9mIHRoZSBwcm9qZWN0J3Mgd29ya2luZyBkaXJlY3RvcnkgaXMgZHJvcHBlZCBvbiBjbG9zZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kcm9waGlzdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBwcm9qZWN0J3MgZXhlY3V0aW9uIGhpc3RvcnkgaXMgZHJvcHBlZCBvbiBjbG9zZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5mbHVzaGhpc3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgcHJvamVjdCdzIGV4ZWN1dGlvbiBoaXN0b3J5IGlzIGZsdXNoZWQgb24gY2xvc2U8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RDbG9zZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvY2xvc2UnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGdyYW50cyBhdXRob3JzaGlwIG9mIHRoZSBzcGVjaWZpZWQgcHJvamVjdCB0byBvdGhlciB1c2Vycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0R3JhbnRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5ld2F1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgc3BlY2lmaWVzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdXNlcm5hbWVzIGluZGljYXRpbmcgdGhlIG5ld1xuICAgICAgICAgKiAgICAgICBvd25lcnNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0R3JhbnQ6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2dyYW50JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBpbXBvcnRzIHRoZSBzcGVjaWZpZWQgcHJvamVjdCBhcmNoaXZlIGFzIGEgbmV3IHBlcnNpc3RlbnRcbiAgICAgICAgICogcHJvamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0SW1wb3J0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+bmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIHByb2plY3QgYXJjaGl2ZSBmaWxlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmZpbGU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+Li4uZmlsZSBjb250ZW50Li4uPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRlc2NyPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyBhIGRlc2NyaXB0aW9uIGZvciB0aGUgbmV3bHkgaW1wb3J0ZWQgcHJvamVjdFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RJbXBvcnQ6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbmZpZy5mb3JtYXQgPSBcInRleHRcIjtcbiAgICAgICAgICAgIHZhciBpb0NvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjb25maWcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb25maWcuZm9ybUlkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjogY2FsbGJhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9pbXBvcnQnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBleHBvcnRzIGEgY29tcHJlc3NlZCBhcmNoaXZlIGZpbGUgZm9yIHRoZSBzcGVjaWZpZWQgcHJvamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHNldCBvZiBkcm9wIHBhcmFtZXRlcnMgYWxsb3cgdGhlIGNhbGxlciB0byBzZWxlY3RpdmVseSBkcm9wIGFzcGVjdHMsXG4gICAgICAgICAqIHN1Y2ggYXMgd29ya3NwYWNlLCB3b3JraW5nIGRpcmVjdG9yeSwgb3IgZXhlY3V0aW9uIGhpc3Rvcnkgb2YgdGhlIHByb2plY3RcbiAgICAgICAgICogc3RhdGUgd2hlbiBnZW5lcmF0aW5nIHRoZSBhcmNoaXZlLiBUaGUgZmx1c2hoaXN0b3J5IHBhcmFtZXRlciBhbGxvd3MgdGhlXG4gICAgICAgICAqIGNhbGxlciB0byBwcmVzZXJ2ZSB0aGUgcHJvamVjdCBleGVjdXRpb24gaGlzdG9yeSBpdHNlbGYgd2hpbGUgZXhjbHVkaW5nIGFsbFxuICAgICAgICAgKiBnZW5lcmF0ZWQgY29uc29sZSBvdXRwdXQgYW5kIHJlc3VsdHMgYXNzb2NpYXRlZCB3aXRoIHRoYXQgaGlzdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0RXhwb3J0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRyb3B3b3Jrc3BhY2U8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgY29udGVudCBvZiB0aGUgcHJvamVjdCdzIHdvcmtzcGFjZSBpcyBkcm9wcGVkIG9uIGV4cG9ydDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kcm9wZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIGNvbnRlbnQgb2YgdGhlIHByb2plY3QncyB3b3JraW5nIGRpcmVjdG9yeSBpcyBkcm9wcGVkIG9uIGV4cG9ydDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kcm9waGlzdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBwcm9qZWN0J3MgZXhlY3V0aW9uIGhpc3RvcnkgaXMgZHJvcHBlZCBvbiBleHBvcnQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+Zmx1c2hoaXN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIHByb2plY3QncyBleGVjdXRpb24gaGlzdG9yeSBpcyBmbHVzaGVkIG9uIGV4cG9ydDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdEV4cG9ydDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvZXhwb3J0JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBkZWxldGVzIHRoZSBzcGVjaWZpZWQgcHJvamVjdC5cbiAgICAgICAgICogRGVsZXRpbmcgYSBwcm9qZWN0IGlzIGEgcGVybWFuZW50IG9wZXJhdGlvbiB0aGF0IGNhbm5vdCBiZSB1bmRvbmUgb3JcbiAgICAgICAgICogcmVjb3ZlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3REZWxldGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3REZWxldGU6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2RlbGV0ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gUHJvamVjdCBFeGVjdXRpb24gQVBJc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBleGVjdXRlcyBhIGJsb2NrIG9mIFIgY29kZSBvbiB0aGUgUiBzZXNzaW9uIGlkZW50aWZpZWQgYnkgdGhlXG4gICAgICAgICAqIHByb2plY3QgcGFyYW1ldGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQbGVhc2Ugbm90ZSB0aGUgZm9sbG93aW5nIHByZSBhbmQgcG9zdCBleGVjdXRpb24gcGFyYW1ldGVyczpcbiAgICAgICAgICpcbiAgICAgICAgICogPHN0cm9uZz5QcmUtZXhlY3V0aW9uIHBhcmFtZXRlcnM6PC9zdHJvbmc+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxvbD5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgaW5wdXRzIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBwYXNzIFJldm9EZXBsb3lSLWVuY29kZWRcbiAgICAgICAgICogICAgICAgUiBvYmplY3QgdmFsdWVzIGFzIGlucHV0cy4gVGhlc2UgaW5wdXRzIGFyZSB0dXJuZWQgaW50byBSIG9iamVjdHNcbiAgICAgICAgICogICAgICAgaW4gdGhlIHdvcmtzcGFjZSBiZWZvcmUgdGhlIGV4ZWN1dGlvbiBiZWdpbnMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHByZWxvYWRmaWxlIHBhcmFtZXRlcnMgYWxsb3dzIHRoZSBjYWxsZXIgdG8gbG9hZCBvbmUgb3IgbW9yZVxuICAgICAgICAgKiAgICAgICBmaWxlcyBmcm9tIHRoZSByZXBvc2l0b3J5IGludG8gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGJlZm9yZSB0aGVcbiAgICAgICAgICogICAgICAgZXhlY3V0aW9uIGJlZ2lucy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgcHJlbG9hZG9iamVjdCBwYXJhbWV0ZXJzIGFsbG93IHRoZSBjYWxsZXIgdG8gbG9hZCBvbmUgb3IgbW9yZVxuICAgICAgICAgKiAgICAgICBiaW5hcnkgUiBvYmplY3RzICguckRhdGEpIGZyb20gdGhlIHJlcG9zaXRvcnkgaW50byB0aGUgd29ya3NwYWNlXG4gICAgICAgICAqICAgICAgIGJlZm9yZSB0aGUgZXhlY3V0aW9uIGJlZ2lucy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgYWRvcHQgcGFyYW1ldGVycyBhbGxvdyB0aGUgY2FsbGVyIHRvIGxvYWQgYSBwcmUtZXhpc3RpbmdcbiAgICAgICAgICogICAgICAgcHJvamVjdCB3b3Jrc3BhY2UsIHByb2plY3Qgd29ya2luZyBkaXJlY3RvcnkgYW5kL29yIHByb2plY3QgcGFja2FnZVxuICAgICAgICAgKiAgICAgICBkZXBlbmRlbmNpZXMgYmVmb3JlIHRoZSBleGVjdXRpb24gYmVnaW5zLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiA8L29sPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8c3Ryb25nPlBvc3QtZXhlY3V0aW9uIHBhcmFtZXRlcnM6PC9zdHJvbmc+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxvbD5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgcm9iamVjdHMgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHNwZWNpZnkgYSBjb21tYS1zZXBhcmF0ZWRcbiAgICAgICAgICogICAgICAgbGlzdCBvZiBvYmplY3QgbmFtZXMgdGhhdCB3aWxsIGJlIHJldHVybmVkIGFzIFJldm9EZXBsb3lSLWVuY29kZWQgUlxuICAgICAgICAgKiAgICAgICBvYmplY3RzIG9uIHRoZSByZXNwb25zZSBtYXJrdXAgYWZ0ZXIgdGhlIGV4ZWN1dGlvbiBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlZmlsZSBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgc3BlY2lmeSBhIGNvbW1hLXNlcGFyYXRlZFxuICAgICAgICAgKiAgICAgICBsaXN0IG9mIHdvcmtpbmcgZGlyZWN0b3J5IGZpbGVzIHRvIGJlIHN0b3JlZCBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlclxuICAgICAgICAgKiAgICAgICB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVvYmplY3QgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHNwZWNpZnkgYSBjb21tYS1zZXBhcmF0ZWRcbiAgICAgICAgICogICAgICAgbGlzdCBvZiB3b3Jrc3BhY2Ugb2JqZWN0cyB0byBiZSBzdG9yZWQgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGlvbiBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3Jld29ya3NwYWNlIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBzdG9yZSB0aGUgZW50aXJlXG4gICAgICAgICAqICAgICAgIHdvcmtzcGFjZSBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlciB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVkaXJlY3RvcnkgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHNwZWNpZnkgYSB0YXJnZXRcbiAgICAgICAgICogICAgICAgcmVwb3NpdG9yeSBkaXJlY3RvcnkgZm9yIHN0b3JlZCBmaWxlcyBhbmQgb2JqZWN0cyBhZnRlciB0aGUgZXhlY3V0aW9uXG4gICAgICAgICAqICAgICAgIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVuZXd2ZXJzaW9uIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBjcmVhdGUgbmV3XG4gICAgICAgICAqICAgICAgIHZlcnNpb25zIG9mIGVhY2ggc3RvcmVkIGZpbGUgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlIGV4ZWN1dGlvblxuICAgICAgICAgKiAgICAgICBjb21wbGV0ZXMuIEJ5IGRlZmF1bHQsIHN0b3JlZCBmaWxlcyBvdmVyd3JpdGUgYW55IHByZS1leGlzdGluZyBmaWxlXG4gICAgICAgICAqICAgICAgIGJ5IHRoZSBzYW1lIG5hbWUuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlcHVibGljIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBhc3NpZ24gcHVibGljIGFjY2Vzc1xuICAgICAgICAgKiAgICAgICB0byBlYWNoIHN0b3JlZCBmaWxlIGluIHRoZSByZXBvc2l0b3J5IGFmdGVyIHRoZSBleGVjdXRpb24gY29tcGxldGVzLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiA8L29sPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgPHN0cm9uZz5Tb21lIGtleSBkYXRhIGluZGljYXRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwIG9uIHRoaXMgY2FsbDo8L3N0cm9uZz5cbiAgICAgICAgICpcbiAgICAgICAgICogPG9sPlxuICAgICAgICAgKiAgICA8bGk+Y29kZSAtIGluZGljYXRlcyB0aGUgY29kZSB0aGF0IGhhcyBiZWVuIGV4ZWN1dGVkPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBjb25zb2xlIC0gaW5kaWNhdGVzIHRoZSBjb25zb2xlIG91dHB1dCByZXN1bHRpbmcgZnJvbSB0aGUgY29kZVxuICAgICAgICAgKiAgICAgICBleGVjdXRpb25cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICByZXN1bHRzIC0gaW5kaWNhdGVzIHRoZSBsaXN0IG9mIGZpbGVzIGdlbmVyYXRlZCBieSB0aGUgUiBncmFwaGljc1xuICAgICAgICAgKiAgICAgICBkZXZpY2VcbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBhcnRpZmFjdHMgLSBpbmRpY2F0ZXMgdGhlIGxpc3Qgb2YgZmlsZXMgZ2VuZXJhdGVkIG9yIG1vZGlmaWVkIGluIHRoZVxuICAgICAgICAgKiAgICAgICB3b3JraW5nIGRpcmVjdG9yeVxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIG9iamVjdHMgLSAgaW5kaWNhdGVzIHRoZSBsaXN0IG9mIFIgb2JqZWN0cyByZXR1cm5lZCBmcm9tIHRoZVxuICAgICAgICAgKiAgICAgICB3b3Jrc3BhY2VcbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBmaWxlcyAtIGluZGljYXRlcyB0aGUgbGlzdCBvZiBmaWxlcyBhbmQgb2JqZWN0cyBzdG9yZWQgaW4gdGhlXG4gICAgICAgICAqICAgICAgIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlIGV4ZWN1dGlvbiBjb21wbGV0ZXNcbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBpbnRlcnJ1cHRlZCAtIGluZGljYXRlcyB0aGUgaW50ZXJydXB0ZWQgc3RhdHVzIG9mIGV4ZWN1dGlvblxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIGVycm9yIC0gb24gZmFpbHVyZSwgaW5kaWNhdGVzIHRoZSByZWFzb24gZm9yIGZhaWx1cmVcbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBlcnJvckNvZGUgLSBvbiBmYWlsdXJlLCBpbmRpY2F0ZXMgdGhlIGVycm9yIGNvZGUgZm9yIGZhaWx1cmVcbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogPC9vbD5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0RXhlY3V0ZUNvZGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmNvZGU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBibG9jayBvZiBSIGNvZGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+aW5wdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgUmV2b0RlcGxveVItZW5jb2RlZCBzY3JpcHQgaW5wdXRzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmNzdmlucHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHByaW1pdGl2ZSBuYW1lL3ZhbHVlIGlucHV0czwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2FkZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiByZXBvc2l0b3J5IGZpbGVuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2FkZmlsZWF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGF1dGhvcnMsIGF1dGhvci1wZXItcHJlbG9hZGZpbGVuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRmaWxldmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZlcnNpb25zLCB2ZXJzaW9uLXBlci1wcmVsb2FkZmlsZW5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdG5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiByZXBvc2l0b3J5IG9iamVjdCAoLnJEYXRhKSBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdGF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGF1dGhvcnMsIGF1dGhvci1wZXItcHJlbG9hZG9iamVjdG5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdHZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2ZXJzaW9ucywgdmVyc2lvbi1wZXItb2JqZWN0LXByZWxvYWRvYmplY3RuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmFkb3B0d29ya3NwYWNlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWRlbnRpZmllcyBwcm9qZWN0IGZyb20gd2hpY2ggd29ya3NwYWNlIGlzIHRvIGJlIGFkb3B0ZWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+YWRvcHRkaXJlY3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZGVudGlmaWVzIHByb2plY3QgZnJvbSB3aGljaCBkaXJlY3RvcnkgaXMgdG8gYmUgYWRvcHRlZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5hZG9wdHBhY2thZ2VzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWRlbnRpZmllcyBwcm9qZWN0IGZyb20gd2hpY2ggcGFja2FnZSBkZXBlbmRlbmNpZXMgYXJlIHRvIGJlIGFkb3B0ZWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dGFnPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIGEgdGFnIHRoYXQgbGFiZWxzIHRoZSBleGVjdXRpb248L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZWNob29mZjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUgUiBjb21tYW5kcyB3aWxsIG5vdCBhcHBlYXIgaW4gdGhlIGNvbnNvbGUgb3V0cHV0PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmNvbnNvbGVvZmY8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlIGNvbnNvbGUgb3V0cHV0IGlzIG5vdCByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+Z3JhcGhpY3M8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBwcmVmZXJyZWQgUiBncmFwaGljcyBkZXZpY2UgZm9yIGV4ZWN1dGlvbjogcG5nIG9yIHN2ZzwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmdyYXBoaWNzd2lkdGg8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBwcmVmZXJyZWQgd2lkdGggZm9yIFIgZ3JhcGhpY3MgZGV2aWNlIGltYWdlczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmdyYXBoaWNzaGVpZ2h0PC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgcHJlZmVycmVkIGhlaWdodCBmb3IgUiBncmFwaGljcyBkZXZpY2UgaW1hZ2VzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+cm9iamVjdHM8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG9iamVjdHMgZm9yIHJldHJpZXZhbCBmb2xsb3dpbmcgdGhlIGV4ZWN1dGlvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PnN0b3JlZmlsZTwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygd29ya2luZyBkaXJlY3RvcnkgZmlsZW5hbWVzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+c3RvcmVvYmplY3Q8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHdvcmtzcGFjZSBvYmplY3QgbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5zdG9yZXdvcmtzcGFjZTwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgZmlsZW5hbWUgKC5yRGF0YSkgd2hlcmUgd29ya3NwYWNlIGNvbnRlbnRzIHdpbGwgYmUgc2F2ZWQgaW4gdGhlIHJlcG9zaXRvcnk8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5zdG9yZW5ld3ZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBlbnN1cmVzIGVhY2ggZmlsZSBzdG9yZWQgaW5cbiAgICAgICAgICogICAgcmVwb3NpdG9yeSByZXN1bHRzIGluIG5ldyB2ZXJzaW9uIGJlaW5nIGNyZWF0ZWQgaWYgbmVlZGVkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+c3RvcmVwdWJsaWM8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBwdWJsaXNoZXMgZWFjaCBmaWxlIHN0b3JlZCBpbiB0aGUgcmVwb3NpdG9yeTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmluZmluaXR5PC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgY3VzdG9tIHZhbHVlIGZvciBJbmZpbml0eSBhcHBlYXJpbmcgaW4gUiBvYmplY3RcbiAgICAgICAgICogICAgZGF0YSByZXR1cm5lZCBvbiBjYWxsLCBvdGhlcndpc2UgSW5maW5pdHkgaXMgcmVwcmVzZW50ZWQgYnkgPGNvZGU+MHg3ZmYwMDAwMDAwMDAwMDAwTDwvY29kZT5cbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+bmFuPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgY3VzdG9tIHZhbHVlIGZvciBOYU4gYXBwZWFyaW5nIGluIFIgb2JqZWN0IGRhdGFcbiAgICAgICAgICogICAgcmV0dXJuZWQgb24gY2FsbCwgb3RoZXJ3aXNlIE5hTiBpcyByZXByZXNlbnRlZCBieSA8Y29kZT5udWxsPC9jb2RlPjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmVuY29kZURhdGFGcmFtZVByaW1pdGl2ZUFzVmVjdG9yPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgZGF0YS5mcmFtZSBwcmltaXRpdmVzIGFyZSBlbmNvZGVkIHZlY3RvcnMgaW4gUiBvYmplY3QgZGF0YSByZXR1cm5lZCBvbiBjYWxsPC9kZD5cbiAgICAgICAgICogIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdEV4ZWN1dGVDb2RlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7ICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2V4ZWN1dGUvY29kZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGV4ZWN1dGVzIGV4ZWN1dGVzIHJlcG9zaXRvcnktbWFuYWdlZCBzY3JpcHRzIG9yIGV4dGVybmFsIHNjcmlwdHNcbiAgICAgICAgICogb24gdGhlIFIgc2Vzc2lvbiBpZGVudGlmaWVkIGJ5IHRoZSBwcm9qZWN0IHBhcmFtZXRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gZXhlY3V0ZSBhIHNpbmdsZSByZXBvc2l0b3J5LW1hbmFnZWQgc2NyaXB0IHRoZSBjYWxsZXIgbXVzdCBwcm92aWRlXG4gICAgICAgICAqIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGZpbGVuYW1lLCBhdXRob3IgYW5kIG9wdGlvbmFsbHkgdmVyc2lvbi4gVG8gZXhlY3V0ZVxuICAgICAgICAgKiBhIGNoYWluIG9mIHJlcG9zaXRvcnktbWFuYWdlZCBzY3JpcHRzIHRoZSBjYWxsZXIgbXVzdCBwcm92aWRlIGFcbiAgICAgICAgICogY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmFsdWVzIG9uIHRoZSBmaWxlbmFtZSAsIGF1dGhvciBhbmQgb3B0aW9uYWxseVxuICAgICAgICAgKiB2ZXJzaW9uIHBhcmFtZXRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIGV4ZWN1dGUgYSBzaW5nbGUgZXh0ZXJuYWwgc2NyaXB0IHRoZSBjYWxsZXIgbXVzdCBwcm92aWRlIGEgdmFsaWQgVVJMIG9yXG4gICAgICAgICAqIGZpbGUgcGF0aCB1c2luZyB0aGUgZXh0ZXJuYWxzb3VyY2UgcGFyYW1ldGVyLiBUbyBleGVjdXRlIGEgY2hhaW4gb2ZcbiAgICAgICAgICogZXh0ZXJuYWwgc2NyaXB0cyB0aGUgY2FsbGVyIG11c3QgcHJvdmlkZSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZhbHVlc1xuICAgICAgICAgKiBvbiB0aGUgZXh0ZXJuYWxzb3VyY2UgcGFyYW1ldGVyLiBOb3RlLCB0byBleGVjdXRlIGFuIGV4dGVybmFsIHNjcmlwdCB0aGVcbiAgICAgICAgICogY2FsbGVyIG11c3QgaGF2ZSBQT1dFUl9VU0VSIHByaXZpbGVnZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IEEgY2hhaW5lZCBleGVjdXRpb24gZXhlY3V0ZXMgZWFjaCBvZiB0aGUgc2NyaXB0cyBpZGVudGlmaWVkIG9uIHRoZVxuICAgICAgICAgKiBjYWxsIGluIGEgc2VxdWVudGlhbCBmYXNoaW9uIG9uIHRoZSBSIHNlc3Npb24sIHdpdGggZXhlY3V0aW9uIG9jY3VyaW5nIGluXG4gICAgICAgICAqIHRoZSBvcmRlciBzcGVjaWZpZWQgb24gdGhlIHBhcmFtZXRlciBsaXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBQbGVhc2Ugbm90IHRoZSBmb2xsb3dpbmcgcHJlIGFuZCBwb3N0IGV4ZWN1dGlvbiBwYXJhbWV0ZXJzOlxuICAgICAgICAgKlxuICAgICAgICAgKiA8c3Ryb25nPlByZS1leGVjdXRpb24gcGFyYW1ldGVyczo8L3N0cm9uZz5cbiAgICAgICAgICpcbiAgICAgICAgICogPG9sPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBpbnB1dHMgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHBhc3MgUmV2b0RlcGxveVItZW5jb2RlZFxuICAgICAgICAgKiAgICAgICBSIG9iamVjdCB2YWx1ZXMgYXMgaW5wdXRzLiBUaGVzZSBpbnB1dHMgYXJlIHR1cm5lZCBpbnRvIFIgb2JqZWN0c1xuICAgICAgICAgKiAgICAgICBpbiB0aGUgd29ya3NwYWNlIGJlZm9yZSB0aGUgZXhlY3V0aW9uIGJlZ2lucy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgcHJlbG9hZGZpbGUgcGFyYW1ldGVycyBhbGxvd3MgdGhlIGNhbGxlciB0byBsb2FkIG9uZSBvciBtb3JlXG4gICAgICAgICAqICAgICAgIGZpbGVzIGZyb20gdGhlIHJlcG9zaXRvcnkgaW50byB0aGUgd29ya2luZyBkaXJlY3RvcnkgYmVmb3JlIHRoZVxuICAgICAgICAgKiAgICAgICBleGVjdXRpb24gYmVnaW5zLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBwcmVsb2Fkb2JqZWN0IHBhcmFtZXRlcnMgYWxsb3cgdGhlIGNhbGxlciB0byBsb2FkIG9uZSBvciBtb3JlXG4gICAgICAgICAqICAgICAgIGJpbmFyeSBSIG9iamVjdHMgKC5yRGF0YSkgZnJvbSB0aGUgcmVwb3NpdG9yeSBpbnRvIHRoZSB3b3Jrc3BhY2VcbiAgICAgICAgICogICAgICAgYmVmb3JlIHRoZSBleGVjdXRpb24gYmVnaW5zLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBhZG9wdCBwYXJhbWV0ZXJzIGFsbG93IHRoZSBjYWxsZXIgdG8gbG9hZCBhIHByZS1leGlzdGluZ1xuICAgICAgICAgKiAgICAgICBwcm9qZWN0IHdvcmtzcGFjZSwgcHJvamVjdCB3b3JraW5nIGRpcmVjdG9yeSBhbmQvb3IgcHJvamVjdCBwYWNrYWdlXG4gICAgICAgICAqICAgICAgIGRlcGVuZGVuY2llcyBiZWZvcmUgdGhlIGV4ZWN1dGlvbiBiZWdpbnMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqIDwvb2w+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxzdHJvbmc+UG9zdC1leGVjdXRpb24gcGFyYW1ldGVyczo8L3N0cm9uZz5cbiAgICAgICAgICpcbiAgICAgICAgICogPG9sPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSByb2JqZWN0cyBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gc3BlY2lmeSBhIGNvbW1hLXNlcGFyYXRlZFxuICAgICAgICAgKiAgICAgICBsaXN0IG9mIG9iamVjdCBuYW1lcyB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgYXMgUmV2b0RlcGxveVItZW5jb2RlZCBSXG4gICAgICAgICAqICAgICAgIG9iamVjdHMgb24gdGhlIHJlc3BvbnNlIG1hcmt1cCBhZnRlciB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVmaWxlIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciBzcGVjaWZ5IGEgY29tbWEtc2VwYXJhdGVkXG4gICAgICAgICAqICAgICAgIGxpc3Qgb2Ygd29ya2luZyBkaXJlY3RvcnkgZmlsZXMgdG8gYmUgc3RvcmVkIGluIHRoZSByZXBvc2l0b3J5IGFmdGVyXG4gICAgICAgICAqICAgICAgIHRoZSBleGVjdXRpb24gY29tcGxldGVzLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBzdG9yZW9iamVjdCBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgc3BlY2lmeSBhIGNvbW1hLXNlcGFyYXRlZFxuICAgICAgICAgKiAgICAgICBsaXN0IG9mIHdvcmtzcGFjZSBvYmplY3RzIHRvIGJlIHN0b3JlZCBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlciB0aGVcbiAgICAgICAgICogICAgICAgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmV3b3Jrc3BhY2UgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHN0b3JlIHRoZSBlbnRpcmVcbiAgICAgICAgICogICAgICAgd29ya3NwYWNlIGluIHRoZSByZXBvc2l0b3J5IGFmdGVyIHRoZSBleGVjdXRpb24gY29tcGxldGVzLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBzdG9yZWRpcmVjdG9yeSBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gc3BlY2lmeSBhIHRhcmdldFxuICAgICAgICAgKiAgICAgICByZXBvc2l0b3J5IGRpcmVjdG9yeSBmb3Igc3RvcmVkIGZpbGVzIGFuZCBvYmplY3RzIGFmdGVyIHRoZSBleGVjdXRpb25cbiAgICAgICAgICogICAgICAgY29tcGxldGVzLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBzdG9yZW5ld3ZlcnNpb24gcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIGNyZWF0ZSBuZXdcbiAgICAgICAgICogICAgICAgdmVyc2lvbnMgb2YgZWFjaCBzdG9yZWQgZmlsZSBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlciB0aGUgZXhlY3V0aW9uXG4gICAgICAgICAqICAgICAgIGNvbXBsZXRlcy4gQnkgZGVmYXVsdCwgc3RvcmVkIGZpbGVzIG92ZXJ3cml0ZSBhbnkgcHJlLWV4aXN0aW5nIGZpbGVcbiAgICAgICAgICogICAgICAgYnkgdGhlIHNhbWUgbmFtZS5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVwdWJsaWMgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIGFzc2lnbiBwdWJsaWMgYWNjZXNzXG4gICAgICAgICAqICAgICAgIHRvIGVhY2ggc3RvcmVkIGZpbGUgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlIGV4ZWN1dGlvbiBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqIDwvb2w+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxzdHJvbmc+XG4gICAgICAgICAqICAgIFNvbWUgb2YgdGhlIGtleSBkYXRhIGluZGljYXRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwIG9uIHRoaXMgY2FsbFxuICAgICAgICAgKiAgICBpbmNsdWRlOlxuICAgICAgICAgKiA8L3N0cm9uZz5cbiAgICAgICAgICpcbiAgICAgICAgICogPG9sPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIGNvbnNvbGUgLSBpbmRpY2F0ZXMgdGhlIGNvbnNvbGUgb3V0cHV0IHJlc3VsdGluZyBmcm9tIHRoZSBzY3JpcHRcbiAgICAgICAgICogICAgICAgZXhlY3V0aW9uXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgcmVzdWx0cyAtIGluZGljYXRlcyB0aGUgbGlzdCBvZiBmaWxlcyBnZW5lcmF0ZWQgYnkgdGhlIFIgZ3JhcGhpY3NcbiAgICAgICAgICogICAgICAgZGV2aWNlXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgYXJ0aWZhY3RzIC0gaW5kaWNhdGVzIHRoZSBsaXN0IG9mIGZpbGVzIGdlbmVyYXRlZCBvciBtb2RpZmllZCBpbiB0aGVcbiAgICAgICAgICogICAgICAgd29ya2luZyBkaXJlY3RvcnlcbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBvYmplY3RzIC0gaW5kaWNhdGVzIHRoZSBsaXN0IG9mIFIgb2JqZWN0cyByZXR1cm5lZCBmcm9tIHRoZSB3b3Jrc3BhY2VcbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBmaWxlcyAtIGluZGljYXRlcyB0aGUgbGlzdCBvZiBmaWxlcyBhbmQgb2JqZWN0cyBzdG9yZWQgaW4gdGhlXG4gICAgICAgICAqICAgICAgIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlIGV4ZWN1dGlvbiBjb21wbGV0ZXNcbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPmludGVycnVwdGVkIC0gaW5kaWNhdGVzIHRoZSBpbnRlcnJ1cHRlZCBzdGF0dXMgb2YgZXhlY3V0aW9uPC9saT5cbiAgICAgICAgICogICAgPGxpPmVycm9yIC0gb24gZmFpbHVyZSwgaW5kaWNhdGVzIHRoZSByZWFzb24gZm9yIGZhaWx1cmU8L2xpPlxuICAgICAgICAgKiAgICA8bGk+ZXJyb3JDb2RlIC0gb24gZmFpbHVyZSwgaW5kaWNhdGVzIHRoZSBlcnJvciBjb2RlIGZvciBmYWlsdXJlPC9saT5cbiAgICAgICAgICogPC9vbD5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0RXhlY3V0ZVNjcmlwdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqICA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmZpbGVuYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdCBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJlcG9zaXRvcnktbWFuYWdlZCBkaXJlY3RvcmllcyBmb3JcbiAgICAgICAgICogICAgICAgc2NyaXB0cywgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+YXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYXV0aG9ycywgYXV0aG9yLXBlci1maWxlbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD52ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmVyc2lvbnMsIHZlcnNpb24tcGVyLWZpbGVuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmV4dGVybmFsc291cmNlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgVVJMcyBvciBmaWxlIHBhdGhzIHRvIGV4dGVybmFsIHNjcmlwdHM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+aW5wdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgUmV2b0RlcGxveVItZW5jb2RlZCBzY3JpcHQgaW5wdXRzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmNzdmlucHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHByaW1pdGl2ZSBuYW1lL3ZhbHVlIGlucHV0czwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2FkZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiByZXBvc2l0b3J5IGZpbGVuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2FkZmlsZWF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGF1dGhvcnMsIGF1dGhvci1wZXItcHJlbG9hZGZpbGVuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRmaWxldmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZlcnNpb25zLCB2ZXJzaW9uLXBlci1wcmVsb2FkZmlsZW5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdG5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiByZXBvc2l0b3J5IG9iamVjdCAoLnJEYXRhKSBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdGF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGF1dGhvcnMsIGF1dGhvci1wZXItcHJlbG9hZG9iamVjdG5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdHZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2ZXJzaW9ucywgdmVyc2lvbi1wZXItb2JqZWN0LXByZWxvYWRvYmplY3RuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmFkb3B0d29ya3NwYWNlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWRlbnRpZmllcyBwcm9qZWN0IGZyb20gd2hpY2ggd29ya3NwYWNlIGlzIHRvIGJlIGFkb3B0ZWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+YWRvcHRkaXJlY3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZGVudGlmaWVzIHByb2plY3QgZnJvbSB3aGljaCBkaXJlY3RvcnkgaXMgdG8gYmUgYWRvcHRlZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkZD5hZG9wdHBhY2thZ2VzPC9kZD5cbiAgICAgICAgICogICAgPGR0PihvcHRpb25hbCkgaWRlbnRpZmllcyBwcm9qZWN0IGZyb20gd2hpY2ggcGFja2FnZSBkZXBlbmRlbmNpZXMgYXJlIHRvIGJlIGFkb3B0ZWQ8L2R0PlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dGFnPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIGEgdGFnIHRoYXQgbGFiZWxzIHRoZSBleGVjdXRpb248L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZWNob29mZjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUgUiBjb21tYW5kcyB3aWxsIG5vdCBhcHBlYXIgaW4gdGhlIGNvbnNvbGUgb3V0cHV0PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmdyYXBoaWNzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHByZWZlcnJlZCBSIGdyYXBoaWNzIGRldmljZSBmb3IgZXhlY3V0aW9uOiBwbmcgb3Igc3ZnPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmdyYXBoaWNzd2lkdGg8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgcHJlZmVycmVkIHdpZHRoIGZvciBSIGdyYXBoaWNzIGRldmljZSBpbWFnZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+Z3JhcGhpY3NoZWlnaHQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgcHJlZmVycmVkIGhlaWdodCBmb3IgUiBncmFwaGljcyBkZXZpY2UgaW1hZ2VzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJvYmplY3RzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygb2JqZWN0cyBmb3IgcmV0cmlldmFsIGZvbGxvd2luZyB0aGUgZXhlY3V0aW9uPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnN0b3JlZmlsZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHdvcmtpbmcgZGlyZWN0b3J5IGZpbGVuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zdG9yZW9iamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHdvcmtzcGFjZSBvYmplY3QgbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c3RvcmV3b3Jrc3BhY2U8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBmaWxlbmFtZSAoLnJEYXRhKSB3aGVyZSB3b3Jrc3BhY2UgY29udGVudHMgd2lsbCBiZSBzYXZlZCBpbiB0aGUgcmVwb3NpdG9yeTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zdG9yZW5ld3ZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgZW5zdXJlcyBlYWNoIGZpbGUgc3RvcmVkIGluIHJlcG9zaXRvcnkgcmVzdWx0cyBpbiBuZXcgdmVyc2lvbiBiZWluZyBjcmVhdGVkIGlmIG5lZWRlZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zdG9yZXB1YmxpYzwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBwdWJsaXNoZXMgZWFjaCBmaWxlIHN0b3JlZCBpbiB0aGUgcmVwb3NpdG9yeTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5pbmZpbml0eTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBjdXN0b20gdmFsdWUgZm9yIEluZmluaXR5IGFwcGVhcmluZyBpbiBSIG9iamVjdCBkYXRhIHJldHVybmVkIG9uIGNhbGwsIG90aGVyd2lzZSBJbmZpbml0eSBpcyByZXByZXNlbnRlZCBieSA8Y29kZT4weDdmZjAwMDAwMDAwMDAwMDBMPC9jb2RlPjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5uYW48L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgY3VzdG9tIHZhbHVlIGZvciBOYU4gYXBwZWFyaW5nIGluIFIgb2JqZWN0IGRhdGEgcmV0dXJuZWQgb24gY2FsbCwgb3RoZXJ3aXNlIE5hTiBpcyByZXByZXNlbnRlZCBieSA8Y29kZT5udWxsPC9jb2RlPjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5lbmNvZGVEYXRhRnJhbWVQcmltaXRpdmVBc1ZlY3RvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBkYXRhLmZyYW1lIHByaW1pdGl2ZXMgYXJlIGVuY29kZWQgdmVjdG9ycyBpbiBSIG9iamVjdCBkYXRhIHJldHVybmVkIG9uIGNhbGw8L2RkPlxuICAgICAgICAgKiAgPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RXhlY3V0ZVNjcmlwdDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykgeyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvZXhlY3V0ZS9zY3JpcHQnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGludGVycnVwdHMgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIG9uIHNwZWNpZmllZCBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RFeGVjdXRlSW50ZXJydXB0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogIDxkbD5cbiAgICAgICAgICogICAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICogIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdEV4ZWN1dGVJbnRlcnJ1cHQ6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2V4ZWN1dGUvaW50ZXJydXB0JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCByZXRyaWV2ZXMgdGhlIFIgY29uc29sZSBvdXRwdXQgZm9yIHRoZSBsYXRlc3QgZXhlY3V0aW9uIG9uXG4gICAgICAgICAqIHNwZWNpZmllZCBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RFeGVjdXRlQ29uc29sZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqICA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKiAgPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RXhlY3V0ZUNvbnNvbGU6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2V4ZWN1dGUvY29uc29sZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgcmV0cmlldmVzIHRoZSBleGVjdXRpb24gaGlzdG9yeSBmb3IgdGhlIHNwZWNpZmllZCBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBTb21lIG9mIHRoZSBrZXkgZGF0YSBpbmRpY2F0ZWQgZm9yIGVhY2ggaGlzdG9yeSBpdGVtIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogb24gdGhpcyBjYWxsIGluY2x1ZGU6XG4gICAgICAgICAqXG4gICAgICAgICAqIDxvbD5cbiAgICAgICAgICogIDxsaT5jb2RlIC0gaW5kaWNhdGVzIHRoZSBjb2RlIHRoYXQgaGFzIGJlZW4gZXhlY3V0ZWQ8L2xpPlxuICAgICAgICAgKiAgPGxpPmNvbnNvbGUgLSBpbmRpY2F0ZXMgdGhlIGNvbnNvbGUgb3V0cHV0IHJlc3VsdGluZyBmcm9tIHRoZSBjb2RlIGV4ZWN1dGlvbjwvbGk+XG4gICAgICAgICAqICA8bGk+cmVzdWx0c0dlbmVyYXRlZCAtIGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIGdlbmVyYXRlZCByZXN1bHRzIG9uIHRoZSBleGVjdXRpb248L2xpPlxuICAgICAgICAgKiAgPGxpPnJlc3VsdHNBdmFpbGFibGUgLSBpbmRpY2F0ZXMgdGhlIG51bWJlciBvZiBnZW5lcmF0ZWQgcmVzdWx0cyBzdGlsbCBzdG9yZWQgb24gdGhlIGV4ZWN1dGlvbjwvbGk+XG4gICAgICAgICAqICA8bGk+cmVzb3VyY2VVc2FnZSAtIGluZGljYXRlcyB0aGUgY3VycmVudCBzdG9yYWdlIGJ5dGUgY291bnQgZm9yIHJlc3VsdHMgb24gdGhlIGV4ZWN1dGlvbjwvbGk+XG4gICAgICAgICAqICA8bGk+ZXhlY3V0aW9uIC0gaW5kaWNhdGVzIHRoZSBleGVjdXRpb24gaWRlbnRpZmllciwgd2hpY2ggY2FuIHRoZW4gYmUgdXNlZCBvbiAvci9wcm9qZWN0L2V4ZWN1dGlvbi9yZXN1bHQgY2FsbHMgdG8gcmV0cmlldmUgb3IgbWFuYWdlIHJlc3VsdHM8L2xpPlxuICAgICAgICAgKiAgPGxpPmludGVycnVwdGVkIC0gaW5kaWNhdGVzIHRoZSBpbnRlcnJ1cHRlZCBzdGF0dXMgb2YgZXhlY3V0aW9uPC9saT5cbiAgICAgICAgICogIDxsaT5lcnJvciAtIG9uIGZhaWx1cmUsIGluZGljYXRlcyB0aGUgcmVhc29uIGZvciBmYWlsdXJlPC9saT5cbiAgICAgICAgICogIDxsaT5lcnJvckNvZGUgLSBvbiBmYWlsdXJlLCBpbmRpY2F0ZXMgdGhlIGVycm9yIGNvZGUgZm9yIGZhaWx1cmU8L2xpPlxuICAgICAgICAgKiA8L29sPlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RFeGVjdXRlSGlzdG9yeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsdGVyZGVwdGg8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBtYXggbnVtYmVyIG9mIGV4ZWN1dGlvbnMgdG8gYmUgcmV0dXJuZWQgaW4gdGhlIGhpc3Rvcnk8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZXhlY3V0aW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleGVjdXRpb24gaWRlbnRpZmllcnMgb24gd2hpY2ggdG8gZmlsdGVyIGhpc3Rvcnk8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsdGVydGFnPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBleGVjdXRpb24gdGFnIG9uIHdoaWNoIHRvIGZpbHRlciBoaXN0b3J5PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJldmVyc2VkPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBleGVjdXRpb24gaGlzdG9yeSBpcyByZXR1cm5lZCBpbiBhXG4gICAgICAgICAqICAgICAgIHJldmVyc2UtY2hyb25vbG9naWNhbCBvcmRlclxuICAgICAgICAgKiAgICA8L2R0PlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RFeGVjdXRlSGlzdG9yeTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvZXhlY3V0ZS9oaXN0b3J5JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBmbHVzaGVzIGV4ZWN1dGlvbnMgaW4gdGhlIGhpc3Rvcnkgb24gdGhlIHNwZWNpZmllZCBwcm9qZWN0LlxuICAgICAgICAgKiBGbHVzaGluZyBhbiBleGVjdXRpb24gZGVsZXRlcyBib3RoIHRoZSBSIGNvbnNvbGUgb3V0cHV0IGFuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAgICAqIHJlc3VsdHMgYXNzb2NpYXRlZCB3aXRoIHRoYXQgZXhlY3V0aW9uIGJ1dCBkb2VzIG5vdCByZW1vdmUgdGhlIGV4ZWN1dGlvblxuICAgICAgICAgKiBpdHNlbGYgZnJvbSB0aGUgaGlzdG9yeS4gQnkgb21pdHRpbmcgdGhlIGV4ZWN1dGlvbiBwYXJhbWV0ZXIsIHRoZSBjYWxsZXJcbiAgICAgICAgICogY2FuIGZsdXNoIGV2ZXJ5IGV4ZWN1dGlvbiBpbiB0aGUgaGlzdG9yeSBvbiB0aGUgc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZmx1c2hpbmcgZmFjaWxpdHkgaXMgcHJvdmlkZWQgdG8gaGVscCB1c2VycyBtYW5hZ2UgdGhlIGxldmVscyBvZlxuICAgICAgICAgKiByZXNvdXJjZSB1c2FnZSBhc3NvY2lhdGVkIHdpdGggdGhlaXIgcGVyc2lzdGVudCBwcm9qZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0RXhlY3V0ZUZsdXNoXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZXhlY3V0aW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhlY3V0aW9uIGlkZW50aWZpZXJzPC9kZD5cbiAgICAgICAgICogIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdEV4ZWN1dGVGbHVzaDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvZXhlY3V0ZS9mbHVzaCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgbGlzdHMgdGhlIGV4ZWN1dGlvbiByZXN1bHRzIGZvciB0aGUgc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IHNwZWNpZnlpbmcgYSB2YWx1ZSBmb3IgdGhlIGV4ZWN1dGlvbiBwYXJhbWV0ZXIgdGhlIGNhbGxlciBjYW4gbGltaXQgdGhlXG4gICAgICAgICAqIHJlc3BvbnNlIHRvIHRob3NlIHJlc3VsdHMgZm91bmQgb24gYSBzcGVjaWZpYyBleGVjdXRpb24gb3Igc2V0IG9mXG4gICAgICAgICAqIGV4ZWN1dGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxibG9ja3F1b3RlPlxuICAgICAgICAgKiAgICBJbXBvcnRhbnQhIFRoZSBVUkxzIGluZGljYXRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwIG9uIHRoaXMgY2FsbCByZW1haW5cbiAgICAgICAgICogICAgdmFsaWQgZm9yIGFzIGxvbmcgYXMgdGhlIHJlc3VsdHMgcmVtYWluIHBhcnQgb2YgdGhlIHByb2plY3QuXG4gICAgICAgICAqIDwvYmxvY2txdW90ZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0RXhlY3V0ZVJlc3VsdExpc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmV4ZWN1dGlvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleGVjdXRpb24gaWRlbnRpZmllcnNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RXhlY3V0ZVJlc3VsdExpc3Q6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2V4ZWN1dGUvcmVzdWx0L2xpc3QnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGRvd25sb2FkcyB0aGUgZXhlY3V0aW9uIHJlc3VsdHMgZm9yIHRoZSBzcGVjaWZpZWQgcHJvamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgc3BlY2lmeWluZyBhIHZhbHVlIGZvciB0aGUgZXhlY3V0aW9uIHBhcmFtZXRlciB0aGUgY2FsbGVyIGNhbiBkb3dubG9hZFxuICAgICAgICAgKiBvbmx5IHJlc3VsdHMgb24gdGhlIHNwZWNpZmllZCBleGVjdXRpb25zLiBCeSBzcGVjaWZ5aW5nIGEgdmFsdWUgZm9yIHRoZVxuICAgICAgICAgKiBmaWxlbmFtZSBwYXJhbWV0ZXIgdGhlIGNhbGxlciBjYW4gZG93bmxvYWQgYSBzcGVjaWZpYyByZXN1bHQgb24gdGhlXG4gICAgICAgICAqIHNwZWNpZmllZCBleGVjdXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdEV4ZWN1dGVSZXN1bHREb3dubG9hZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZXhlY3V0aW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4ZWN1dGlvbiBpZGVudGlmaWVyc1xuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgYSByZXN1bHQgZmlsZSBuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmlubGluZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgQ29udGVudC1EaXNwb3NpdGlvbiByZXNwb25zZSBoZWFkZXJcbiAgICAgICAgICogICAgICAgaW5kaWNhdGluZyBhdHRhY2htZW50IGlzIG9taXR0ZWRcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdEV4ZWN1dGVSZXN1bHREb3dubG9hZDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvZXhlY3V0ZS9yZXN1bHQvZG93bmxvYWQnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGRlbGV0ZXMgdGhlIGV4ZWN1dGlvbiByZXN1bHRzIGZvciB0aGUgc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IHNwZWNpZnlpbmcgYSB2YWx1ZSBmb3IgdGhlIGV4ZWN1dGlvbiBwYXJhbWV0ZXIgdGhlIGNhbGxlciBjYW4gZGVsZXRlXG4gICAgICAgICAqIG9ubHkgdGhvc2UgcmVzdWx0cyBvbiB0aGUgc3BlY2lmaWVkIGV4ZWN1dGlvbnMuIEJ5IHNwZWNpZnlpbmcgYSB2YWx1ZSBmb3JcbiAgICAgICAgICogdGhlIGZpbGVuYW1lIHBhcmFtZXRlciB0aGUgY2FsbGVyIGNhbiBkZWxldGUgYSBzcGVjaWZpYyByZXN1bHQgb24gdGhlXG4gICAgICAgICAqIHNwZWNpZmllZCBleGVjdXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RFeGVjdXRlUmVzdWx0RGVsZXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIDxkdD5leGVjdXRpb248L2R0PlxuICAgICAgICAgKiAgIDxkZD5cbiAgICAgICAgICogICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4ZWN1dGlvbiBpZGVudGlmaWVyc1xuICAgICAgICAgKiAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgPGR0PmZpbGVuYW1lPC9kdD5cbiAgICAgICAgICogICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgYSByZXN1bHQgZmlsZSBuYW1lPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RXhlY3V0ZVJlc3VsdERlbGV0ZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvZXhlY3V0ZS9yZXN1bHQvZGVsZXRlJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAvLyBQcm9qZWN0IERpcmVjdG9yeSBBUElzXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGxpc3RzIHdvcmtpbmcgZGlyZWN0b3J5IGZpbGVzIGZvciB0aGUgc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmaWx0ZXIgcGFyYW1ldGVyIGNhbiBiZSBzcGVjaWZpZWQgb24gdGhlIGNhbGwgdG8gZmlsdGVyLCB0aGUgdHlwZXMgb2ZcbiAgICAgICAgICogZmlsZXMgcmV0dXJuZWQgYWNjb3JkaW5nIHRvIHRoZWlyIGNhdGVnb3J5LiBUaGUgZm9sbG93aW5nIGZpbHRlciB2YWx1ZXMgYXJlXG4gICAgICAgICAqIHN1cHBvcnRlZDpcbiAgICAgICAgICpcbiAgICAgICAgICogPG9sPlxuICAgICAgICAgKiAgICA8bGk+cGxvdCAtIGZpbGVzIGVuZGluZyB3aXRoIGEgLnBuZywgLnN2ZyBvciAuanBnIGV4dGVuc2lvbjwvbGk+XG4gICAgICAgICAqICAgIDxsaT5zY3JpcHQgLSBmaWxlcyBlbmRpbmcgd2l0aCBhIC5SIG9yIC5yIGV4dGVuc2lvbjwvbGk+XG4gICAgICAgICAqICAgIDxsaT5SIC0gZmlsZXMgZW5kaW5nIHdpdGggYSAuckRhdGEgb3IgLnJkYXRhIGV4dGVuc2lvbjwvbGk+XG4gICAgICAgICAqICAgIDxsaT5kYXRhIC0gZmlsZXMgZW5kaW5nIHdpdGggYSAuY3N2IG9yIC54bHMgZXh0ZW5zaW9uPC9saT5cbiAgICAgICAgICogICAgPGxpPnRleHQgLSBmaWxlcyBlbmRpbmcgd2l0aCBhIC50eHQgZXh0ZW5zaW9uPC9saT5cbiAgICAgICAgICogPC9vbD5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0RGlyZWN0b3J5TGlzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsdGVyPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBmaWx0ZXIgYnkgY2F0ZWdvcnkgdmFsdWU8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3REaXJlY3RvcnlMaXN0OiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9kaXJlY3RvcnkvbGlzdCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgdXBsb2FkcyBhIGZpbGUgaW50byB0aGUgd29ya2luZyBkaXJlY3RvcnkgZm9yIHRoZSBzcGVjaWZpZWRcbiAgICAgICAgICogcHJvamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0RGlyZWN0b3J5VXBsb2FkXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4uLi5maWxlIGNvbnRlbnQuLi48L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGVzY3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIGRlc2NyaXB0aW9uIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCBmaWxlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm92ZXJ3cml0ZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIG92ZXJ3cml0ZXMgdGhlIGV4aXN0aW5nIGZpbGUgb2Ygc2FtZSBuYW1lPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RGlyZWN0b3J5VXBsb2FkOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25maWcuZm9ybWF0ID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICB2YXIgaW9Db25maWcgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogY29uZmlnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgZm9ybToge1xuICAgICAgICAgICAgICAgICAgICBpZDogY29uZmlnLmZvcm1JZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IGNhbGxiYWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvZGlyZWN0b3J5L3VwbG9hZCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgdHJhbnNmZXJzIGEgZmlsZSBmcm9tIGEgVVJMIGludG8gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGZvciB0aGVcbiAgICAgICAgICogc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdERpcmVjdG9yeVRyYW5zZmVyXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dXJsPC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgVVJMIGZvciB0aGUgZmlsZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXNjcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgZGVzY3JpcHRpb24gdG8gYmUgYXNzb2NpYXRlZCB3aXRoIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+b3ZlcndyaXRlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgb3ZlcndyaXRlcyB0aGUgZXhpc3RpbmcgZmlsZSBvZiBzYW1lIG5hbWU8L2RkPlxuICAgICAgICAgKiAgPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RGlyZWN0b3J5VHJhbnNmZXI6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2RpcmVjdG9yeS90cmFuc2ZlcicsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgd3JpdGVzIGEgdGV4dCBmaWxlIGludG8gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGZvciB0aGUgc3BlY2lmaWVkXG4gICAgICAgICAqIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdERpcmVjdG9yeVdyaXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dGV4dDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHRleHQgY29udGVudCBmb3IgdGhlIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGVsaW1pdGVyPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyBhIGN1c3RvbSBkZWxpbWl0ZXIgZm9yIHRleHQgd2hlbiB3cml0aW5nXG4gICAgICAgICAqICAgICAgIG11bHRpcGxlIGZpbGVzLCBkZWZhdWx0cyB0byAjLCNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRlc2NyPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBkZXNjcmlwdGlvbiB0byBiZSBhc3NvY2lhdGVkIHdpdGggZmlsZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5vdmVyd3JpdGU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCBvdmVyd3JpdGVzIHRoZSBleGlzdGluZyBmaWxlIG9mIHNhbWUgbmFtZTwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdERpcmVjdG9yeVdyaXRlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9kaXJlY3Rvcnkvd3JpdGUnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiogXG4gICAgICAgICAqIFRoaXMgY2FsbCB1cGRhdGVzIGEgZmlsZSBuYW1lIGFuZC9vciBkZXNjcmlwdGlvbiBpbiB0aGUgd29ya2luZyBkaXJlY3RvcnlcbiAgICAgICAgICogZm9yIHRoZSBzcGVjaWZpZWQgcHJvamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0RGlyZWN0b3J5VXBkYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cmVuYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBuZXcgbmFtZSBmb3IgdGhlIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGVzY3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpY2VzIHRoZSBuZXcgZGVzY3JpcHRpb24gZm9yIHRoZSBmaWxlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm92ZXJ3cml0ZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIG92ZXJ3cml0ZXMgdGhlIGV4aXN0aW5nIGZpbGUgb2Ygc2FtZSBuYW1lPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RGlyZWN0b3J5VXBkYXRlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9kaXJlY3RvcnkvdXBkYXRlJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBzdG9yZXMgYSBmaWxlIGZyb20gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IHRvIHRoZSByZXBvc2l0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3REaXJlY3RvcnlTdG9yZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIGZpbGUgZm9yIHN0b3Jpbmc8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGVzY3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgYSBkZXNjcmlwdGlvbiB0byBhY2NvbXBhbnkgdGhlIHNhdmVkIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dGFnczwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGFnIHdvcmRzIHRvIGFzc29jaWF0ZSB3aXRoIHJlcG9zaXRvcnkgZmlsZVxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cmVzdHJpY3RlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygcm9sZSBuYW1lcywgd2hpY2ggbWFrZXMgdGhlIGZpbGVcbiAgICAgICAgICogICAgICAgIHZpc2libGUgdG8gYXV0aGVudGljYXRlZCB1c2VycyB3aXRoIHRoZXNlIHJvbGVzXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zaGFyZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIGZpbGUgd2lsbCBiZSBzaGFyZWQgLCB3aGljaCBtYWtlcyB0aGUgZmlsZVxuICAgICAgICAgKiAgICAgICB2aXNpYmxlIHRvIGF1dGhlbnRpY2F0ZWQgdXNlcnNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnB1Ymxpc2hlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgZmlsZSB3aWxsIGJlIHB1Ymxpc2hlZCAsIHdoaWNoIG1ha2VzIHRoZVxuICAgICAgICAgKiAgICAgICBmaWxlIHZpc2libGUgdG8gYXV0aGVudGljYXRlZCBhbmQgYW5vbnltb3VzIHVzZXJzXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5uZXd2ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBuZXcgZmlsZSB3aWxsIGJlIHJlbmFtZWQgdG8gYXZvaWQgb3ZlcndyaXRpbmdcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RGlyZWN0b3J5U3RvcmU6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2RpcmVjdG9yeS9zdG9yZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgbG9hZHMgYSBmaWxlIGZyb20gdGhlIHJlcG9zaXRvcnkgaW50byB0aGUgd29ya2luZyBkaXJlY3RvcnkgZm9yXG4gICAgICAgICAqIHRoZSBzcGVjaWZpZWQgcHJvamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0RGlyZWN0b3J5TG9hZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IGZpbGUgbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5hdXRob3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBhdXRob3IgbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD52ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IGZpbGUgdmVyc2lvbjwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdERpcmVjdG9yeUxvYWQ6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2RpcmVjdG9yeS9sb2FkJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBkb3dubG9hZHMgdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGNvbnRlbnRzIGZvciB0aGUgc3BlY2lmaWVkXG4gICAgICAgICAqIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IHNwZWNpZnlpbmcgYSBzaW5nbGUgdmFsdWUgZm9yIHRoZSBmaWxlbmFtZSBwYXJhbWV0ZXIsIHRoZSBjYWxsZXIgY2FuXG4gICAgICAgICAqIGRvd25sb2FkIGEgc3BlY2lmaWMgZmlsZS4gQnkgc3BlY2lmeWluZyBtdWx0aXBsZSB2YWx1ZXMgZm9yIHRoZSBmaWxlbmFtZVxuICAgICAgICAgKiBwYXJhbWV0ZXIsIHRoZSBjYWxsZXIgY2FuIGRvd25sb2FkIGEgemlwIGFyY2hpdmUgb2YgdGhvc2UgZmlsZXMuIEJ5XG4gICAgICAgICAqIG9taXR0aW5nIHRoZSBmaWxlbmFtZSBwYXJhbWV0ZXIsIHRoZW4gdGhlIGNhbGxlciBjYW4gZG93bmxvYWQgYSB6aXAgYXJjaGl2ZVxuICAgICAgICAgKiB3aXRoIGFsbCBvZiB0aGUgZmlsZXMgaW4gdGhlIHdvcmtpbmcgZGlyZWN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3REaXJlY3RvcnlEb3dubG9hZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgY29tbWEtc2VwYXJhdGVkIGZpbGUgbmFtZXMgZm9yIGRvd25sb2FkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmlubGluZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgQ29udGVudC1EaXNwb3NpdGlvbiByZXNwb25zZSBoZWFkZXJcbiAgICAgICAgICogICAgICAgaW5kaWNhdGluZyBhdHRhY2htZW50IGlzIG9taXR0ZWRcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RGlyZWN0b3J5RG93bmxvYWQ6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9wcm9qZWN0L2RpcmVjdG9yeS9kb3dubG9hZCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgZGVsZXRlcyBmaWxlcyBmcm9tIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBmb3IgdGhlIHNwZWNpZmllZFxuICAgICAgICAgKiBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3REaXJlY3RvcnlEZWxldGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmZpbGVuYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpbGUgbmFtZXMgZm9yIGRlbGV0aW9uPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0RGlyZWN0b3J5RGVsZXRlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9kaXJlY3RvcnkvZGVsZXRlJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAvLyBQcm9qZWN0IFBhY2thZ2UgQVBJc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBsaXN0cyBSIHBhY2thZ2UgZGVwZW5kZW5jaWVzIGZvciB0aGUgc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdFBhY2thZ2VMaXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5pbnN0YWxsZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIGlmIHRydWUsIHJlc3BvbnNlIGxpc3RzIGFsbCBwYWNrYWdlcyBpbnN0YWxsZWQgaW4gcHJvamVjdCBlbnZpcm9ubWVudFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RQYWNrYWdlTGlzdDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3Byb2plY3QvcGFja2FnZS9saXN0JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBhdHRhY2hlcyBSIHBhY2thZ2UgZGVwZW5kZW5jaWVzIGZvciB0aGUgc3BlY2lmaWVkIHByb2plY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJvamVjdFBhY2thZ2VBdHRhY2hcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyB0aGUgcHJvamVjdCBpZGVudGlmaWVyPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgUiBwYWNrYWdlIG5hbWVzIHRvIGF0dGFjaDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5yZXBvPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIFIgcmVwb3NpdG9yeSBsb2NhdGlvbiBmb3IgbmFtZWQgcGFja2FnZXM8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RQYWNrYWdlQXR0YWNoOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9wYWNrYWdlL2F0dGFjaCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgZGV0YWNoZXMgUiBwYWNrYWdlIGRlcGVuZGVuY2llcyBmb3IgdGhlIHNwZWNpZmllZCBwcm9qZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByb2plY3RQYWNrYWdlRGV0YWNoXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5uYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFIgcGFja2FnZSBuYW1lcyB0byBkZXRhY2g8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3RQYWNrYWdlRGV0YWNoOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcHJvamVjdC9wYWNrYWdlL2RldGFjaCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gVXNlciBBUElzXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIHNpZ25zIHRoZSB1c2VyIGluIGJ5IGF1dGhlbnRpY2F0aW5nIHRoZSBjcmVkZW50aWFscyB3aXRoIHRoZVxuICAgICAgICAgKiBSZXZvRGVwbG95UiBzZXJ2ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgdXNlckxvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+dXNlcm5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSB1c2VybmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wYXNzd29yZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHBhc3N3b3JkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRpc2FibGVhdXRvc2F2ZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSB3aGVuIHRydWUsIGRpc2FibGVzIGF1dG9zYXZlIHNlbWFudGljcyBmb3IgcGVyc2lzdGVudFxuICAgICAgICAgKiAgICAgICBwcm9qZWN0c1xuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHVzZXJMb2dpbjogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3VzZXIvbG9naW4nLCBjb25maWcsIGNhbGxiYWNrKTsgICAgICAgICAgICBcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIHNpZ25zIG91dCB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCB1c2VyTG9nb3V0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+dXNlcmNvb2tpZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSB3aGVuIHNwZWNpZmllZCwgdmFsdWUgc2V0cyBhcHBsaWNhdGlvbi1zcGVjaWZpYyBwZXJzaXN0ZW50XG4gICAgICAgICAqICAgICAgIHVzZXIgY29va2llLCB3aGljaCBpcyByZXRyaWV2YWJsZSBvbiByZXNwb25zZSB0b1xuICAgICAgICAgKiAgICAgICA8YSBocmVmPVwiI21ldGhvZF91c2VyTG9naW5cIj51c2VyTG9naW48L2E+IGNhbGwuXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdXNlckxvZ291dDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3VzZXIvbG9nb3V0JywgY29uZmlnLCBjYWxsYmFjayk7ICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCByZXRyaWV2ZXMgZGV0YWlscyBhYm91dCB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlci4gVGhlXG4gICAgICAgICAqIGRldGFpbHMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlIG1hcmt1cCBvbiB0aGlzIGNhbGwgYXJlIGV4YWN0bHkgdGhlIHNhbWVcbiAgICAgICAgICogZGV0YWlscyBhcyB0aG9zZSByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwIG9uIHRoZVxuICAgICAgICAgKiA8YSBocmVmPVwiI21ldGhvZF91c2VyTG9naW5cIj51c2VyTG9naW48L2E+IGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgdXNlckFib3V0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyQWJvdXQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvdXNlci9hYm91dCcsIHt9LCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBhdXRvc2F2ZSBzZW1hbnRpY3Mgb24gcGVyc2lzdGVudCBwcm9qZWN0c1xuICAgICAgICAgKiBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBjdXJyZW50IHVzZXJzIEhUVFAgc2Vzc2lvbi4gQnkgZGVmYXVsdCwgYWxsIGxpdmVcbiAgICAgICAgICogcGVyc2lzdGVudCBwcm9qZWN0cyBhcmUgYXV0b3NhdmVkIHVuZGVyIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAgICAgICpcbiAgICAgICAgICogPHVsPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFdoZW4gYSB1c2VyIGNsb3NlcyBhIHByb2plY3QgdXNpbmcgdGhlXG4gICAgICAgICAqICAgICAgIDxhIGhyZWY9XCIjbWV0aG9kX3Byb2plY3RDbG9zZVwiPnByb2plY3RDbG9zZTwvYT4gY2FsbC5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBXaGVuIGEgdXNlciBzaWducy1vdXQgdXNpbmcgdGhlXG4gICAgICAgICAqICAgICAgIDxhIGhyZWY9XCIjbWV0aG9kX3VzZXJMb2dvdXRcIj51c2VyTG9nb3V0PC9hPiBjYWxsLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFdoZW4gYSB1c2VyIGlzIGF1dG9tYXRpY2FsbHkgc2lnbmVkLW91dCBieSB0aGUgc3lzdGVtIGFmdGVyIGFcbiAgICAgICAgICogICAgICAgcHJvbG9uZ2VkIHBlcmlvZCBvZiBpbmFjdGl2aXR5LlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiA8L3VsPlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHRoZSBhdXRvc2F2ZSBmZWF0dXJlIGlzIGRpc2FibGVkIGEgdXNlciBtdXN0IG1ha2UgYW4gZXhwbGljaXQgY2FsbCBvblxuICAgICAgICAgKiA8YSBocmVmPVwiI21ldGhvZF9wcm9qZWN0U2F2ZVwiPnByb2plY3RTYXZlPC9hPiBpbiBvcmRlciB0byBzYXZlIGEgcHJvamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCB1c2VyQXV0b3NhdmVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5lbmFibGU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSB0b2dnbGVzIGF1dG9zYXZlIHNlbWFudGljcyBmb3IgcGVyc2lzdGVudCBwcm9qZWN0cy48L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHVzZXJBdXRvc2F2ZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3VzZXIvYXV0b3NhdmUnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vIFJlcG9zaXRvcnkgU2NyaXB0IEFQSXNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgbGlzdHMgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgY2FsbCBpcyBhdmFpbGFibGUgdG8gYXV0aGVudGljYXRlZCBhbmQgYW5vbnltb3VzIHVzZXJzLiBIb3dldmVyLCBpZlxuICAgICAgICAgKiB0aGUgY2FsbGVyIGlzIGFuIGFub255bW91cyB1c2VyIHRoZW4gb25seSBwdWJsaXNoZWQgc2NyaXB0cyB3aWxsIGJlXG4gICAgICAgICAqIHJldHVybmVkIGluIHRoZSByZXNwb25zZSBtYXJrdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVwb3NpdG9yeVNjcmlwdExpc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSB3aGVuIHNwZWNpZmllZCwgY2FsbCByZXR1cm5zIGxpc3Qgb2Ygc2NyaXB0IHZlcnNpb25zIGZvclxuICAgICAgICAgKiAgICAgICBmaWxlbmFtZVxuICAgICAgICAgKiAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zaGFyZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIGZpbGVzIHRoYXQgYXJlIHJlc3RyaWN0ZWQgYnV0XG4gICAgICAgICAqICAgICAgIHZpc2libGUgb3Igc2hhcmVkIGJ5IG90aGVyIHVzZXJzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wdWJsaXNoZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIHNjcmlwdHMgcHVibGlzaGVkIGJ5IG90aGVyIHVzZXJzIGFyZVxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeVNjcmlwdExpc3Q6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcmVwb3NpdG9yeS9zY3JpcHQvbGlzdCcsIHt9LCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgZXhlY3V0ZXMgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdHMgb3IgZXh0ZXJuYWwgc2NyaXB0cyBvbiBhblxuICAgICAgICAgKiBBbm9ueW1vdXMgUHJvamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gZXhlY3V0ZSBhIHNpbmdsZSByZXBvc2l0b3J5LW1hbmFnZWQgc2NyaXB0IHRoZSBjYWxsZXIgbXVzdCBwcm92aWRlXG4gICAgICAgICAqIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGZpbGVuYW1lLCBhdXRob3IgYW5kIG9wdGlvbmFsbHkgdmVyc2lvbi4gVG8gZXhlY3V0ZSBhXG4gICAgICAgICAqIGNoYWluIG9mIHJlcG9zaXRvcnktbWFuYWdlZCBzY3JpcHRzIHRoZSBjYWxsZXIgbXVzdCBwcm92aWRlIGFcbiAgICAgICAgICogY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmFsdWVzIG9uIHRoZSBmaWxlbmFtZSAsIGF1dGhvciBhbmQgb3B0aW9uYWxseVxuICAgICAgICAgKiB2ZXJzaW9uIHBhcmFtZXRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIGV4ZWN1dGUgYSBzaW5nbGUgZXh0ZXJuYWwgc2NyaXB0IHRoZSBjYWxsZXIgbXVzdCBwcm92aWRlIGEgdmFsaWQgVVJMXG4gICAgICAgICAqIG9yIGZpbGUgcGF0aCB1c2luZyB0aGUgZXh0ZXJuYWxzb3VyY2UgcGFyYW1ldGVyLiBUbyBleGVjdXRlIGEgY2hhaW4gb2ZcbiAgICAgICAgICogZXh0ZXJuYWwgc2NyaXB0cyB0aGUgY2FsbGVyIG11c3QgcHJvdmlkZSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mXG4gICAgICAgICAqIHZhbHVlcyBvbiB0aGUgZXh0ZXJuYWxzb3VyY2UgcGFyYW1ldGVyLiBOb3RlLCB0byBleGVjdXRlIGFuIGV4dGVybmFsIHNjcmlwdFxuICAgICAgICAgKiB0aGUgY2FsbGVyIG11c3QgaGF2ZSBQT1dFUl9VU0VSIHByaXZpbGVnZXMgc28gdGhpcyBmZWF0dXJlIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgICogdG8gYW5vbnltb3VzIHVzZXJzIG9uIHRoaXMgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogQSBjaGFpbmVkIGV4ZWN1dGlvbiBleGVjdXRlcyBlYWNoIG9mIHRoZSBzY3JpcHRzIGlkZW50aWZpZWQgb24gdGhlXG4gICAgICAgICAqIGNhbGwgaW4gYSBzZXF1ZW50aWFsIGZhc2hpb24gb24gdGhlIFIgc2Vzc2lvbiwgd2l0aCBleGVjdXRpb24gb2NjdXJpbmcgaW5cbiAgICAgICAgICogdGhlIG9yZGVyIHNwZWNpZmllZCBvbiB0aGUgcGFyYW1ldGVyIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxzdHJvbmc+UHJlLWV4ZWN1dGlvbiBwYXJhbWV0ZXJzOjwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8b2w+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIGlucHV0cyBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gcGFzcyBSZXZvRGVwbG95Ui1lbmNvZGVkXG4gICAgICAgICAqICAgICAgIFIgb2JqZWN0IHZhbHVlcyBhcyBpbnB1dHMuIFRoZXNlIGlucHV0cyBhcmUgdHVybmVkIGludG8gUiBvYmplY3RzXG4gICAgICAgICAqICAgICAgIGluIHRoZSB3b3Jrc3BhY2UgYmVmb3JlIHRoZSBleGVjdXRpb24gYmVnaW5zLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBwcmVsb2FkZmlsZSBwYXJhbWV0ZXJzIGFsbG93cyB0aGUgY2FsbGVyIHRvIGxvYWQgb25lIG9yIG1vcmVcbiAgICAgICAgICogICAgICAgZmlsZXMgZnJvbSB0aGUgcmVwb3NpdG9yeSBpbnRvIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBiZWZvcmUgdGhlXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGlvbiBiZWdpbnMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHByZWxvYWRvYmplY3QgcGFyYW1ldGVycyBhbGxvdyB0aGUgY2FsbGVyIHRvIGxvYWQgb25lIG9yIG1vcmVcbiAgICAgICAgICogICAgICAgYmluYXJ5IFIgb2JqZWN0cyAoLnJEYXRhKSBmcm9tIHRoZSByZXBvc2l0b3J5IGludG8gdGhlIHdvcmtzcGFjZVxuICAgICAgICAgKiAgICAgICBiZWZvcmUgdGhlIGV4ZWN1dGlvbiBiZWdpbnMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIGFkb3B0IHBhcmFtZXRlcnMgYWxsb3cgdGhlIGNhbGxlciB0byBsb2FkIGEgcHJlLWV4aXN0aW5nXG4gICAgICAgICAqICAgICAgIHByb2plY3Qgd29ya3NwYWNlLCBwcm9qZWN0IHdvcmtpbmcgZGlyZWN0b3J5IGFuZC9vciBwcm9qZWN0IHBhY2thZ2VcbiAgICAgICAgICogICAgICAgZGVwZW5kZW5jaWVzIGJlZm9yZSB0aGUgZXhlY3V0aW9uIGJlZ2lucy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogPC9vbD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHN0cm9uZz5Qb3N0LWV4ZWN1dGlvbiBwYXJhbWV0ZXJzOjwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8b2w+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHJvYmplY3RzIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBzcGVjaWZ5IGEgY29tbWEtc2VwYXJhdGVkXG4gICAgICAgICAqICAgICAgIGxpc3Qgb2Ygb2JqZWN0IG5hbWVzIHRoYXQgd2lsbCBiZSByZXR1cm5lZCBhcyBSZXZvRGVwbG95Ui1lbmNvZGVkIFJcbiAgICAgICAgICogICAgICAgb2JqZWN0cyBvbiB0aGUgcmVzcG9uc2UgbWFya3VwIGFmdGVyIHRoZSBleGVjdXRpb24gY29tcGxldGVzLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBzdG9yZWZpbGUgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHNwZWNpZnkgYSBjb21tYS1zZXBhcmF0ZWRcbiAgICAgICAgICogICAgICAgbGlzdCBvZiB3b3JraW5nIGRpcmVjdG9yeSBmaWxlcyB0byBiZSBzdG9yZWQgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXJcbiAgICAgICAgICogICAgICAgdGhlIGV4ZWN1dGlvbiBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3Jlb2JqZWN0IHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciBzcGVjaWZ5IGEgY29tbWEtc2VwYXJhdGVkXG4gICAgICAgICAqICAgICAgIGxpc3Qgb2Ygd29ya3NwYWNlIG9iamVjdHMgdG8gYmUgc3RvcmVkIGluIHRoZSByZXBvc2l0b3J5IGFmdGVyIHRoZVxuICAgICAgICAgKiAgICAgICBleGVjdXRpb24gY29tcGxldGVzLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBzdG9yZXdvcmtzcGFjZSBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gc3RvcmUgdGhlIGVudGlyZVxuICAgICAgICAgKiAgICAgICB3b3Jrc3BhY2UgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlIGV4ZWN1dGlvbiBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlZGlyZWN0b3J5IHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBzcGVjaWZ5IGEgdGFyZ2V0XG4gICAgICAgICAqICAgICAgIHJlcG9zaXRvcnkgZGlyZWN0b3J5IGZvciBzdG9yZWQgZmlsZXMgYW5kIG9iamVjdHMgYWZ0ZXIgdGhlIGV4ZWN1dGlvblxuICAgICAgICAgKiAgICAgICBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlbmV3dmVyc2lvbiBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gY3JlYXRlIG5ld1xuICAgICAgICAgKiAgICAgICB2ZXJzaW9ucyBvZiBlYWNoIHN0b3JlZCBmaWxlIGluIHRoZSByZXBvc2l0b3J5IGFmdGVyIHRoZSBleGVjdXRpb25cbiAgICAgICAgICogICAgICAgY29tcGxldGVzLiBCeSBkZWZhdWx0LCBzdG9yZWQgZmlsZXMgb3ZlcndyaXRlIGFueSBwcmUtZXhpc3RpbmcgZmlsZVxuICAgICAgICAgKiAgICAgICBieSB0aGUgc2FtZSBuYW1lLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBzdG9yZXB1YmxpYyBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gYXNzaWduIHB1YmxpYyBhY2Nlc3NcbiAgICAgICAgICogICAgICAgdG8gZWFjaCBzdG9yZWQgZmlsZSBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlciB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgaW5maW5pdHkgLCBuYW4gYW5kIGVuY29kZURhdGFGcmFtZVByaW1pdGl2ZUFzVmVjdG9yIHBhcmFtZXRlcnNcbiAgICAgICAgICogICAgICAgYWxsb3cgdGhlIGNhbGxlciB0byBjb250cm9sIGhvdyBSZXZvRGVwbG95Ui1lbmNvZGVkIFIgb2JqZWN0IGRhdGEgaXNcbiAgICAgICAgICogICAgICAgZW5jb2RlZCBpbiB0aGUgcmVzcG9uc2UgbWFya2t1cC5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogPC9vbD5cbiAgICAgICAgICpcbiAgICAgICAgICogIDxzdHJvbmc+XG4gICAgICAgICAqICAgICBTb21lIGtleSBkYXRhIGluZGljYXRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwIG9uIHRoaXMgY2FsbDpcbiAgICAgICAgICogIDwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgPG9sPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIGNvbnNvbGUgLSBpbmRpY2F0ZXMgdGhlIGNvbnNvbGUgb3V0cHV0IHJlc3VsdGluZyBmcm9tIHRoZSBjb2RlXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGlvblxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIHJlc3VsdHMgLSBpbmRpY2F0ZXMgdGhlIGxpc3Qgb2YgZmlsZXMgZ2VuZXJhdGVkIGJ5IHRoZSBSIGdyYXBoaWNzXG4gICAgICAgICAqICAgICAgIGRldmljZVxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIGFydGlmYWN0cyAtIGluZGljYXRlcyB0aGUgbGlzdCBvZiBmaWxlcyBnZW5lcmF0ZWQgb3IgbW9kaWZpZWQgaW4gdGhlXG4gICAgICAgICAqICAgICAgIHdvcmtpbmcgZGlyZWN0b3J5XG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgb2JqZWN0cyAtICBpbmRpY2F0ZXMgdGhlIGxpc3Qgb2YgUiBvYmplY3RzIHJldHVybmVkIGZyb20gdGhlXG4gICAgICAgICAqICAgICAgIHdvcmtzcGFjZVxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIGZpbGVzIC0gaW5kaWNhdGVzIHRoZSBsaXN0IG9mIGZpbGVzIGFuZCBvYmplY3RzIHN0b3JlZCBpbiB0aGVcbiAgICAgICAgICogICAgICAgcmVwb3NpdG9yeSBhZnRlciB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlc1xuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+aW50ZXJydXB0ZWQgLSBpbmRpY2F0ZXMgdGhlIGludGVycnVwdGVkIHN0YXR1cyBvZiBleGVjdXRpb248L2xpPlxuICAgICAgICAgKiAgICA8bGk+ZXJyb3IgLSBvbiBmYWlsdXJlLCBpbmRpY2F0ZXMgdGhlIHJlYXNvbiBmb3IgZmFpbHVyZTwvbGk+XG4gICAgICAgICAqICAgIDxsaT5lcnJvckNvZGUgLSBvbiBmYWlsdXJlLCBpbmRpY2F0ZXMgdGhlIGVycm9yIGNvZGUgZm9yIGZhaWx1cmU8L2xpPlxuICAgICAgICAgKiA8L29sPlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlTY3JpcHRFeGVjdXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+cHJvamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHByb2plY3QgaWRlbnRpZmllcjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5jb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiByZXBvc2l0b3J5LW1hbmFnZWQgc2NyaXB0IGZpbGVuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kaXJlY3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeS1tYW5hZ2VkIGRpcmVjdG9yaWVzIGZvclxuICAgICAgICAgKiAgICAgICBzY3JpcHRzLCBkZWZhdWx0cyB0byByb290XG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5hdXRob3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhdXRob3JzLCBhdXRob3ItcGVyLWZpbGVuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2ZXJzaW9ucywgdmVyc2lvbi1wZXItZmlsZW5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZXh0ZXJuYWxzb3VyY2U8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBVUkxzIG9yIGZpbGUgcGF0aHMgdG8gZXh0ZXJuYWwgc2NyaXB0czwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5pbnB1dHM8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBSZXZvRGVwbG95Ui1lbmNvZGVkIHNjcmlwdCBpbnB1dHM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+Y3N2aW5wdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcHJpbWl0aXZlIG5hbWUvdmFsdWUgaW5wdXRzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRmaWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJlcG9zaXRvcnkgZmlsZW5hbWVzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRmaWxlYXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYXV0aG9ycywgYXV0aG9yLXBlci1wcmVsb2FkZmlsZW5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZGZpbGV2ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmVyc2lvbnMsIHZlcnNpb24tcGVyLXByZWxvYWRmaWxlbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2Fkb2JqZWN0bmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJlcG9zaXRvcnkgb2JqZWN0ICguckRhdGEpIGZpbGVuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2Fkb2JqZWN0YXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYXV0aG9ycywgYXV0aG9yLXBlci1wcmVsb2Fkb2JqZWN0bmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2Fkb2JqZWN0dmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZlcnNpb25zLCB2ZXJzaW9uLXBlci1vYmplY3QtcHJlbG9hZG9iamVjdG5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+YWRvcHR3b3Jrc3BhY2U8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZGVudGlmaWVzIHByb2plY3QgZnJvbSB3aGljaCB3b3Jrc3BhY2UgaXMgdG8gYmUgYWRvcHRlZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5hZG9wdGRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlkZW50aWZpZXMgcHJvamVjdCBmcm9tIHdoaWNoIGRpcmVjdG9yeSBpcyB0byBiZSBhZG9wdGVkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmFkb3B0cGFja2FnZXM8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZGVudGlmaWVzIHByb2plY3QgZnJvbSB3aGljaCBwYWNrYWdlIGRlcGVuZGVuY2llcyBhcmUgdG8gYmUgYWRvcHRlZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5ibGFja2JveDwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBleGVjdXRpb24gd2lsbCBvY2N1ciBvbiB0aGUgSFRUUCBibGFja2JveFxuICAgICAgICAgKiAgICAgICBwcm9qZWN0IGZvciB0aGUgY3VycmVudCBIVFRQIHNlc3Npb25cbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+cmVjeWNsZTwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIHRydWUsIHJlY3ljbGVzIHRoZSBSIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBIVFRQXG4gICAgICAgICAqICAgICAgIGJsYWNrYm94IHByb2plY3Qgb24gdGhlIGN1cnJlbnQgSFRUUCBzZXNzaW9uXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD50YWc8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgYSB0YWcgdGhhdCBsYWJlbHMgdGhlIGV4ZWN1dGlvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5lY2hvb2ZmPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmdyYXBoaWNzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHByZWZlcnJlZCBSIGdyYXBoaWNzIGRldmljZSBmb3IgZXhlY3V0aW9uOiBwbmcgb3Igc3ZnPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmdyYXBoaWNzd2lkdGg8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgcHJlZmVycmVkIHdpZHRoIGZvciBSIGdyYXBoaWNzIGRldmljZSBpbWFnZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+Z3JhcGhpY3NoZWlnaHQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgcHJlZmVycmVkIGhlaWdodCBmb3IgUiBncmFwaGljcyBkZXZpY2UgaW1hZ2VzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJvYmplY3RzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygb2JqZWN0cyBmb3IgcmV0cmlldmFsIGZvbGxvd2luZyB0aGUgZXhlY3V0aW9uPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnN0b3JlZmlsZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHdvcmtpbmcgZGlyZWN0b3J5IGZpbGVuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zdG9yZW9iamVjdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHdvcmtzcGFjZSBvYmplY3QgbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c3RvcmV3b3Jrc3BhY2U8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBmaWxlbmFtZSAoLnJEYXRhKSB3aGVyZSB3b3Jrc3BhY2UgY29udGVudHMgd2lsbCBiZSBzYXZlZCBpbiB0aGUgcmVwb3NpdG9yeTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zdG9yZW5ld3ZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgZW5zdXJlcyBlYWNoIGZpbGUgc3RvcmVkIGluIHJlcG9zaXRvcnkgcmVzdWx0cyBpbiBuZXcgdmVyc2lvbiBiZWluZyBjcmVhdGVkIGlmIG5lZWRlZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zdG9yZXB1YmxpYzwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBwdWJsaXNoZXMgZWFjaCBmaWxlIHN0b3JlZCBpbiB0aGUgcmVwb3NpdG9yeTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5pbmZpbml0eTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgY3VzdG9tIHZhbHVlIGZvciBJbmZpbml0eSBhcHBlYXJpbmcgaW4gUiBvYmplY3RcbiAgICAgICAgICogICAgICAgZGF0YSByZXR1cm5lZCBvbiBjYWxsLCBvdGhlcndpc2UgSW5maW5pdHkgaXMgcmVwcmVzZW50ZWQgYnlcbiAgICAgICAgICogICAgICAgPGNvZGU+MHg3ZmYwMDAwMDAwMDAwMDAwTDwvY29kZT5cbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5hbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgY3VzdG9tIHZhbHVlIGZvciBOYU4gYXBwZWFyaW5nIGluIFIgb2JqZWN0IGRhdGFcbiAgICAgICAgICogICAgICAgcmV0dXJuZWQgb24gY2FsbCwgb3RoZXJ3aXNlIE5hTiBpcyByZXByZXNlbnRlZCBieSA8Y29kZT5udWxsPC9jb2RlPlxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZW5jb2RlRGF0YUZyYW1lUHJpbWl0aXZlQXNWZWN0b3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIGRhdGEuZnJhbWUgcHJpbWl0aXZlcyBhcmUgZW5jb2RlZFxuICAgICAgICAgKiAgICAgICB2ZWN0b3JzIGluIFIgb2JqZWN0IGRhdGEgcmV0dXJuZWQgb24gY2FsbFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcG9zaXRvcnlTY3JpcHRFeGVjdXRlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcmVwb3NpdG9yeS9zY3JpcHQvZXhlY3V0ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBleGVjdXRlcyByZXBvc2l0b3J5LW1hbmFnZWQgc2NyaXB0cyBvciBleHRlcm5hbCBzY3JpcHRzIG9uIGFuXG4gICAgICAgICAqIEFub255bW91cyBQcm9qZWN0IGFuZCByZXR1cm5zIGEgc2ltcGxlIEhUTUwgcGFnZSB0aGF0IGRpc3BsYXlzIHRoZSByZXN1bHRzXG4gICAgICAgICAqIGdlbmVyYXRlZCBvbiB0aGUgZXhlY3V0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPbiBhIHN1Y2Nlc3NmdWwgZXhlY3V0aW9uLCB0aGUgSFRNTCBwYWdlIHdpbGwgZGlzcGxheSB0aGUgZm9sbG93aW5nIGRhdGFcbiAgICAgICAgICogd2hlbiBhdmFpbGFibGUgb24gdGhlIHJlc3BvbnNlOlxuICAgICAgICAgKlxuICAgICAgICAgKiA8dWw+XG4gICAgICAgICAqICAgIDxsaT5SIGNvbnNvbGUgb3V0cHV0PC9saT5cbiAgICAgICAgICogICAgPGxpPlIgd29ya3NwYWNlIG9iamVjdCBkYXRhPC9saT5cbiAgICAgICAgICogICAgPGxpPlIgZ2VuZXJhdGVkIHBsb3RzPC9saT5cbiAgICAgICAgICogICAgPGxpPkxpbmtzIHRvIFIgd29ya2luZyBkaXJlY3RvcnkgYXJ0aWZhY3RzPC9saT5cbiAgICAgICAgICogICAgPGxpPkxpbmtzIHRvIFJlcG9zaXRvcnkgc3RvcmVkIGFydGlmYWN0czwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqXG4gICAgICAgICAqIE9uIGEgZmFpbGVkIGV4ZWN1dGlvbiwgdGhlIEhUTUwgcGFnZSB3aWxsIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAgICAgKiBpbmRpY2F0aW5nIHRoZSBjYXVzZSBvZiB0aGUgZmFpbHVyZSBhbmQgd2hlbiBhdmFpbGFibGUsIFIgY29uc29sZSBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBBUEkgY2FsbCBtYWtlcyBpdCB2ZXJ5IHNpbXBsZSB0byBpbnRlZ3JhdGUgb3V0cHV0cyBnZW5lcmF0ZWQgYnlcbiAgICAgICAgICogUmV2b0RlcGxveVItbWFuYWdlZCBSIHNjcmlwdHMgaW50byBhbnkgdGhpcmQtcGFydHkgYXBwbGljYXRpb24uIEl0IGNhbiBhbHNvXG4gICAgICAgICAqIGJlIHVzZWQgYXMgYSB2ZXJ5IHNpbXBsZSB0ZXN0IGFuZCBkZWJ1Z2dpbmcgYWlkIGZvciBSIHNjcmlwdCBhbmRcbiAgICAgICAgICogYXBwbGljYXRpb24gZGV2ZWxvcGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gZXhlY3V0ZSBhIHNpbmdsZSByZXBvc2l0b3J5LW1hbmFnZWQgc2NyaXB0IHRoZSBjYWxsZXIgbXVzdCBwcm92aWRlXG4gICAgICAgICAqIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGZpbGVuYW1lICwgYXV0aG9yIGFuZCBvcHRpb25hbGx5IHZlcnNpb24gLiBUbyBleGVjdXRlXG4gICAgICAgICAqIGEgY2hhaW4gb2YgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdHMgdGhlIGNhbGxlciBtdXN0IHByb3ZpZGUgYVxuICAgICAgICAgKiBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2YWx1ZXMgb24gdGhlIGZpbGVuYW1lICwgYXV0aG9yIGFuZCBvcHRpb25hbGx5XG4gICAgICAgICAqIHZlcnNpb24gcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gZXhlY3V0ZSBhIHNpbmdsZSBleHRlcm5hbCBzY3JpcHQgdGhlIGNhbGxlciBtdXN0IHByb3ZpZGUgYSB2YWxpZCBVUkwgb3JcbiAgICAgICAgICogZmlsZSBwYXRoIHVzaW5nIHRoZSBleHRlcm5hbHNvdXJjZSBwYXJhbWV0ZXIuIFRvIGV4ZWN1dGUgYSBjaGFpbiBvZlxuICAgICAgICAgKiBleHRlcm5hbCBzY3JpcHRzIHRoZSBjYWxsZXIgbXVzdCBwcm92aWRlIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmFsdWVzXG4gICAgICAgICAqIG9uIHRoZSBleHRlcm5hbHNvdXJjZSBwYXJhbWV0ZXIuIE5vdGUsIHRvIGV4ZWN1dGUgYW4gZXh0ZXJuYWwgc2NyaXB0IHRoZVxuICAgICAgICAgKiBjYWxsZXIgbXVzdCBoYXZlIFBPV0VSX1VTRVIgcHJpdmlsZWdlcyBzbyB0aGlzIGZlYXR1cmUgaXMgbm90IGF2YWlsYWJsZSB0b1xuICAgICAgICAgKiBhbm9ueW1vdXMgdXNlcnMgb24gdGhpcyBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBBIGNoYWluZWQgZXhlY3V0aW9uIGV4ZWN1dGVzIGVhY2ggb2YgdGhlIHNjcmlwdHMgaWRlbnRpZmllZCBvbiB0aGVcbiAgICAgICAgICogY2FsbCBpbiBhIHNlcXVlbnRpYWwgZmFzaGlvbiBvbiB0aGUgUiBzZXNzaW9uLCB3aXRoIGV4ZWN1dGlvbiBvY2N1cmluZyBpblxuICAgICAgICAgKiB0aGUgb3JkZXIgc3BlY2lmaWVkIG9uIHRoZSBwYXJhbWV0ZXIgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogUGxlYXNlIG5vdGUgdGhlIGZvbGxvd2luZyBwcmUgYW5kIHBvc3QgZXhlY3V0aW9uIHBhcmFtZXRlcnM6XG4gICAgICAgICAqXG4gICAgICAgICAqIDxzdHJvbmc+UHJlLWV4ZWN1dGlvbiBwYXJhbWV0ZXJzOjwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8b2w+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIGlucHV0cyBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gcGFzcyBSZXZvRGVwbG95Ui1lbmNvZGVkXG4gICAgICAgICAqICAgICAgIFIgb2JqZWN0IHZhbHVlcyBhcyBpbnB1dHMuIFRoZXNlIGlucHV0cyBhcmUgdHVybmVkIGludG8gUiBvYmplY3RzXG4gICAgICAgICAqICAgICAgIGluIHRoZSB3b3Jrc3BhY2UgYmVmb3JlIHRoZSBleGVjdXRpb24gYmVnaW5zLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBjc3ZpbnB1dHMgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHBhc3MgUiBvYmplY3QgcHJpbWl0aXZlXG4gICAgICAgICAqICAgICAgIHZhbHVlcyBhcyBjb21tYS1zZXBhcmF0ZWQgbmFtZS92YWx1ZSBwYWlycy4gVGhlc2UgaW5wdXRzIGFyZSB0dXJuZWRcbiAgICAgICAgICogICAgICAgaW50byBSIG9iamVjdHMgaW4gdGhlIHdvcmtzcGFjZSBiZWZvcmUgdGhlIGV4ZWN1dGlvbiBiZWdpbnMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHByZWxvYWRmaWxlIHBhcmFtZXRlcnMgYWxsb3dzIHRoZSBjYWxsZXIgdG8gbG9hZCBvbmUgb3IgbW9yZVxuICAgICAgICAgKiAgICAgICBmaWxlcyBmcm9tIHRoZSByZXBvc2l0b3J5IGludG8gdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGJlZm9yZSB0aGVcbiAgICAgICAgICogICAgICAgZXhlY3V0aW9uIGJlZ2lucy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgcHJlbG9hZG9iamVjdCBwYXJhbWV0ZXJzIGFsbG93IHRoZSBjYWxsZXIgdG8gbG9hZCBvbmUgb3IgbW9yZVxuICAgICAgICAgKiAgICAgICBiaW5hcnkgUiBvYmplY3RzICguckRhdGEpIGZyb20gdGhlIHJlcG9zaXRvcnkgaW50byB0aGUgd29ya3NwYWNlXG4gICAgICAgICAqICAgICAgIGJlZm9yZSB0aGUgZXhlY3V0aW9uIGJlZ2lucy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgYWRvcHQgcGFyYW1ldGVycyBhbGxvdyB0aGUgY2FsbGVyIHRvIGxvYWQgYSBwcmUtZXhpc3RpbmdcbiAgICAgICAgICogICAgICAgcHJvamVjdCB3b3Jrc3BhY2UsIHByb2plY3Qgd29ya2luZyBkaXJlY3RvcnkgYW5kL29yIHByb2plY3QgcGFja2FnZVxuICAgICAgICAgKiAgICAgICBkZXBlbmRlbmNpZXMgYmVmb3JlIHRoZSBleGVjdXRpb24gYmVnaW5zLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiA8L29sPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8c3Ryb25nPlBvc3QtZXhlY3V0aW9uIHBhcmFtZXRlcnM6PC9zdHJvbmc+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxvbD5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgcm9iamVjdHMgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHNwZWNpZnkgYSBjb21tYS1zZXBhcmF0ZWRcbiAgICAgICAgICogICAgICAgbGlzdCBvZiBvYmplY3QgbmFtZXMgdGhhdCB3aWxsIGJlIHJldHVybmVkIGFzIFJldm9EZXBsb3lSLWVuY29kZWQgUlxuICAgICAgICAgKiAgICAgICBvYmplY3RzIG9uIHRoZSByZXNwb25zZSBtYXJrdXAgYWZ0ZXIgdGhlIGV4ZWN1dGlvbiBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlZmlsZSBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gc3BlY2lmeSBhIGNvbW1hLXNlcGFyYXRlZFxuICAgICAgICAgKiAgICAgICBsaXN0IG9mIHdvcmtpbmcgZGlyZWN0b3J5IGZpbGVzIHRvIGJlIHN0b3JlZCBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlclxuICAgICAgICAgKiAgICAgICB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVvYmplY3QgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHNwZWNpZnkgYSBjb21tYS1zZXBhcmF0ZWRcbiAgICAgICAgICogICAgICAgbGlzdCBvZiB3b3Jrc3BhY2Ugb2JqZWN0cyB0byBiZSBzdG9yZWQgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGlvbiBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3Jld29ya3NwYWNlIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBzdG9yZSB0aGUgZW50aXJlXG4gICAgICAgICAqICAgICAgIHdvcmtzcGFjZSBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlciB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVkaXJlY3RvcnkgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHNwZWNpZnkgYSB0YXJnZXRcbiAgICAgICAgICogICAgICAgcmVwb3NpdG9yeSBkaXJlY3RvcnkgZm9yIHN0b3JlZCBmaWxlcyBhbmQgb2JqZWN0cyBhZnRlciB0aGUgZXhlY3V0aW9uXG4gICAgICAgICAqICAgICAgIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVuZXd2ZXJzaW9uIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBjcmVhdGUgbmV3XG4gICAgICAgICAqICAgICAgIHZlcnNpb25zIG9mIGVhY2ggc3RvcmVkIGZpbGUgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlIGV4ZWN1dGlvblxuICAgICAgICAgKiAgICAgICBjb21wbGV0ZXMuIEJ5IGRlZmF1bHQsIHN0b3JlZCBmaWxlcyBvdmVyd3JpdGUgYW55IHByZS1leGlzdGluZyBmaWxlXG4gICAgICAgICAqICAgICAgIGJ5IHRoZSBzYW1lIG5hbWUuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlcHVibGljIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBhc3NpZ24gcHVibGljIGFjY2Vzc1xuICAgICAgICAgKiAgICAgICB0byBlYWNoIHN0b3JlZCBmaWxlIGluIHRoZSByZXBvc2l0b3J5IGFmdGVyIHRoZSBleGVjdXRpb24gY29tcGxldGVzLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgVGhlIGluZmluaXR5ICwgbmFuIGFuZCBlbmNvZGVEYXRhRnJhbWVQcmltaXRpdmVBc1ZlY3RvciBwYXJhbWV0ZXJzXG4gICAgICAgICAqICAgICAgYWxsb3cgdGhlIGNhbGxlciB0byBjb250cm9sIGhvdyBSZXZvRGVwbG95Ui1lbmNvZGVkIFIgb2JqZWN0IGRhdGEgaXNcbiAgICAgICAgICogICAgICBlbmNvZGVkIGluIHRoZSByZXNwb25zZSBtYXJra3VwLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiA8L29sPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8c3Ryb25nPlNvbWUga2V5IGRhdGEgaW5kaWNhdGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXAgb24gdGhpcyBjYWxsOjwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8b2w+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgY29uc29sZSAtIGluZGljYXRlcyB0aGUgUiBjb25zb2xlIG91dHB1dCByZXN1bHRpbmcgZnJvbSB0aGUgZXhlY3V0aW9uXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgcmVzdWx0cyAtIGluZGljYXRlcyB0aGUgbGlzdCBvZiBmaWxlcyBnZW5lcmF0ZWQgYnkgdGhlIFIgZ3JhcGhpY3NcbiAgICAgICAgICogICAgICAgZGV2aWNlXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgYXJ0aWZhY3RzIC0gaW5kaWNhdGVzIHRoZSBsaXN0IG9mIGZpbGVzIGdlbmVyYXRlZCBvciBtb2RpZmllZCBpbiB0aGVcbiAgICAgICAgICogICAgICAgd29ya2luZyBkaXJlY3RvcnlcbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBvYmplY3RzIC0gIGluZGljYXRlcyB0aGUgbGlzdCBvZiBSIG9iamVjdHMgcmV0dXJuZWQgZnJvbSB0aGVcbiAgICAgICAgICogICAgICAgd29ya3NwYWNlXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgZmlsZXMgLSBpbmRpY2F0ZXMgdGhlIGxpc3Qgb2YgZmlsZXMgYW5kIG9iamVjdHMgc3RvcmVkIGluIHRoZVxuICAgICAgICAgKiAgICAgICByZXBvc2l0b3J5IGFmdGVyIHRoZSBleGVjdXRpb24gY29tcGxldGVzXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgaW50ZXJydXB0ZWQgLSBpbmRpY2F0ZXMgdGhlIGludGVycnVwdGVkIHN0YXR1cyBvZiBleGVjdXRpb25cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBlcnJvciAtIG9uIGZhaWx1cmUsIGluZGljYXRlcyB0aGUgcmVhc29uIGZvciBmYWlsdXJlXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgZXJyb3JDb2RlIC0gb24gZmFpbHVyZSwgaW5kaWNhdGVzIHRoZSBlcnJvciBjb2RlIGZvciBmYWlsdXJlXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqIDwvb2w+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVwb3NpdG9yeVNjcmlwdFJlbmRlclxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PnByb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBwcm9qZWN0IGlkZW50aWZpZXI8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdFxuICAgICAgICAgKiAgICAgICBmaWxlbmFtZXNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiByZXBvc2l0b3J5LW1hbmFnZWQgZGlyZWN0b3JpZXMgZm9yXG4gICAgICAgICAqICAgICAgIHNjcmlwdHMsIGRlZmF1bHRzIHRvIHJvb3RcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhdXRob3JzLCBvbmUgYXV0aG9yIHBlciBmaWxlbmFtZVxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2ZXJzaW9ucywgb25lIHZlcnNpb24gcGVyIGZpbGVuYW1lXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5leHRlcm5hbHNvdXJjZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBVUkxzIG9yIGZpbGUgcGF0aHMgdG8gZXh0ZXJuYWxcbiAgICAgICAgICogICAgICAgc2NyaXB0c1xuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+aW5wdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgUmV2b0RlcGxveVItZW5jb2RlZCBzY3JpcHQgaW5wdXRzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmNzdmlucHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHByaW1pdGl2ZSBuYW1lL3ZhbHVlIGlucHV0czwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2FkZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiByZXBvc2l0b3J5IGZpbGVuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2FkZmlsZWF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGF1dGhvcnMsIGF1dGhvci1wZXItcHJlbG9hZGZpbGVuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRmaWxldmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZlcnNpb25zLCB2ZXJzaW9uLXBlci1wcmVsb2FkZmlsZW5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdG5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiByZXBvc2l0b3J5IG9iamVjdCAoLnJEYXRhKSBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdGF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGF1dGhvcnMsIGF1dGhvci1wZXItcHJlbG9hZG9iamVjdG5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZG9iamVjdHZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2ZXJzaW9ucywgdmVyc2lvbi1wZXItb2JqZWN0LXByZWxvYWRvYmplY3RuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmFkb3B0d29ya3NwYWNlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWRlbnRpZmllcyBwcm9qZWN0IGZyb20gd2hpY2ggd29ya3NwYWNlIGlzIHRvIGJlIGFkb3B0ZWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+YWRvcHRkaXJlY3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZGVudGlmaWVzIHByb2plY3QgZnJvbSB3aGljaCBkaXJlY3RvcnkgaXMgdG8gYmUgYWRvcHRlZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5hZG9wdHBhY2thZ2VzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWRlbnRpZmllcyBwcm9qZWN0IGZyb20gd2hpY2ggcGFja2FnZSBkZXBlbmRlbmNpZXMgYXJlIHRvIGJlIGFkb3B0ZWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5ibGFja2JveDwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIGV4ZWN1dGlvbiB3aWxsIG9jY3VyIG9uIHRoZSBIVFRQIGJsYWNrYm94IHByb2plY3QgZm9yIHRoZSBjdXJyZW50IEhUVFAgc2Vzc2lvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PnJlY3ljbGU8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHJlY3ljbGVzIHRoZSBSIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBIVFRQIGJsYWNrYm94IHByb2plY3Qgb24gdGhlIGN1cnJlbnQgSFRUUCBzZXNzaW9uPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnRhZzwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBhIHRhZyB0aGF0IGxhYmVscyB0aGUgZXhlY3V0aW9uPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmVjaG9vZmY8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlIFIgY29tbWFuZHMgd2lsbCBub3QgYXBwZWFyIGluIHRoZSBjb25zb2xlIG91dHB1dDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5jb25zb2xlb2ZmPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSBjb25zb2xlIG91dHB1dCBpcyBub3QgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlIG1hcmt1cDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5ncmFwaGljczwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBwcmVmZXJyZWQgUiBncmFwaGljcyBkZXZpY2UgZm9yIGV4ZWN1dGlvbjogcG5nIG9yIHN2ZzwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5ncmFwaGljc3dpZHRoPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHByZWZlcnJlZCB3aWR0aCBmb3IgUiBncmFwaGljcyBkZXZpY2UgaW1hZ2VzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmdyYXBoaWNzaGVpZ2h0PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHByZWZlcnJlZCBoZWlnaHQgZm9yIFIgZ3JhcGhpY3MgZGV2aWNlIGltYWdlczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5yb2JqZWN0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG9iamVjdHMgZm9yIHJldHJpZXZhbCBmb2xsb3dpbmcgdGhlIGV4ZWN1dGlvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zdG9yZWZpbGU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB3b3JraW5nIGRpcmVjdG9yeSBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c3RvcmVvYmplY3Q8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB3b3Jrc3BhY2Ugb2JqZWN0IG5hbWVzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnN0b3Jld29ya3NwYWNlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgZmlsZW5hbWUgKC5yRGF0YSkgd2hlcmUgd29ya3NwYWNlIGNvbnRlbnRzIHdpbGwgYmUgc2F2ZWQgaW4gdGhlIHJlcG9zaXRvcnk8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c3RvcmVuZXd2ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIGVuc3VyZXMgZWFjaCBmaWxlIHN0b3JlZCBpbiByZXBvc2l0b3J5IHJlc3VsdHMgaW4gbmV3IHZlcnNpb24gYmVpbmcgY3JlYXRlZCBpZiBuZWVkZWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c3RvcmVwdWJsaWM8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgcHVibGlzaGVzIGVhY2ggZmlsZSBzdG9yZWQgaW4gdGhlIHJlcG9zaXRvcnk8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+aW5maW5pdHk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgc3BlY2lmaWVzIGN1c3RvbSB2YWx1ZSBmb3IgSW5maW5pdHkgYXBwZWFyaW5nIGluIFIgb2JqZWN0XG4gICAgICAgICAqICAgICAgIGRhdGEgcmV0dXJuZWQgb24gY2FsbCwgb3RoZXJ3aXNlIEluZmluaXR5IGlzIHJlcHJlc2VudGVkIGJ5XG4gICAgICAgICAqICAgICAgIDB4N2ZmMDAwMDAwMDAwMDAwMExcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5hbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgY3VzdG9tIHZhbHVlIGZvciBOYU4gYXBwZWFyaW5nIGluIFIgb2JqZWN0IGRhdGFcbiAgICAgICAgICogICAgICAgcmV0dXJuZWQgb24gY2FsbCwgb3RoZXJ3aXNlIE5hTiBpcyByZXByZXNlbnRlZCBieSBudWxsXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5lbmNvZGVEYXRhRnJhbWVQcmltaXRpdmVBc1ZlY3RvcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiB0cnVlLCBkYXRhLmZyYW1lIHByaW1pdGl2ZXMgYXJlIGVuY29kZWQgdmVjdG9ycyBpbiBSXG4gICAgICAgICAqICAgICAgIG9iamVjdCBkYXRhIHJldHVybmVkIG9uIGNhbGxcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByZXBvc2l0b3J5U2NyaXB0UmVuZGVyOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcmVwb3NpdG9yeS9zY3JpcHQvcmVuZGVyJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBpbnRlcnJ1cHRzIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBvbiB0aGUgSFRUUCBCbGFja2JveCBwcm9qZWN0XG4gICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBIVFRQIHNlc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVwb3NpdG9yeVNjcmlwdEludGVycnVwdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeVNjcmlwdEludGVycnVwdDogZnVuY3Rpb24oY2FsbGJhY2spIHsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L3NjcmlwdC9pbnRlcnJ1cHQnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vIFJlcG9zaXRvcnkgRmlsZSBBUElzXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGxpc3RzIHJlcG9zaXRvcnktbWFuYWdlZCBmaWxlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXBvc2l0b3J5RmlsZXRMaXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgd2hlbiBzcGVjaWZpZWQsIGNhbGwgcmV0dXJucyBsaXN0IG9mIHNjcmlwdCB2ZXJzaW9ucyBmb3JcbiAgICAgICAgICogICAgICAgZmlsZW5hbWVcbiAgICAgICAgICogICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlcG9zaXRvcnkgZGlyZWN0b3J5LCBkZWZhdWx0cyB0byByb290XG4gICAgICAgICAqICAgICAgIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnNoYXJlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgZmlsZXMgdGhhdCBhcmUgcmVzdHJpY3RlZCBidXRcbiAgICAgICAgICogICAgICAgdmlzaWJsZSBvciBzaGFyZWQgYnkgb3RoZXIgdXNlcnMgYXJlIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnB1Ymxpc2hlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgc2NyaXB0cyBwdWJsaXNoZWQgYnkgb3RoZXIgdXNlcnMgYXJlXG4gICAgICAgICAqICAgICAgIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmNhdGVnb3J5RmlsdGVyPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHdoZW4gc3BlY2lmaWVkIGxpc3Qgb2YgZmlsZXMgaW4gcmVzcG9uc2UgbWFya3VwIGlzIGxpbWl0ZWRcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByZXBvc2l0b3J5RmlsZUxpc3Q6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2ZpbGUvbGlzdCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIHVwbG9hZHMgYSBmaWxlIGZyb20gdGhlIHVzZXIncyBjb21wdXRlciB0byB0aGUgcmVwb3NpdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXBvc2l0b3J5RmlsZVVwbG9hZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PmZpbGVuYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyBuYW1lIG9mIHRoZSBmaWxlIHRvIHVwbG9hZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWxlPC9kdD5cbiAgICAgICAgICogICAgPGRkPi4uLmZpbGUgY29udGVudC4uLjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXNjcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBhIGRlc2NyaXB0aW9uIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB1cGxvYWRlZCBmaWxlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD50YWdzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRhZyB3b3JkcyB0byBhc3NvY2lhdGUgd2l0aCB0aGUgcmVwb3NpdG9yeSBmaWxlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJlc3RyaWN0ZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSAob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJvbGUgbmFtZXMsIHdoaWNoIG1ha2VzIHRoZSBmaWxlIHZpc2libGUgdG8gYXV0aGVudGljYXRlZCB1c2VycyB3aXRoIHRoZXNlIHJvbGVzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIDxkdD5zaGFyZWQ8L2R0PlxuICAgICAgICAgKiAgICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIGZpbGUgd2lsbCBiZSBzaGFyZWQgd2hpY2ggbWFrZXMgdGhlIGZpbGUgdmlzaWJsZSB0byBhdXRoZW50aWNhdGVkIHVzZXJzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnB1Ymxpc2hlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBmaWxlIHdpbGwgYmUgcHVibGlzaGVkIHdoaWNoIG1ha2VzIHRoZSBmaWxlIHZpc2libGUgdG8gYXV0aGVudGljYXRlZCBhbmQgYW5vbnltb3VzIHVzZXJzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5ld3ZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgcmVwb3NpdG9yeSB3aWxsIGNyZWF0ZSBuZXcgdmVyc2lvbiByYXRoZXIgdGhhbiBvdmVyd3JpdGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+bmV3dmVyc2lvbm1zZzwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIG5ld3ZlcnNpb24gaXMgdHJ1ZSwgbWVzc2FnZSB0byBhc3NvY2lhdGUgd2l0aCBuZXcgdmVyc2lvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5pbnB1dHM8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIGlucHV0cyBwcm9wZXJ0eSBvbiBhIHJlcG9zaXRvcnktbWFuYWdlZCBzY3JpcHQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+b3V0cHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgb3V0cHV0cyBwcm9wZXJ0eSBvbiBhIHJlcG9zaXRvcnktbWFuYWdlZCBzY3JpcHQ8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcG9zaXRvcnlGaWxlVXBsb2FkOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25maWcuZm9ybWF0ID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICB2YXIgaW9Db25maWcgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogY29uZmlnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgZm9ybToge1xuICAgICAgICAgICAgICAgICAgICBpZDogY29uZmlnLmZvcm1JZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IGNhbGxiYWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZmlsZS91cGxvYWQnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIHRyYW5zZmVycyBhIGZpbGUgZnJvbSBhIFVSTCB0byB0aGUgcmVwb3NpdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXBvc2l0b3J5RmlsZVRyYW5zZmVyXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIG5hbWUgb2YgdGhlIGZpbGUgdG8gdXBsb2FkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnVybDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgYSB1cmwgb2YgdGhlIGZpbGUgdG8gdXBsb2FkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXNjcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBhIGRlc2NyaXB0aW9uIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB1cGxvYWRlZCBmaWxlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnRhZ3M8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGFnIHdvcmRzIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSByZXBvc2l0b3J5IGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cmVzdHJpY3RlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygcm9sZSBuYW1lcywgd2hpY2ggbWFrZXMgdGhlIGZpbGUgdmlzaWJsZSB0byBhdXRoZW50aWNhdGVkIHVzZXJzIHdpdGggdGhlc2Ugcm9sZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgPGR0PnNoYXJlZDwvZHQ+XG4gICAgICAgICAqICAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgZmlsZSB3aWxsIGJlIHNoYXJlZCB3aGljaCBtYWtlcyB0aGUgZmlsZSB2aXNpYmxlIHRvIGF1dGhlbnRpY2F0ZWQgdXNlcnM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHVibGlzaGVkPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIGZpbGUgd2lsbCBiZSBwdWJsaXNoZWQgd2hpY2ggbWFrZXMgdGhlIGZpbGUgdmlzaWJsZSB0byBhdXRoZW50aWNhdGVkIGFuZCBhbm9ueW1vdXMgdXNlcnM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+bmV3dmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSByZXBvc2l0b3J5IHdpbGwgY3JlYXRlIG5ldyB2ZXJzaW9uIHJhdGhlciB0aGFuIG92ZXJ3cml0ZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5uZXd2ZXJzaW9ubXNnPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgbmV3dmVyc2lvbiBpcyB0cnVlLCBtZXNzYWdlIHRvIGFzc29jaWF0ZSB3aXRoIG5ldyB2ZXJzaW9uPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmlucHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgaW5wdXRzIHByb3BlcnR5IG9uIGEgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5vdXRwdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBvdXRwdXRzIHByb3BlcnR5IG9uIGEgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeUZpbGVUcmFuc2ZlcjogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZmlsZS90cmFuc2ZlcicsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgd3JpdGVzIGEgdGV4dCBmaWxlIHRvIHRoZSByZXBvc2l0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlGaWxlV3JpdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgbmFtZSBvZiB0aGUgZmlsZSB0byB1cGxvYWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dGV4dDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5zcGVjaWZpZXMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZmlsZSB0byB1cGxvYWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlcG9zaXRvcnkgZGlyZWN0b3J5LCBkZWZhdWx0cyB0byByb290XG4gICAgICAgICAqICAgICAgIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRlc2NyPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyBhIGRlc2NyaXB0aW9uIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB1cGxvYWRlZFxuICAgICAgICAgKiAgICAgICBmaWxlXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD50YWdzPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0YWcgd29yZHMgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHJlcG9zaXRvcnkgZmlsZVxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cmVzdHJpY3RlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSAob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJvbGUgbmFtZXMsIHdoaWNoIG1ha2VzXG4gICAgICAgICAqICAgICAgIHRoZSBmaWxlIHZpc2libGUgdG8gYXV0aGVudGljYXRlZCB1c2VycyB3aXRoIHRoZXNlIHJvbGVzXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zaGFyZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiB0cnVlLCBpbGUgaXMgc2hhcmVkIGFuZCB2aXNpYmxlIHRvIGF1dGhlbnRpY2F0ZWQgdXNlcnNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnB1Ymxpc2g8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIGZpbGUgd2lsbCBiZSBwdWJsaXNoZWQgd2hpY2ggbWFrZXMgdGhlIGZpbGVcbiAgICAgICAgICogICAgICAgdmlzaWJsZSB0byBhdXRoZW50aWNhdGVkIGFuZCBhbm9ueW1vdXMgdXNlcnNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5ld3ZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIHJlcG9zaXRvcnkgd2lsbCBjcmVhdGUgbmV3IHZlcnNpb24gcmF0aGVyXG4gICAgICAgICAqICAgICAgIHRoYW4gb3ZlcndyaXRlXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5uZXd2ZXJzaW9ubXNnPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIG5ld3ZlcnNpb24gaXMgdHJ1ZSwgbWVzc2FnZSB0byBhc3NvY2lhdGUgd2l0aCBuZXdcbiAgICAgICAgICogICAgICAgdmVyc2lvblxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+aW5wdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgaW5wdXRzIHByb3BlcnR5IG9uIGEgcmVwb3NpdG9yeS1tYW5hZ2VkXG4gICAgICAgICAqICAgICAgIHNjcmlwdFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+b3V0cHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIG91dHB1dHMgcHJvcGVydHkgb24gYSByZXBvc2l0b3J5LW1hbmFnZWRcbiAgICAgICAgICogICAgICAgc2NyaXB0XG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeUZpbGVXcml0ZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZmlsZS93cml0ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgdXBkYXRlcyB0aGUgcHJvcGVydGllcyBvbiBhIHJlcG9zaXRvcnktbWFuYWdlZCBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlGaWxlVXBkYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIG5hbWUgb2YgdGhlIGZpbGUgdG8gdXBsb2FkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXNjcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBhIGRlc2NyaXB0aW9uIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB1cGxvYWRlZCBmaWxlPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnRhZ3M8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGFnIHdvcmRzIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSByZXBvc2l0b3J5IGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cmVzdHJpY3RlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSAob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJvbGUgbmFtZXMsIHdoaWNoIG1ha2VzXG4gICAgICAgICAqICAgICAgIHRoZSBmaWxlIHZpc2libGUgdG8gYXV0aGVudGljYXRlZCB1c2VycyB3aXRoIHRoZXNlIHJvbGVzXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICA8ZHQ+c2hhcmVkPC9kdD5cbiAgICAgICAgICogICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSBmaWxlIHdpbGwgYmUgc2hhcmVkIHdoaWNoIG1ha2VzIHRoZSBmaWxlIHZpc2libGUgdG8gYXV0aGVudGljYXRlZCB1c2VyczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wdWJsaXNoZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgZmlsZSB3aWxsIGJlIHB1Ymxpc2hlZCB3aGljaCBtYWtlcyB0aGUgZmlsZSB2aXNpYmxlIHRvIGF1dGhlbnRpY2F0ZWQgYW5kIGFub255bW91cyB1c2VyczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5pbnB1dHM8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIGlucHV0cyBwcm9wZXJ0eSBvbiBhIHJlcG9zaXRvcnktbWFuYWdlZCBzY3JpcHQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+b3V0cHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgb3V0cHV0cyBwcm9wZXJ0eSBvbiBhIHJlcG9zaXRvcnktbWFuYWdlZCBzY3JpcHQ8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcG9zaXRvcnlGaWxlVXBkYXRlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcmVwb3NpdG9yeS9maWxlL3VwZGF0ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgcmV2ZXJ0cyB0aGUgY3VycmVudCB3b3JraW5nIGNvcHkgb2YgYSBmaWxlIHRvIGEgc3BlY2lmaWMgdmVyc2lvblxuICAgICAgICAgKiBmb3VuZCBpbiB0aGUgZmlsZXMgdmVyc2lvbiBoaXN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlGaWxlUmV2ZXJ0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIG5hbWUgb2YgdGhlIGZpbGUgdG8gdXBsb2FkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IGZpbGUgdmVyc2lvbiB0byByZXZlcnQgaW50byB0aGUgY3VycmVudCB3b3JraW5nIGNvcHk8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlcG9zaXRvcnkgZGlyZWN0b3J5LCBkZWZhdWx0cyB0byByb290XG4gICAgICAgICAqICAgICAgIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRlc2NyPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIGEgZGVzY3JpcHRpb24gdG8gYXNzb2NpYXRlIHdpdGggdGhlIHVwbG9hZGVkIGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cmVzdHJpY3RlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygcm9sZSBuYW1lcywgd2hpY2ggbWFrZXMgdGhlIGZpbGUgdmlzaWJsZSB0byBhdXRoZW50aWNhdGVkIHVzZXJzIHdpdGggdGhlc2Ugcm9sZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgPGR0PnNoYXJlZDwvZHQ+XG4gICAgICAgICAqICAgICA8ZGQ+KG9wdGlvbmFsKSBpZiB0cnVlLCB0aGUgZmlsZSB3aWxsIGJlIHNoYXJlZCB3aGljaCBtYWtlcyB0aGUgZmlsZSB2aXNpYmxlIHRvIGF1dGhlbnRpY2F0ZWQgdXNlcnM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHVibGlzaGVkPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgdHJ1ZSwgdGhlIGZpbGUgd2lsbCBiZSBwdWJsaXNoZWQgd2hpY2ggbWFrZXMgdGhlIGZpbGUgdmlzaWJsZSB0byBhdXRoZW50aWNhdGVkIGFuZCBhbm9ueW1vdXMgdXNlcnM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+bmV3dmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIHRydWUsIHRoZSByZXBvc2l0b3J5IHdpbGwgY3JlYXRlIG5ldyB2ZXJzaW9uIHJhdGhlciB0aGFuIG92ZXJ3cml0ZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5uZXd2ZXJzaW9ubXNnPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgbmV3dmVyc2lvbiBpcyB0cnVlLCBtZXNzYWdlIHRvIGFzc29jaWF0ZSB3aXRoIG5ldyB2ZXJzaW9uPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmlucHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgaW5wdXRzIHByb3BlcnR5IG9uIGEgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5vdXRwdXRzPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBvdXRwdXRzIHByb3BlcnR5IG9uIGEgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeUZpbGVSZXZlcnQ6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2ZpbGUvcmV2ZXJ0JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBnZW5lcmF0ZXMgYSBkaWZmIGJldHdlZW4gdGhlIGN1cnJlbnQgd29ya2luZyBjb3B5IG9mIGEgZmlsZSBhbmRcbiAgICAgICAgICogYSBzcGVjaWZpYyB2ZXJzaW9uIGZvdW5kIGluIHRoZSBmaWxlcyB2ZXJzaW9uIGhpc3RvcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVwb3NpdG9yeUZpbGVEaWZmXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IGZpbGUgbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5hdXRob3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IGZpbGUgYXV0aG9yPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIHNwZWNpZmllcyB0aGUgcmVwb3NpdG9yeSBmaWxlIHZlcnNpb24gdG8gZGlmZiBhZ2FpbnN0IHRoZSBjdXJyZW50XG4gICAgICAgICAqICAgICAgIHdvcmtpbmcgY29weVxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlcG9zaXRvcnkgZGlyZWN0b3J5LCBkZWZhdWx0cyB0byByb290XG4gICAgICAgICAqICAgICAgIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByZXBvc2l0b3J5RmlsZURpZmY6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2ZpbGUvZGlmZicsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgZ3JhbnRzIG93bmVyc2hpcCByaWdodHMgb24gYSBmaWxlIHRvIG9uZSBvciBtb3JlIGF1dGhlbnRpY2F0ZWRcbiAgICAgICAgICogdXNlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUsIHVubGlrZSBtb3N0IHJlcG9zaXRvcnkgQVBJcyB0aGF0IHJlcXVpcmUgYm90aCBmaWxlbmFtZSBhbmQgYXV0aG9yXG4gICAgICAgICAqIHBhcmFtZXRlcnMsIHRoZXJlIGlzIG5vIGV4cGxpY2l0IGF1dGhvciBwYXJhbWV0ZXIgb24gdGhpcyBjYWxsLiBUaGUgYXV0aG9yXG4gICAgICAgICAqIGlzIHVuZGVyc3Rvb2QgdG8gYmUgdGhlIGNhbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXBvc2l0b3J5RmlsZUdyYW50XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+c3BlY2lmaWVzIHRoZSBuYW1lIG9mIHRoZSByZXBvc2l0b3J5IGZpbGU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+bmV3YXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPiBzcGVjaWZpZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBncmFudGVlIHVzZXJuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5yZXZva2VhdXRob3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgc3BlY2lmaWVzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmV2b2tlZSB1c2VybmFtZXNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcG9zaXRvcnlGaWxlR3JhbnQ6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2ZpbGUvZ3JhbnQnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGRvd25sb2FkcyBhIHJlcG9zaXRvcnktbWFuYWdlZCBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlGaWxlRG93bmxvYWRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgICAgPGR0PmZpbGVuYW1lPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+c3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IGZpbGUgbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPnNwZWNpZmllcyB0aGUgcmVwb3NpdG9yeSBhdXRob3I8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlcG9zaXRvcnkgZGlyZWN0b3J5LCBkZWZhdWx0cyB0byByb290XG4gICAgICAgICAqICAgICAgIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+dmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IGZpbGUgdmVyc2lvbjwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeUZpbGVEb3dubG9hZDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZmlsZS9kb3dubG9hZCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgZGVsZXRlcyBhIGZpbGUgZnJvbSB0aGUgcmVwb3NpdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXBvc2l0b3J5RmlsZURlbGV0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD5zcGVjaWZpZXMgdGhlIHJlcG9zaXRvcnkgZmlsZSBuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeUZpbGVEZWxldGU6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2ZpbGUvZGVsZXRlJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBmZXRjaGVzIHRoZSBsYXRlc3QgbWV0YS1kYXRhIG9uIGEgZmlsZSBpbiB0aGUgcmVwb3NpdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXBvc2l0b3J5RmlsZUZldGNoXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPnNwZWNpZmllcyB0aGUgcmVwb3NpdG9yeSBmaWxlIG5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+YXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgcmVwb3NpdG9yeSBmaWxlIGF1dGhvclxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlcG9zaXRvcnkgZGlyZWN0b3J5LCBkZWZhdWx0cyB0byByb290XG4gICAgICAgICAqICAgICAgIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IGZpbGUgdmVyc2lvblxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcG9zaXRvcnlGaWxlRmV0Y2g6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2ZpbGUvZmV0Y2gnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGNvcGllcyBvbmUgb3IgbW9yZSByZXBvc2l0b3J5LW1hbmFnZWQgZmlsZXMgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICAgICAqIGRpcmVjdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGRlc3RpbmF0aW9uIGRpcmVjdG9yeSBhbHJlYWR5IGNvbnRhaW5zIGEgZmlsZW5hbWUgbWF0Y2hpbmcgYW5cbiAgICAgICAgICogaW5jb21pbmcgZmlsZW5hbWUsIHRoZW4gYSBuZXcgdmVyc2lvbiBvZiB0aGUgZmlsZSBpcyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVwb3NpdG9yeUZpbGVDb3B5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPnNwZWNpZmllcyB0aGUgcmVwb3NpdG9yeSBmaWxlIG5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlcG9zaXRvcnkgZGlyZWN0b3J5LCBkZWZhdWx0cyB0byByb290XG4gICAgICAgICAqICAgICAgIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRlc3RpbmF0aW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgbmFtZSBvZiB0aGUgZGVzdGluYXRpb24gdXNlciBkaXJlY3RvcnkgaW5cbiAgICAgICAgICogICAgICAgdGhlIHJlcG9zaXRvcnlcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSByZXBvc2l0b3J5IGZpbGUgdmVyc2lvblxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZXJlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBuZXcgZmlsZW5hbWVzIGZvciBjb3BpZWQgZmlsZXNcbiAgICAgICAgICogICAgICAgaWRlbnRpZmllZCBvbiBmaWxlbmFtZSBwYXJhbWV0ZXJcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByZXBvc2l0b3J5RmlsZUNvcHk6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2ZpbGUvY29weScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgbW92ZXMgb25lIG9yIG1vcmUgcmVwb3NpdG9yeS1tYW5hZ2VkIGZpbGVzIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAgICAgKiBkaXJlY3RvcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBkZXN0aW5hdGlvbiBkaXJlY3RvcnkgYWxyZWFkeSBjb250YWlucyBhIGZpbGVuYW1lIG1hdGNoaW5nIGFuXG4gICAgICAgICAqIGluY29taW5nIGZpbGVuYW1lLCB0aGVuIGEgbmV3IHZlcnNpb24gb2YgdGhlIGZpbGUgaXMgYXV0b21hdGljYWxseSBjcmVhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlGaWxlTW92ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD5zcGVjaWZpZXMgdGhlIHJlcG9zaXRvcnkgZmlsZSBuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXN0aW5hdGlvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIGRlc3RpbmF0aW9uIHVzZXIgZGlyZWN0b3J5IGluXG4gICAgICAgICAqICAgICAgIHRoZSByZXBvc2l0b3J5XG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD52ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgcmVwb3NpdG9yeSBmaWxlIHZlcnNpb25cbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByZXBvc2l0b3J5RmlsZU1vdmU6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2ZpbGUvbW92ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gUmVwb3NpdG9yeSBEaXJlY3RvcnkgQVBJc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBsaXN0cyByZXBvc2l0b3J5LW1hbmFnZWQgZGlyZWN0b3JpZXMuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIGEgbGlzdCBvZiB0aGUgY2FsbGVyJ3MgdXNlciBkaXJlY3RvcmllcyAoIHJvb3QgYW5kIGN1c3RvbSApIGFyZVxuICAgICAgICAgKiByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgdXNlcmZpbGVzIHBhcmFtZXRlciBpcyBzcGVjaWZpZWQsIHRoZSBmaWxlcyBpbiBhbGwgb2YgdGhlIGNhbGxlcidzXG4gICAgICAgICAqIHVzZXIgZGlyZWN0b3JpZXMgYXJlIGxpc3RlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwLiBOb3RlLCBkZXBlbmRpbmcgb24gdGhlXG4gICAgICAgICAqIG51bWJlciBvZiBmaWxlcyBvd25lZCBieSB0aGUgY2FsbGVyLCB3aGVuIHRoaXMgcGFyYW1ldGVyIGlzIGVuYWJsZWQgdGhlXG4gICAgICAgICAqIHJlc3BvbnNlIG1hcmt1cCByZXR1cm5lZCBvbiB0aGlzIGNhbGwgY2FuIGJlIGEgdmVyYm9zZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGRpcmVjdG9yeSBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkIHRoZW4gb25seSB0aGUgZmlsZXMgaW4gdGhlXG4gICAgICAgICAqIGRpcmVjdG9yeSBpbmRpY2F0ZWQgYXJlIHJldHVybmVkIGluIHRoZSByZXNwb25zZSBtYXJrdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQgdG8gcmV0dXJuIGZpbGVzIGluIHRoZSBjYWxsZXIncyBhcmNoaXZlZFxuICAgICAgICAgKiBkaXJlY3RvcmllcyBhbmQvb3IgZmlsZXMgaW4gdGhlIFJlc3RyaWN0ZWQgLCBTaGFyZWQgYW5kIFB1YmxpYyBzeXN0ZW1cbiAgICAgICAgICogZGlyZWN0b3JpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IFRoZSBtZXRhZGF0YSBwcm9wZXJ0eSBpbiB0aGUgcmVzcG9uc2UgbWFya3VwIG9uIHRoaXMgY2FsbCBpcyBwcm92aWRlZFxuICAgICAgICAgKiBhcyBhIGNvbnZlbmllbmNlIGZvciBjbGllbnQgYXBwbGljYXRpb24gZGV2ZWxvcGVycy4gSXQgcHJvdmlkZXMgYSBjb21wbGV0ZVxuICAgICAgICAgKiBsaXN0IGZvIHRoZSB1c2VyIGRpcmVjdG9yaWVzIGF2YWlsYWJsZSB0byB0aGUgY3VycmVudCBjYWxsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVwb3NpdG9yeURpcmVjdG9yeUxpc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD51c2VyZmlsZXM8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgc3BlY2lmaWVkLCBmaWxlcyBpbiBhbGwgdXNlciBkaXJlY3RvcmllcyBhcmUgbGlzdGVkIGluXG4gICAgICAgICAqICAgICAgIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5hcmNoaXZlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiB0cnVlLCBmaWxlcyBmb3VuZCBpbiBhcmNoaXZlZCBkaXJlY3RvcmllcyBhcmUgaW5jbHVkZWRcbiAgICAgICAgICogICAgICAgaW4gdGhlIHJlc3BvbnNlIG1hcmt1cFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c2hhcmVkPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIHRydWUsIGZpbGVzIHRoYXQgYXJlIHJlc3RyaWN0ZWQgYnV0IHZpc2libGUgb3Igc2hhcmVkXG4gICAgICAgICAqICAgICAgIGJ5IG90aGVyIHVzZXJzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wdWJsaXNoZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgdHJ1ZSwgZmlsZXMgdGhhdCBhcmUgcHVibGlzaGVkIGJ5IG90aGVyIHVzZXJzIGFyZVxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeURpcmVjdG9yeUxpc3Q6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2RpcmVjdG9yeS9saXN0JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBjcmVhdGVzIGEgcmVwb3NpdG9yeS1tYW5hZ2VkIGN1c3RvbSBkaXJlY3RvcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBuYW1lIG9mIHRoZSBuZXcgY3VzdG9tIGRpcmVjdG9yeSBpcyBhbHJlYWR5IGluIHVzZSBieSB0aGUgY2FsbGVyIHRoZVxuICAgICAgICAgKiByZXNwb25zZSBtYXJrdXAgd2lsbCBpbmRpY2F0ZSBhbiBhcHByb3ByaWF0ZSBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXBvc2l0b3J5RGlyZWN0b3J5TGlzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeURpcmVjdG9yeUNyZWF0ZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykgeyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZGlyZWN0b3J5L2NyZWF0ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgcmVuYW1lcyBhbiBleGlzdGluZyByZXBvc2l0b3J5LW1hbmFnZWQgdXNlciBkaXJlY3RvcnlcbiAgICAgICAgICogKCBjdXN0b20gb3IgYXJjaGl2ZWQgKS4gV2hlbiByZW5hbWluZyBhIHVzZXIgZGlyZWN0b3J5LCBhbGwgZmlsZXMgaW4gdGhlXG4gICAgICAgICAqIHNvdXJjZSBkaXJlY3RvcnkgYXJlIGF1dG9tYXRpY2FsbHkgbW92ZWQgdG8gdGhlIGRlc3RpbmF0aW9uIGRpcmVjdG9yeS4gSWZcbiAgICAgICAgICogdGhlIGRlc3RpbmF0aW9uIGRpcmVjdG9yeSBhbHJlYWR5IGV4aXN0cyB0aGUgY2FsbCB3aWxsIGJlIHJlamVjdGVkIGFuZCB0aGVcbiAgICAgICAgICogcmVzcG9uc2UgbWFya3VwIHdpbGwgaW5kaWNhdGUgYW4gYXBwcm9wcmlhdGUgZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gdXNlIHRoaXMgY2FsbCB0byBjb252ZXJ0IGFuIGFyY2hpdmVkIGRpcmVjdG9yeSBiYWNrIGludG8gYSBjdXN0b21cbiAgICAgICAgICogZGlyZWN0b3J5LCBlc3NlbnRpYWxseSB1bmFyY2hpdmluZyB0aGUgYXJjaGl2ZWQgZGlyZWN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBZb3UgY2FuIG5vdCByZW5hbWUgdGhlIHJvb3QgZGlyZWN0b3J5LiBUbyBtb3ZlIGZpbGVzIGZyb20gdGhlIHJvb3RcbiAgICAgICAgICogZGlyZWN0b3J5IHVzZSB0aGUgL3IvcmVwb3NpdG9yeS9kaXJlY3RvcnkvbW92ZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8c3Ryb25nPkltcG9ydGFudDo8L3N0cm9uZz5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBjYWxsIHdpbGwgb25seSBtb3ZlIGZpbGVzIHRoYXQgYXJlIG93bmVkIGJ5IGEgc2luZ2xlIGF1dGhvciB0byB0aGVcbiAgICAgICAgICogZGVzdGluYXRpb24gZGlyZWN0b3J5LiBJZiBhIHJlcG9zaXRvcnktbWFuYWdlZCBmaWxlIGluIHRoZSBzb3VyY2UgZGlyZWN0b3J5XG4gICAgICAgICAqIGhhcyBtdWx0aXBsZSBhdXRob3JzLCBhcyBhIHJlc3VsdCBvZiBjb2xsYWJvcmF0aW9uIHVzaW5nIHRoZVxuICAgICAgICAgKiAvci9yZXBvc2l0b3J5L2ZpbGUvZ3JhbnQgY2FsbCwgdGhlIGZpbGUgd2lsbCBub3QgYmUgbW92ZWQgdG8gdGhlXG4gICAgICAgICAqIGRlc3RpbmF0aW9uIGRpcmVjdG9yeSBhbmQgYSB3YXJuaW5nIHRvIHRoYXQgYWZmZWN0IHdpbGwgYmUgaW5kaWNhdGVkIGluIHRoZVxuICAgICAgICAgKiByZXNwb25zZSBtYXJrdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVwb3NpdG9yeURpcmVjdG9yeVJlbmFtZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXN0aW5hdGlvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIG5ldyBuYW1lIGZvciB0aGUgZGVzdGluYXRpb24gY3VzdG9tIGRpcmVjdG9yeVxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcG9zaXRvcnlEaXJlY3RvcnlSZW5hbWU6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHsgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZGlyZWN0b3J5L3JlbmFtZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBcbiAgICAgICAgICogVGhpcyBjYWxsIGNvcGllcyBvbmUgb3IgbW9yZSByZXBvc2l0b3J5LW1hbmFnZWQgZmlsZXMgZnJvbSBhIHNvdXJjZSB1c2VyXG4gICAgICAgICAqIGRpcmVjdG9yeSB0byBhIGRlc3RpbmF0aW9uIHVzZXIgZGlyZWN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZmlsZW5hbWUgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCwgb25seSB0aG9zZSBmaWxlcyBpbmRpY2F0ZWQgb24gdGhhdFxuICAgICAgICAgKiBwYXJhbWV0ZXIgYXJlIGNvcGllZC4gT3RoZXJ3aXNlLCBhbGwgZmlsZXMgaW4gdGhlIHNvdXJjZSBkaXJlY3RvcnkgYXJlXG4gICAgICAgICAqIGNvcGllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gZW5zdXJlIGNvcHlpbmcgZmlsZXMgZG9lcyBub3QgYWNjaWRlbnRhbGx5IG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgZmlsZXNcbiAgICAgICAgICogaW4gdGhlIGRlc3RpbmF0aW9uIGRpcmVjdG9yeSwgYWxsIGNvcGllZCBmaWxlcyBhcmUgY3JlYXRlZCBhcyBuZXcgdmVyc2lvbnNcbiAgICAgICAgICogaW4gdGhlIGRlc3RpbmF0aW9uIGRpcmVjdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXBvc2l0b3J5RGlyZWN0b3J5Q29weVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXN0aW5hdGlvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIG5ldyBuYW1lIGZvciB0aGUgZGVzdGluYXRpb24gY3VzdG9tIGRpcmVjdG9yeVxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmlsZW5hbWVzIHRvIGJlIGNvcGllZC4gSWYgb21pdHRlZCxcbiAgICAgICAgICogICAgICAgYWxsIGZpbGVzIGluIHRoZSBzb3VyY2UgZGlyZWN0b3J5IGFyZSBjb3BpZWRcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmZpbGVyZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbmV3IGZpbGVuYW1lcyBmb3IgY29waWVkIGZpbGVzXG4gICAgICAgICAqICAgICAgIGlkZW50aWZpZWQgb24gZmlsZW5hbWUgcGFyYW1ldGVyXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeURpcmVjdG9yeUNvcHk6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9yZXBvc2l0b3J5L2RpcmVjdG9yeS9jb3B5JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBtb3ZlcyBvbmUgb3IgbW9yZSByZXBvc2l0b3J5LW1hbmFnZWQgZmlsZXMgZnJvbSBhIHNvdXJjZSB1c2VyXG4gICAgICAgICAqIGRpcmVjdG9yeSB0byBhIGRlc3RpbmF0aW9uIHVzZXIgZGlyZWN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZmlsZW5hbWUgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCwgb25seSB0aG9zZSBmaWxlcyBpbmRpY2F0ZWQgb24gdGhhdFxuICAgICAgICAgKiBwYXJhbWV0ZXIgYXJlIG1vdmVkLiBPdGhlcndpc2UsIGFsbCBmaWxlcyBpbiB0aGUgc291cmNlIGRpcmVjdG9yeSBhcmUgbW92ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIGVuc3VyZSBtb3ZpbmcgZmlsZXMgZG9lcyBub3QgYWNjaWRlbnRhbGx5IG92ZXJ3cml0ZSBhbnkgZXhpc3RpbmcgZmlsZXNcbiAgICAgICAgICogaW4gdGhlIGRlc3RpbmF0aW9uIGRpcmVjdG9yeSwgYWxsIG1vdmVkIGZpbGVzIGFyZSBjcmVhdGVkIGFzIG5ldyB2ZXJzaW9uc1xuICAgICAgICAgKiBpbiB0aGUgZGVzdGluYXRpb24gZGlyZWN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA8c3Ryb25nPkltcG9ydGFudDo8L3N0cm9uZz5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBjYWxsIHdpbGwgb25seSBtb3ZlIGZpbGVzIHRoYXQgYXJlIG93bmVkIGJ5IGEgc2luZ2xlIGF1dGhvciB0byB0aGVcbiAgICAgICAgICogZGVzdGluYXRpb24gZGlyZWN0b3J5LiBJZiBhIHJlcG9zaXRvcnktbWFuYWdlZCBmaWxlIGluIHRoZSBzb3VyY2UgZGlyZWN0b3J5XG4gICAgICAgICAqIGhhcyBtdWx0aXBsZSBhdXRob3JzLCBhcyByZXN1bHQgb2YgY29sbGFib3JhdGlvbiB1c2luZyB0aGVcbiAgICAgICAgICogL3IvcmVwb3NpdG9yeS9maWxlL2dyYW50IGNhbGwsIHRoZSBmaWxlIHdpbGwgbm90IGJlIG1vdmVkIHRvIHRoZVxuICAgICAgICAgKiBkZXN0aW5hdGlvbiBkaXJlY3RvcnkgYW5kIGEgd2FybmluZyB0byB0aGF0IGFmZmVjdCB3aWxsIGJlIGluZGljYXRlZCBpbiB0aGVcbiAgICAgICAgICogcmVzcG9uc2UgbWFya3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlEaXJlY3RvcnlNb3ZlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgdGFyZ2V0IHJlcG9zaXRvcnkgZGlyZWN0b3J5LCBkZWZhdWx0cyB0byByb290XG4gICAgICAgICAqICAgICAgIGluY2x1ZGVkIGluIHRoZSByZXNwb25zZSBtYXJrdXBcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRlc3RpbmF0aW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgbmV3IG5hbWUgZm9yIHRoZSBkZXN0aW5hdGlvbiBjdXN0b20gZGlyZWN0b3J5XG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWxlbmFtZXMgdG8gYmUgY29waWVkLiBJZiBvbWl0dGVkLFxuICAgICAgICAgKiAgICAgICBhbGwgZmlsZXMgaW4gdGhlIHNvdXJjZSBkaXJlY3RvcnkgYXJlIGNvcGllZFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcG9zaXRvcnlEaXJlY3RvcnlNb3ZlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcmVwb3NpdG9yeS9kaXJlY3RvcnkvbW92ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgdXBkYXRlcyByZXBvc2l0b3J5LW1hbmFnZWQgZmlsZSBhY2Nlc3MgY29udHJvbHMgYnkgZGlyZWN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZmlsZW5hbWUgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCwgb25seSB0aG9zZSBmaWxlcyBpbmRpY2F0ZWQgb24gdGhhdFxuICAgICAgICAgKiBwYXJhbWV0ZXIgYXJlIHVwZGF0ZWQuIE90aGVyd2lzZSwgYWxsIGZpbGVzIGluIHRoZSBzb3VyY2UgZGlyZWN0b3J5IGFyZVxuICAgICAgICAgKiB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlEaXJlY3RvcnlVcGRhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5kaXJlY3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSB0YXJnZXQgcmVwb3NpdG9yeSBkaXJlY3RvcnksIGRlZmF1bHRzIHRvIHJvb3RcbiAgICAgICAgICogICAgICAgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlIG1hcmt1cFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZmlsZW5hbWU8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmlsZW5hbWVzIHRvIGJlIGNvcGllZC4gSWYgb21pdHRlZCxcbiAgICAgICAgICogICAgICAgYWxsIGZpbGVzIGluIHRoZSBzb3VyY2UgZGlyZWN0b3J5IGFyZSBjb3BpZWRcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJlc3RyaWN0ZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBuZXcgbmFtZSBmb3IgdGhlIGRlc3RpbmF0aW9uIGN1c3RvbSBkaXJlY3RvcnlcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnNoYXJlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgZmlsZXMgYXJlIHNoYXJlZCBhbmQgdmlzaWJsZSB0b1xuICAgICAgICAgKiAgICAgICBhdXRoZW50aWNhdGVkIHVzZXJzXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wdWJsaXNoZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIGZpbGVzIGFyZSBwdWJsaXNoZWQgYW5kIHZpc2libGUgdG9cbiAgICAgICAgICogICAgICAgYXV0aGVudGljYXRlZCBhbmQgYW5vbnltb3VzIHVzZXJzXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeURpcmVjdG9yeVVwZGF0ZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZGlyZWN0b3J5L3VwZGF0ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgYXJjaGl2ZXMgb25lIG9yIG1vcmUgcmVwb3NpdG9yeS1tYW5hZ2VkIGZpbGVzIGZyb20gYSBzb3VyY2UgdXNlclxuICAgICAgICAgKiBkaXJlY3RvcnkgKCByb290IG9yIGN1c3RvbSApIHRvIGFuIGFyY2hpdmUgZGlyZWN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgdmFsdWUgb2YgdGhlIGFyY2hpdmUgcGFyYW1ldGVyIGluZGljYXRlcyBhbiBleGlzdGluZyBhcmNoaXZlXG4gICAgICAgICAqIGRpcmVjdG9yeSB0aGVuIHRoZSBmaWxlcyBpbiB0aGUgc291cmNlIGRpcmVjdG9yeSBhcmUgYWRkZWQgdG8gdGhlIGV4aXN0aW5nXG4gICAgICAgICAqIGFyY2hpdmUuIE90aGVyd2lzZSwgYSBuZXcgYXJjaGl2ZSBkaXJlY3RvcnkgaXMgYXV0b21hdGljYWxseSBjcmVhdGVkIG9uXG4gICAgICAgICAqIGJlaGFsZiBvZiB0aGUgY2FsbGVyLiBBcmNoaXZlZCBkaXJlY3RvcmllcyBhdXRvbWF0aWNhbGx5IGhhdmUgYSAuYXJjaGl2ZVxuICAgICAgICAgKiBwb3N0Zml4IGFwcGVuZGVkIHRvIHRoZWlyIG5hbWUgaWYgaXQgaXMgbm90IHN1cHBsaWVkIG9uIHRoZSBhcmNoaXZlXG4gICAgICAgICAqIHBhcmFtZXRlciB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYWxsIG9mIHRoZSBmaWxlcyBpbiB0aGUgc291cmNlIGRpcmVjdG9yeSBhcmUgc3VjY2Vzc2Z1bGx5IGFyY2hpdmVkLCB0aGVcbiAgICAgICAgICogc291cmNlIGRpcmVjdG9yeSBpcyBhdXRvbWF0aWNhbGx5IGRlbGV0ZWQgZnJvbSB0aGUgcmVwb3NpdG9yeS4gSWYgdGhlXG4gICAgICAgICAqIHNvdXJjZSBkaXJlY3Rvcnkgd2FzIHJvb3QgLCBhbiBlbXB0eSByb290IGRpcmVjdG9yeSBpcyBwcmVzZXJ2ZWQuIElmIGFueSBvZlxuICAgICAgICAgKiB0aGUgZmlsZXMgaW4gdGhlIHNvdXJjZSBkaXJlY3RvcnkgYXJlIHNraXBwZWQgb3IgY2FuIG5vdCBiZSBhcmNoaXZlZCAoc2VlXG4gICAgICAgICAqIGZvbGxvd2luZyBub3RlKSwgdGhvc2UgZmlsZXMgYW5kIHRoZSBzb3VyY2UgZGlyZWN0b3J5IGFyZSBwcmVzZXJ2ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIDxzdHJvbmc+SW1wb3J0YW50Ojwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGNhbGwgd2lsbCBvbmx5IGFyY2hpdmUgZmlsZXMgdGhhdCBhcmUgb3duZWQgYnkgYSBzaW5nbGUgYXV0aG9yIHRvIHRoZVxuICAgICAgICAgKiBkZXN0aW5hdGlvbiBkaXJlY3RvcnkuIElmIGEgcmVwb3NpdG9yeS1tYW5hZ2VkIGZpbGUgaW4gdGhlIHNvdXJjZSBkaXJlY3RvcnlcbiAgICAgICAgICogaGFzIG11bHRpcGxlIGF1dGhvcnMsIGFzIGEgcmVzdWx0IG9mIGNvbGxhYm9yYXRpb24gdXNpbmcgdGhlXG4gICAgICAgICAqIC9yL3JlcG9zaXRvcnkvZmlsZS9ncmFudCBjYWxsLCB0aGUgZmlsZSB3aWxsIG5vdCBiZSBhcmNoaXZlZCB0byB0aGVcbiAgICAgICAgICogZGVzdGluYXRpb24gZGlyZWN0b3J5IGFuZCBhIHdhcm5pbmcgdG8gdGhhdCBhZmZlY3Qgd2lsbCBiZSBpbmRpY2F0ZWQgaW4gdGhlXG4gICAgICAgICAqIHJlc3BvbnNlIG1hcmt1cC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZXBvc2l0b3J5RGlyZWN0b3J5QXJjaGl2ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWxlbmFtZXMgdG8gYmUgY29waWVkLiBJZiBvbWl0dGVkLFxuICAgICAgICAgKiAgICAgICBhbGwgZmlsZXMgaW4gdGhlIHNvdXJjZSBkaXJlY3RvcnkgYXJlIGNvcGllZFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cmVzdHJpY3RlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIG5ldyBuYW1lIGZvciB0aGUgZGVzdGluYXRpb24gY3VzdG9tIGRpcmVjdG9yeVxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c2hhcmVkPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBmaWxlcyBhcmUgc2hhcmVkIGFuZCB2aXNpYmxlIHRvXG4gICAgICAgICAqICAgICAgIGF1dGhlbnRpY2F0ZWQgdXNlcnNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnB1Ymxpc2hlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgZmlsZXMgYXJlIHB1Ymxpc2hlZCBhbmQgdmlzaWJsZSB0b1xuICAgICAgICAgKiAgICAgICBhdXRoZW50aWNhdGVkIGFuZCBhbm9ueW1vdXMgdXNlcnNcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICByZXBvc2l0b3J5RGlyZWN0b3J5QXJjaGl2ZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3IvcmVwb3NpdG9yeS9kaXJlY3RvcnkvYXJjaGl2ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgdXBsb2FkcyBhIHNldCBvZiBmaWxlcyBpbiBhIHppcCBhcmNoaXZlIGludG8gYW4gZXhpc3RpbmdcbiAgICAgICAgICogcmVwb3NpdG9yeS1tYW5hZ2VkIHVzZXIgZGlyZWN0b3J5ICggcm9vdCAsIGN1c3RvbSBvciBhcmNoaXZlZCApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlEaXJlY3RvcnlVcGxvYWRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5maWxlPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAuLi56aXAgYXJjaGl2ZSBmaWxlIGNvbnRlbnQuLi5cbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXNjcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgYSBkZXNjcmlwdGlvbiB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdXBsb2FkZWQgZmlsZVxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dGFnczwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGFnIHdvcmRzIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSByZXBvc2l0b3J5IGZpbGVcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJlc3RyaWN0ZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBuZXcgbmFtZSBmb3IgdGhlIGRlc3RpbmF0aW9uIGN1c3RvbSBkaXJlY3RvcnlcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnNoYXJlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiA8Y29kZT50cnVlPC9jb2RlPiwgZmlsZXMgYXJlIHNoYXJlZCBhbmQgdmlzaWJsZSB0b1xuICAgICAgICAgKiAgICAgICBhdXRoZW50aWNhdGVkIHVzZXJzXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wdWJsaXNoZWQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIGZpbGVzIGFyZSBwdWJsaXNoZWQgYW5kIHZpc2libGUgdG9cbiAgICAgICAgICogICAgICAgYXV0aGVudGljYXRlZCBhbmQgYW5vbnltb3VzIHVzZXJzXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5uZXd2ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPlxuICAgICAgICAgKiAgICAgICAob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCB0aGUgcmVwb3NpdG9yeSB3aWxsIGNyZWF0ZSBuZXdcbiAgICAgICAgICogICAgICAgdmVyc2lvbiByYXRoZXIgdGhhbiBvdmVyd3JpdGVcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0Pm5ld3ZlcnNpb25tc2c8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgbmV3dmVyc2lvbiBpcyB0cnVlLCBtZXNzYWdlIHRvIGFzc29jaWF0ZSB3aXRoIG5ld1xuICAgICAgICAgKiAgICAgICB2ZXJzaW9uXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeURpcmVjdG9yeVVwbG9hZDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgY29uZmlnLmZvcm1hdCA9ICd0ZXh0JztcbiAgICAgICAgICAgIHZhciBpb0NvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjb25maWcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgZm9ybToge1xuICAgICAgICAgICAgICAgICAgICBpZDogY29uZmlnLmZvcm1JZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IGNhbGxiYWNrXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZGlyZWN0b3J5L3VwbG9hZCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgZG93bmxvYWRzIG9uZSBvciBtb3JlIHJlcG9zaXRvcnktbWFuYWdlZCBmaWxlcyBmcm9tIGEgZGlyZWN0b3J5XG4gICAgICAgICAqIGluIHRoZSByZXBvc2l0b3J5LiBUaGUgcmVzcG9uc2UgdHlwZSBvbiB0aGlzIGNhbGwgaXMgYSB6aXAgYXJjaGl2ZSBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZmlsZW5hbWUgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCwgb25seSB0aG9zZSBmaWxlcyBpbmRpY2F0ZWQgb24gdGhhdFxuICAgICAgICAgKiBwYXJhbWV0ZXIgYXJlIGRvd25sb2FkZWQuIE90aGVyd2lzZSwgYWxsIGZpbGVzIGluIHRoZSBzb3VyY2UgZGlyZWN0b3J5IGFyZVxuICAgICAgICAgKiBkb3dubG9hZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHJlcG9zaXRvcnlEaXJlY3RvcnlEb3dubG9hZFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5maWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWxlbmFtZXMgdG8gYmUgY29waWVkLiBJZiBvbWl0dGVkLFxuICAgICAgICAgKiAgICAgICBhbGwgZmlsZXMgaW4gdGhlIHNvdXJjZSBkaXJlY3RvcnkgYXJlIGNvcGllZFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHJlcG9zaXRvcnlEaXJlY3RvcnlEb3dubG9hZDogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykgeyAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZGlyZWN0b3J5L2Rvd25sb2FkJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBkZWxldGVzIGEgcmVwb3NpdG9yeS1tYW5hZ2VkIHVzZXIgZGlyZWN0b3J5ICggcm9vdCAsIGN1c3RvbSBvclxuICAgICAgICAgKiBhcmNoaXZlZCApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIGRlbGV0aW5nIGEgdXNlciBkaXJlY3RvcnksIGFsbCBmaWxlcyBpbiB0aGUgZGlyZWN0b3J5IGFyZVxuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IGRlbGV0ZWQgYWxvbmcgd2l0aCB0aGUgZGlyZWN0b3J5LiBJZiB0aGUgdGFyZ2V0IGRpcmVjdG9yeSBpc1xuICAgICAgICAgKiByb290LCBhbiBlbXB0eSByb290IGRpcmVjdG9yeSBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVwb3NpdG9yeURpcmVjdG9yeURlbGV0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqICAgICAgICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAqIDxkbD5cbiAgICAgICAgICogICAgPGR0PmRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHRhcmdldCByZXBvc2l0b3J5IGRpcmVjdG9yeSwgZGVmYXVsdHMgdG8gcm9vdFxuICAgICAgICAgKiAgICAgICBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3NpdG9yeURpcmVjdG9yeURlbGV0ZTogZnVuY3Rpb24oY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW8oJy9yL3JlcG9zaXRvcnkvZGlyZWN0b3J5L2RlbGV0ZScsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gSm9iIEFQSXNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIC8qKiAgXG4gICAgICAgICAqIFRoaXMgY2FsbCBsaXN0cyBqb2JzIGZvciB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG9wZW5vbmx5IHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBzZWUgb25seSB0aG9zZSBqb2JzIGluIGFuIG9wZW5cbiAgICAgICAgICogc3RhdGUuIFRoZSBzZXQgb2Ygam9iIG9wZW4gc3RhdGVzIGFyZSBzaG93biBoZXJlOlxuICAgICAgICAgKlxuICAgICAgICAgKiA8dWw+XG4gICAgICAgICAqICA8bGk+U2NoZWR1bGVkIDogam9iIGlzIHNjaGVkdWxlZCBidXQgbm90IHlldCBxdWV1ZWQgZm9yIHJ1bm5pbmcuPC9saT5cbiAgICAgICAgICogIDxsaT5RdWV1ZWQgOiBqb2IgaXMgcXVldWVkIGZvciBydW5uaW5nLjwvbGk+XG4gICAgICAgICAqICA8bGk+UnVubmluZyA6IGpvYiBpcyBydW5uaW5nLjwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqXG4gICAgICAgICAqIDxibG9ja3F1b3RlPlxuICAgICAgICAgKiAgICBJbXBvcnRhbnQhIEFueSBvcGVuIGpvYiBjYW4gYmUgY2FuY2VsbGVkIHVzaW5nIHRoZVxuICAgICAgICAgKiAgICA8YSBocmVmPVwiI21ldGhvZF9qb2JDYW5jZWxcIj5qb2JDYW5jZWw8L2E+IGNhbGwuXG4gICAgICAgICAqIDwvYmxvY2txdW90ZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBqb2JMaXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+b3Blbm9ubHk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgdHJ1ZSwgb25seSBqb2JzIGluIGFuIG9wZW4tc3RhdGUgYXJlIGxpc3RlZCBpbiB0aGVcbiAgICAgICAgICogICAgICAgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5leHRlbmRlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBJZiB0cnVlLCBhZGRpdGlvbmFsIGRhdGEgcHJvcGVydGllcyBkZXNjcmliaW5nIGVhY2ggam9iXG4gICAgICAgICAqICAgICAgIGFyZSBsaXN0ZWQgaW4gdGhlIHJlc3BvbnNlIG1hcmt1cFxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGpvYkxpc3Q6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9qb2IvbGlzdCcsIGNvbmZpZywgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNhbGwgc3VibWl0cyBhIGpvYiBmb3IgYmFja2dyb3VuZCBleGVjdXRpb24gb24gYmVoYWxmIG9mIHRoZSB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBzdWJtaXQgdGhlIGV4ZWN1dGlvbiBvZiBhbiBhcmJpdHJhcnkgYmxvY2sgb2YgUiBjb2RlIHRoZSBjYWxsZXIgbXVzdFxuICAgICAgICAgKiBwcm92aWRlIGEgdmFsdWUgb24gdGhlIGNvZGUgcGFyYW1ldGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBzdWJtaXQgdGhlIGV4ZWN1dGlvbiBvZiBhIHNpbmdsZSByZXBvc2l0b3J5LW1hbmFnZWQgc2NyaXB0IHRoZSBjYWxsZXJcbiAgICAgICAgICogbXVzdCBwcm92aWRlIHBhcmFtZXRlciB2YWx1ZXMgZm9yIHJzY3JpcHRuYW1lICwgcnNjcmlwdGF1dGhvciBhbmRcbiAgICAgICAgICogb3B0aW9uYWxseSByc2NyaXB0dmVyc2lvbiAuIFRvIHN1Ym1pdCB0aGUgZXhlY3V0aW9uIG9mIGEgY2hhaW4gb2ZcbiAgICAgICAgICogcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdHMgdGhlIGNhbGxlciBtdXN0IHByb3ZpZGUgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdFxuICAgICAgICAgKiBvZiB2YWx1ZXMgb24gdGhlIHJzY3JpcHRuYW1lLCwgX3JzY3JpcHRhdXRob3IgYW5kIG9wdGlvbmFsbHkgcnNjcmlwdHZlcnNpb25cbiAgICAgICAgICogcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogVG8gc3VibWl0IHRoZSBleGVjdXRpb24gb2YgYSBzaW5nbGUgZXh0ZXJuYWwgc2NyaXB0IHRoZSBjYWxsZXIgbXVzdFxuICAgICAgICAgKiBwcm92aWRlIGEgdmFsaWQgVVJMIG9yIGZpbGUgcGF0aCB1c2luZyB0aGUgZXh0ZXJuYWxzb3VyY2UgcGFyYW1ldGVyLiBUb1xuICAgICAgICAgKiBzdWJtaXQgdGhlIGV4ZWN1dGlvbiBvZiBhIGNoYWluIG9mIGV4dGVybmFsIHNjcmlwdHMgdGhlIGNhbGxlciBtdXN0XG4gICAgICAgICAqIHByb3ZpZGUgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2YWx1ZXMgb24gdGhlIGV4dGVybmFsc291cmNlIHBhcmFtZXRlci5cbiAgICAgICAgICogTm90ZSwgdG8gc3VibWl0IHRoZSBleGVjdXRpb24gb2YgYW4gZXh0ZXJuYWwgc2NyaXB0IHRoZSBjYWxsZXIgbXVzdCBoYXZlXG4gICAgICAgICAqIFBPV0VSX1VTRVIgcHJpdmlsZWdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogQSBjaGFpbmVkIGV4ZWN1dGlvbiBleGVjdXRlcyBlYWNoIG9mIHRoZSBzY3JpcHRzIGlkZW50aWZpZWQgb24gdGhlXG4gICAgICAgICAqIGNhbGwgaW4gYSBzZXF1ZW50aWFsIGZhc2hpb24gb24gdGhlIFIgc2Vzc2lvbiBmb3IgdGhlIGpvYiwgd2l0aCBleGVjdXRpb25cbiAgICAgICAgICogb2NjdXJpbmcgaW4gdGhlIG9yZGVyIHNwZWNpZmllZCBvbiB0aGUgcGFyYW1ldGVyIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBsZWFzZSBub3QgdGhlIGZvbGxvd2luZyBwcmUgYW5kIHBvc3QgZXhlY3V0aW9uIHBhcmFtZXRlcnM6XG4gICAgICAgICAqXG4gICAgICAgICAqIDxzdHJvbmc+UHJlLWV4ZWN1dGlvbiBwYXJhbWV0ZXJzOjwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8b2w+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIGlucHV0cyBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gcGFzcyBSZXZvRGVwbG95Ui1lbmNvZGVkXG4gICAgICAgICAqICAgICAgIFIgb2JqZWN0IHZhbHVlcyBhcyBpbnB1dHMuIFRoZXNlIGlucHV0cyBhcmUgdHVybmVkIGludG8gUiBvYmplY3RzXG4gICAgICAgICAqICAgICAgIGluIHRoZSB3b3Jrc3BhY2UgYmVmb3JlIHRoZSBleGVjdXRpb24gYmVnaW5zLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBwcmVsb2FkZmlsZSBwYXJhbWV0ZXJzIGFsbG93cyB0aGUgY2FsbGVyIHRvIGxvYWQgb25lIG9yIG1vcmVcbiAgICAgICAgICogICAgICAgZmlsZXMgZnJvbSB0aGUgcmVwb3NpdG9yeSBpbnRvIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBiZWZvcmUgdGhlXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGlvbiBiZWdpbnMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHByZWxvYWRvYmplY3QgcGFyYW1ldGVycyBhbGxvdyB0aGUgY2FsbGVyIHRvIGxvYWQgb25lIG9yIG1vcmVcbiAgICAgICAgICogICAgICAgYmluYXJ5IFIgb2JqZWN0cyAoLnJEYXRhKSBmcm9tIHRoZSByZXBvc2l0b3J5IGludG8gdGhlIHdvcmtzcGFjZVxuICAgICAgICAgKiAgICAgICBiZWZvcmUgdGhlIGV4ZWN1dGlvbiBiZWdpbnMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIGFkb3B0IHBhcmFtZXRlcnMgYWxsb3cgdGhlIGNhbGxlciB0byBsb2FkIGEgcHJlLWV4aXN0aW5nXG4gICAgICAgICAqICAgICAgIHByb2plY3Qgd29ya3NwYWNlLCBwcm9qZWN0IHdvcmtpbmcgZGlyZWN0b3J5IGFuZC9vciBwcm9qZWN0IHBhY2thZ2VcbiAgICAgICAgICogICAgICAgZGVwZW5kZW5jaWVzIGJlZm9yZSB0aGUgZXhlY3V0aW9uIGJlZ2lucy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogPC9vbD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHN0cm9uZz5Qb3N0LWV4ZWN1dGlvbiBwYXJhbWV0ZXJzOjwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8b2w+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlZmlsZSBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgc3BlY2lmeSBhIGNvbW1hLXNlcGFyYXRlZFxuICAgICAgICAgKiAgICAgICBsaXN0IG9mIHdvcmtpbmcgZGlyZWN0b3J5IGZpbGVzIHRvIGJlIHN0b3JlZCBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlclxuICAgICAgICAgKiAgICAgICB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVvYmplY3QgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHNwZWNpZnkgYSBjb21tYS1zZXBhcmF0ZWRcbiAgICAgICAgICogICAgICAgbGlzdCBvZiB3b3Jrc3BhY2Ugb2JqZWN0cyB0byBiZSBzdG9yZWQgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGlvbiBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3Jld29ya3NwYWNlIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBzdG9yZSB0aGUgZW50aXJlXG4gICAgICAgICAqICAgICAgIHdvcmtzcGFjZSBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlciB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVkaXJlY3RvcnkgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHNwZWNpZnkgYSB0YXJnZXRcbiAgICAgICAgICogICAgICAgcmVwb3NpdG9yeSBkaXJlY3RvcnkgZm9yIHN0b3JlZCBmaWxlcyBhbmQgb2JqZWN0cyBhZnRlciB0aGUgZXhlY3V0aW9uXG4gICAgICAgICAqICAgICAgIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVuZXd2ZXJzaW9uIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBjcmVhdGUgbmV3XG4gICAgICAgICAqICAgICAgIHZlcnNpb25zIG9mIGVhY2ggc3RvcmVkIGZpbGUgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlIGV4ZWN1dGlvblxuICAgICAgICAgKiAgICAgICBjb21wbGV0ZXMuIEJ5IGRlZmF1bHQsIHN0b3JlZCBmaWxlcyBvdmVyd3JpdGUgYW55IHByZS1leGlzdGluZyBmaWxlXG4gICAgICAgICAqICAgICAgIGJ5IHRoZSBzYW1lIG5hbWUuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlcHVibGljIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBhc3NpZ24gcHVibGljIGFjY2Vzc1xuICAgICAgICAgKiAgICAgICB0byBlYWNoIHN0b3JlZCBmaWxlIGluIHRoZSByZXBvc2l0b3J5IGFmdGVyIHRoZSBleGVjdXRpb24gY29tcGxldGVzLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBzdG9yZW5vcHJvamVjdCBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gc2tpcCB0aGVcbiAgICAgICAgICogICAgICAgcGVyc2lzdGVuY2UtdG8tcHJvamVjdCBzdGVwIGFmdGVyIHRoZSBleGVjdXRpb24uXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqIDwvb2w+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgam9iU3VibWl0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+bmFtZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5qb2IgbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5kZXNjcjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGpvYiBkZXNjcmlwdGlvbjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5jb2RlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgUiBjb2RlIHRvIGV4ZWN1dGUgb24gam9iPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+cnNjcmlwdG5hbWU8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJlcG9zaXRvcnktbWFuYWdlZCBzY3JpcHQgZmlsZW5hbWVzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJzY3JpcHRkaXJlY3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiByZXBvc2l0b3J5LW1hbmFnZWQgZGlyZWN0b3JpZXMgZm9yIHNjcmlwdHMsIGRlZmF1bHRzIHRvIHJvb3Q8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5yc2NyaXB0YXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhdXRob3JzLCBhdXRob3ItcGVyLXJzY3JpcHRuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+cnNjcmlwdHZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZlcnNpb25zLCB2ZXJzaW9uLXBlci1yc2NyaXB0bmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmV4dGVybmFsc291cmNlPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBVUkxzIG9yIGZpbGUgcGF0aHMgdG8gZXh0ZXJuYWwgc2NyaXB0czwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmlucHV0czwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgUmV2b0RlcGxveVItZW5jb2RlZCBzY3JpcHQgaW5wdXRzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmNzdmlucHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHByaW1pdGl2ZSBuYW1lL3ZhbHVlIGlucHV0czwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PnByZWxvYWRmaWxlbmFtZTwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeSBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5wcmVsb2FkZmlsZWF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYXV0aG9ycywgYXV0aG9yLXBlci1wcmVsb2FkZmlsZW5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5wcmVsb2FkZmlsZXZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZlcnNpb25zLCB2ZXJzaW9uLXBlci1wcmVsb2FkZmlsZW5hbWU8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5wcmVsb2Fkb2JqZWN0bmFtZTwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeSBvYmplY3QgKC5yRGF0YSkgZmlsZW5hbWVzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+cHJlbG9hZG9iamVjdGF1dGhvcjwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYXV0aG9ycywgYXV0aG9yLXBlci1wcmVsb2Fkb2JqZWN0bmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PnByZWxvYWRvYmplY3R2ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2ZXJzaW9ucywgdmVyc2lvbi1wZXItb2JqZWN0LXByZWxvYWRvYmplY3RuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+YWRvcHR3b3Jrc3BhY2U8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGlkZW50aWZpZXMgcHJvamVjdCBmcm9tIHdoaWNoIHdvcmtzcGFjZSBpcyB0byBiZSBhZG9wdGVkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+YWRvcHRkaXJlY3Rvcnk8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGlkZW50aWZpZXMgcHJvamVjdCBmcm9tIHdoaWNoIGRpcmVjdG9yeSBpcyB0byBiZSBhZG9wdGVkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+YWRvcHRwYWNrYWdlczwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgaWRlbnRpZmllcyBwcm9qZWN0IGZyb20gd2hpY2ggcGFja2FnZSBkZXBlbmRlbmNpZXMgYXJlIHRvIGJlIGFkb3B0ZWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5wcmlvcml0eTwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBzY2hlZHVsaW5nIHByaW9yaXR5IGZvciB0aGUgam9iOiBsb3cgKGRlZmF1bHQpLCBtZWRpdW0gb3IgaGlnaDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PnRhZzwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIGEgdGFnIHRoYXQgbGFiZWxzIHRoZSBleGVjdXRpb248L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5lY2hvb2ZmPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+XG4gICAgICAgICAqICAgICAgIChvcHRpb25hbCkgaWYgdHJ1ZSBSIGNvbW1hbmRzIHdpbGwgbm90IGFwcGVhciBpbiB0aGUgY29uc29sZSBvdXRwdXRcbiAgICAgICAgICogICAgICAgc2F2ZWQgb24gdGhlIHByb2plY3QgZXhlY3V0aW9uIGhpc3RvcnkgZm9yIHRoZSBqb2JcbiAgICAgICAgICogICAgPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+Z3JhcGhpY3M8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBwcmVmZXJyZWQgUiBncmFwaGljcyBkZXZpY2UgZm9yIGV4ZWN1dGlvbjogcG5nIG9yIHN2ZzwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmdyYXBoaWNzd2lkdGg8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBwcmVmZXJyZWQgd2lkdGggZm9yIFIgZ3JhcGhpY3MgZGV2aWNlIGltYWdlczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PmdyYXBoaWNzaGVpZ2h0PC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgcHJlZmVycmVkIGhlaWdodCBmb3IgUiBncmFwaGljcyBkZXZpY2UgaW1hZ2VzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+c3RvcmVmaWxlPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB3b3JraW5nIGRpcmVjdG9yeSBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5zdG9yZW9iamVjdDwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygd29ya3NwYWNlIG9iamVjdCBuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PnN0b3Jld29ya3NwYWNlPC9kdD5cbiAgICAgICAgICogICAgICA8ZGQ+KG9wdGlvbmFsKSBmaWxlbmFtZSAoLnJEYXRhKSB3aGVyZSB3b3Jrc3BhY2UgY29udGVudHMgd2lsbCBiZSBzYXZlZCBpbiB0aGUgcmVwb3NpdG9yeTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgPGR0PnN0b3JlbmV3dmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIGVuc3VyZXMgZWFjaCBmaWxlIHN0b3JlZCBpbiByZXBvc2l0b3J5IHJlc3VsdHMgaW4gbmV3IHZlcnNpb24gYmVpbmcgY3JlYXRlZCBpZiBuZWVkZWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgIDxkdD5zdG9yZXB1YmxpYzwvZHQ+XG4gICAgICAgICAqICAgICAgPGRkPihvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIHB1Ymxpc2hlcyBlYWNoIGZpbGUgc3RvcmVkIGluIHRoZSByZXBvc2l0b3J5PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+c3RvcmVub3Byb2plY3Q8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBubyBwcm9qZWN0IHBlcnNpc3RlbmNlIGZvbGxvd2luZyBqb2IgZXhlY3V0aW9uPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBqb2JTdWJtaXQ6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHsgICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9qb2Ivc3VibWl0JywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2FsbCBzY2hlZHVsZXMgYSBqb2IgZm9yIGJhY2tncm91bmQgZXhlY3V0aW9uIG9uIGJlaGFsZiBvZiB0aGUgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHNjaGVkc3RhcnQgcGFyYW1ldGVyIGlkZW50aWZpZXMgdGhlIHN0YXJ0IHRpbWUgZm9yIHRoZSBqb2IuIFRoaXNcbiAgICAgICAgICogcGFyYW1ldGVyIHZhbHVlIGlzIHNwZWNpZmllZCBhcyBVVEMgaW4gbWlsbGlzZWNvbmRzLiBUaGUgc2NoZWRyZXBlYXRcbiAgICAgICAgICogcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBqb2IgaXMgdG8gYmUgcmVwZWF0ZWQsIGFuZCBpZlxuICAgICAgICAgKiBvbWl0dGVkIHRoZSBqb2IgaXMgZXhlY3V0ZWQganVzdCBvbmNlLiBUaGUgc2NoZWRpbnRlcnZhbCBwYXJhbWV0ZXJcbiAgICAgICAgICogaW5kaWNhdGVzIHRoZSBpbnRlcnZhbCwgbWVhc3VyZWQgaW4gbWlsbGlzZWNvbmRzLCBiZXR3ZWVuIHJlcGVhdFxuICAgICAgICAgKiBleGVjdXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBzY2hlZHVsZSB0aGUgZXhlY3V0aW9uIG9mIGFuIGFyYml0cmFyeSBibG9jayBvZiBSIGNvZGUgdGhlIGNhbGxlclxuICAgICAgICAgKiBtdXN0IHByb3ZpZGUgYSB2YWx1ZSBvbiB0aGUgY29kZSBwYXJhbWV0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIHNjaGVkdWxlIHRoZSBleGVjdXRpb24gb2YgYSBzaW5nbGUgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdCB0aGVcbiAgICAgICAgICogY2FsbGVyIG11c3QgcHJvdmlkZSBwYXJhbWV0ZXIgdmFsdWVzIGZvciByc2NyaXB0bmFtZSAsIHJzY3JpcHRhdXRob3IgYW5kXG4gICAgICAgICAqIG9wdGlvbmFsbHkgcnNjcmlwdHZlcnNpb24gLiBUbyBzY2hlZHVsZSB0aGUgZXhlY3V0aW9uIG9mIGEgY2hhaW4gb2ZcbiAgICAgICAgICogcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdHMgdGhlIGNhbGxlciBtdXN0IHByb3ZpZGUgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdFxuICAgICAgICAgKiBvZiB2YWx1ZXMgb24gdGhlIHJzY3JpcHRuYW1lLCwgX3JzY3JpcHRhdXRob3IgYW5kIG9wdGlvbmFsbHkgcnNjcmlwdHZlcnNpb25cbiAgICAgICAgICogcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gc2NoZWR1bGUgdGhlIGV4ZWN1dGlvbiBvZiBhIHNpbmdsZSBleHRlcm5hbCBzY3JpcHQgdGhlIGNhbGxlciBtdXN0XG4gICAgICAgICAqIHByb3ZpZGUgYSB2YWxpZCBVUkwgb3IgZmlsZSBwYXRoIHVzaW5nIHRoZSBleHRlcm5hbHNvdXJjZSBwYXJhbWV0ZXIuIFRvXG4gICAgICAgICAqIHNjaGVkdWxlIHRoZSBleGVjdXRpb24gb2YgYSBjaGFpbiBvZiBleHRlcm5hbCBzY3JpcHRzIHRoZSBjYWxsZXIgbXVzdFxuICAgICAgICAgKiBwcm92aWRlIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmFsdWVzIG9uIHRoZSBleHRlcm5hbHNvdXJjZSBwYXJhbWV0ZXIuXG4gICAgICAgICAqIE5vdGUsIHRvIHNjaGVkdWxlIHRoZSBleGVjdXRpb24gb2YgYW4gZXh0ZXJuYWwgc2NyaXB0IHRoZSBjYWxsZXIgbXVzdFxuICAgICAgICAgKiBoYXZlIFBPV0VSX1VTRVIgcHJpdmlsZWdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogQSBjaGFpbmVkIGV4ZWN1dGlvbiBleGVjdXRlcyBlYWNoIG9mIHRoZSBzY3JpcHRzIGlkZW50aWZpZWQgb24gdGhlXG4gICAgICAgICAqIGNhbGwgaW4gYSBzZXF1ZW50aWFsIGZhc2hpb24gb24gdGhlIFIgc2Vzc2lvbiBmb3IgdGhlIGpvYiwgd2l0aFxuICAgICAgICAgKiBleGVjdXRpb24gb2NjdXJpbmcgaW4gdGhlIG9yZGVyIHNwZWNpZmllZCBvbiB0aGUgcGFyYW1ldGVyIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBsZWFzZSBub3QgdGhlIGZvbGxvd2luZyBwcmUgYW5kIHBvc3QgZXhlY3V0aW9uIHBhcmFtZXRlcnM6XG4gICAgICAgICAqXG4gICAgICAgICAqIDxzdHJvbmc+UHJlLWV4ZWN1dGlvbiBwYXJhbWV0ZXJzOjwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8b2w+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIGlucHV0cyBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gcGFzcyBSZXZvRGVwbG95Ui1lbmNvZGVkXG4gICAgICAgICAqICAgICAgIFIgb2JqZWN0IHZhbHVlcyBhcyBpbnB1dHMuIFRoZXNlIGlucHV0cyBhcmUgdHVybmVkIGludG8gUiBvYmplY3RzXG4gICAgICAgICAqICAgICAgIGluIHRoZSB3b3Jrc3BhY2UgYmVmb3JlIHRoZSBleGVjdXRpb24gYmVnaW5zLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBwcmVsb2FkZmlsZSBwYXJhbWV0ZXJzIGFsbG93cyB0aGUgY2FsbGVyIHRvIGxvYWQgb25lIG9yIG1vcmVcbiAgICAgICAgICogICAgICAgZmlsZXMgZnJvbSB0aGUgcmVwb3NpdG9yeSBpbnRvIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBiZWZvcmUgdGhlXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGlvbiBiZWdpbnMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHByZWxvYWRvYmplY3QgcGFyYW1ldGVycyBhbGxvdyB0aGUgY2FsbGVyIHRvIGxvYWQgb25lIG9yIG1vcmVcbiAgICAgICAgICogICAgICAgYmluYXJ5IFIgb2JqZWN0cyAoLnJEYXRhKSBmcm9tIHRoZSByZXBvc2l0b3J5IGludG8gdGhlIHdvcmtzcGFjZVxuICAgICAgICAgKiAgICAgICBiZWZvcmUgdGhlIGV4ZWN1dGlvbiBiZWdpbnMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIGFkb3B0IHBhcmFtZXRlcnMgYWxsb3cgdGhlIGNhbGxlciB0byBsb2FkIGEgcHJlLWV4aXN0aW5nXG4gICAgICAgICAqICAgICAgIHByb2plY3Qgd29ya3NwYWNlLCBwcm9qZWN0IHdvcmtpbmcgZGlyZWN0b3J5IGFuZC9vciBwcm9qZWN0IHBhY2thZ2VcbiAgICAgICAgICogICAgICAgZGVwZW5kZW5jaWVzIGJlZm9yZSB0aGUgZXhlY3V0aW9uIGJlZ2lucy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogPC9vbD5cbiAgICAgICAgICpcbiAgICAgICAgICogPHN0cm9uZz5Qb3N0LWV4ZWN1dGlvbiBwYXJhbWV0ZXJzOjwvc3Ryb25nPlxuICAgICAgICAgKlxuICAgICAgICAgKiA8b2w+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlZmlsZSBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgc3BlY2lmeSBhIGNvbW1hLXNlcGFyYXRlZFxuICAgICAgICAgKiAgICAgICBsaXN0IG9mIHdvcmtpbmcgZGlyZWN0b3J5IGZpbGVzIHRvIGJlIHN0b3JlZCBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlclxuICAgICAgICAgKiAgICAgICB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVvYmplY3QgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHNwZWNpZnkgYSBjb21tYS1zZXBhcmF0ZWRcbiAgICAgICAgICogICAgICAgbGlzdCBvZiB3b3Jrc3BhY2Ugb2JqZWN0cyB0byBiZSBzdG9yZWQgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGlvbiBjb21wbGV0ZXMuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3Jld29ya3NwYWNlIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBzdG9yZSB0aGUgZW50aXJlXG4gICAgICAgICAqICAgICAgIHdvcmtzcGFjZSBpbiB0aGUgcmVwb3NpdG9yeSBhZnRlciB0aGUgZXhlY3V0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVkaXJlY3RvcnkgcGFyYW1ldGVyIGFsbG93cyB0aGUgY2FsbGVyIHRvIHNwZWNpZnkgYSB0YXJnZXRcbiAgICAgICAgICogICAgICAgcmVwb3NpdG9yeSBkaXJlY3RvcnkgZm9yIHN0b3JlZCBmaWxlcyBhbmQgb2JqZWN0cyBhZnRlciB0aGUgZXhlY3V0aW9uXG4gICAgICAgICAqICAgICAgIGNvbXBsZXRlcy5cbiAgICAgICAgICogICAgPC9saT5cbiAgICAgICAgICogICAgPGxpPlxuICAgICAgICAgKiAgICAgICBUaGUgc3RvcmVuZXd2ZXJzaW9uIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBjcmVhdGUgbmV3XG4gICAgICAgICAqICAgICAgIHZlcnNpb25zIG9mIGVhY2ggc3RvcmVkIGZpbGUgaW4gdGhlIHJlcG9zaXRvcnkgYWZ0ZXIgdGhlIGV4ZWN1dGlvblxuICAgICAgICAgKiAgICAgICBjb21wbGV0ZXMuIEJ5IGRlZmF1bHQsIHN0b3JlZCBmaWxlcyBvdmVyd3JpdGUgYW55IHByZS1leGlzdGluZyBmaWxlXG4gICAgICAgICAqICAgICAgIGJ5IHRoZSBzYW1lIG5hbWUuXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqICAgIDxsaT5cbiAgICAgICAgICogICAgICAgVGhlIHN0b3JlcHVibGljIHBhcmFtZXRlciBhbGxvd3MgdGhlIGNhbGxlciB0byBhc3NpZ24gcHVibGljIGFjY2Vzc1xuICAgICAgICAgKiAgICAgICB0byBlYWNoIHN0b3JlZCBmaWxlIGluIHRoZSByZXBvc2l0b3J5IGFmdGVyIHRoZSBleGVjdXRpb24gY29tcGxldGVzLlxuICAgICAgICAgKiAgICA8L2xpPlxuICAgICAgICAgKiAgICA8bGk+XG4gICAgICAgICAqICAgICAgIFRoZSBzdG9yZW5vcHJvamVjdCBwYXJhbWV0ZXIgYWxsb3dzIHRoZSBjYWxsZXIgdG8gc2tpcCB0aGVcbiAgICAgICAgICogICAgICAgcGVyc2lzdGVuY2UtdG8tcHJvamVjdCBzdGVwIGFmdGVyIHRoZSBleGVjdXRpb24uXG4gICAgICAgICAqICAgIDwvbGk+XG4gICAgICAgICAqIDwvb2w+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgam9iU2NoZWR1bGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIHRoZSBjYWxsIGNvbmZpZ3VyYXRpb24uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiA8ZGw+XG4gICAgICAgICAqICAgIDxkdD5uYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPmpvYiBuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmRlc2NyPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgam9iIGRlc2NyaXB0aW9uPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnNjaGVkc3RhcnQ8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgdGhlIHN0YXJ0IHRpbWUgZm9yIGpvYjwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zY2hlZHJlcGVhdDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGpvYiBpcyB0byBiZSByZXBlYXRlZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zY2hlZGludGVydmFsPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIHRoZSBpbnRlcnZhbCAobXMpIG9uIHdoaWNoIGpvYiBpcyB0byBiZSByZXBlYXRlZDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5jb2RlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgUiBjb2RlIHRvIGV4ZWN1dGUgb24gam9iPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnJzY3JpcHRuYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeS1tYW5hZ2VkIHNjcmlwdCBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cnNjcmlwdGRpcmVjdG9yeTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHJlcG9zaXRvcnktbWFuYWdlZCBkaXJlY3RvcmllcyBmb3Igc2NyaXB0cywgZGVmYXVsdHMgdG8gcm9vdDwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5yc2NyaXB0YXV0aG9yPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgYXV0aG9ycywgYXV0aG9yLXBlci1yc2NyaXB0bmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5yc2NyaXB0dmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHZlcnNpb25zLCB2ZXJzaW9uLXBlci1yc2NyaXB0bmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5leHRlcm5hbHNvdXJjZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIFVSTHMgb3IgZmlsZSBwYXRocyB0byBleHRlcm5hbCBzY3JpcHRzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmlucHV0czwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIFJldm9EZXBsb3lSLWVuY29kZWQgc2NyaXB0IGlucHV0czwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5jc3ZpbnB1dHM8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBwcmltaXRpdmUgbmFtZS92YWx1ZSBpbnB1dHM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZGZpbGVuYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeSBmaWxlbmFtZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+cHJlbG9hZGZpbGVhdXRob3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhdXRob3JzLCBhdXRob3ItcGVyLXByZWxvYWRmaWxlbmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5wcmVsb2FkZmlsZXZlcnNpb248L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiB2ZXJzaW9ucywgdmVyc2lvbi1wZXItcHJlbG9hZGZpbGVuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRvYmplY3RuYW1lPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgcmVwb3NpdG9yeSBvYmplY3QgKC5yRGF0YSkgZmlsZW5hbWVzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRvYmplY3RhdXRob3I8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBhdXRob3JzLCBhdXRob3ItcGVyLXByZWxvYWRvYmplY3RuYW1lPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnByZWxvYWRvYmplY3R2ZXJzaW9uPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdmVyc2lvbnMsIHZlcnNpb24tcGVyLW9iamVjdC1wcmVsb2Fkb2JqZWN0bmFtZTwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5hZG9wdHdvcmtzcGFjZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlkZW50aWZpZXMgcHJvamVjdCBmcm9tIHdoaWNoIHdvcmtzcGFjZSBpcyB0byBiZSBhZG9wdGVkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PmFkb3B0ZGlyZWN0b3J5PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWRlbnRpZmllcyBwcm9qZWN0IGZyb20gd2hpY2ggZGlyZWN0b3J5IGlzIHRvIGJlIGFkb3B0ZWQ8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+YWRvcHRwYWNrYWdlczwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlkZW50aWZpZXMgcHJvamVjdCBmcm9tIHdoaWNoIHBhY2thZ2UgZGVwZW5kZW5jaWVzIGFyZSB0byBiZSBhZG9wdGVkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgICA8ZHQ+cHJpb3JpdHk8L2R0PlxuICAgICAgICAgKiAgICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyB0aGUgc2NoZWR1bGluZyBwcmlvcml0eSBmb3IgdGhlIGpvYjogbG93IChkZWZhdWx0KSwgbWVkaXVtIG9yIGhpZ2g8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+dGFnPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgc3BlY2lmaWVzIGEgdGFnIHRoYXQgbGFiZWxzIHRoZSBleGVjdXRpb248L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+ZWNob29mZjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiB0cnVlIFIgY29tbWFuZHMgd2lsbCBub3QgYXBwZWFyIGluIHRoZSBjb25zb2xlIG91dHB1dFxuICAgICAgICAgKiAgICAgICBzYXZlZCBvbiB0aGUgcHJvamVjdCBleGVjdXRpb24gaGlzdG9yeSBmb3IgdGhlIGpvYlxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+Y29uc29sZW9mZjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiB0cnVlIGNvbnNvbGUgb3V0cHV0IGlzIG5vdCBzYXZlZCBvbiB0aGUgcHJvamVjdFxuICAgICAgICAgKiAgICAgICBleGVjdXRpb24gaGlzdG9yeSBmb3IgdGhlIGpvYlxuICAgICAgICAgKiAgICA8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+Z3JhcGhpY3M8L2R0PlxuICAgICAgICAgKiAgICA8ZGQ+KG9wdGlvbmFsKSBzcGVjaWZpZXMgcHJlZmVycmVkIFIgZ3JhcGhpY3MgZGV2aWNlIGZvciBleGVjdXRpb246IHBuZyBvciBzdmc8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+Z3JhcGhpY3N3aWR0aDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBwcmVmZXJyZWQgd2lkdGggZm9yIFIgZ3JhcGhpY3MgZGV2aWNlIGltYWdlczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5ncmFwaGljc2hlaWdodDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIHNwZWNpZmllcyBwcmVmZXJyZWQgaGVpZ2h0IGZvciBSIGdyYXBoaWNzIGRldmljZSBpbWFnZXM8L2RkPlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICA8ZHQ+c3RvcmVmaWxlPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygd29ya2luZyBkaXJlY3RvcnkgZmlsZW5hbWVzPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnN0b3Jlb2JqZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygd29ya3NwYWNlIG9iamVjdCBuYW1lczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5zdG9yZXdvcmtzcGFjZTwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGZpbGVuYW1lICguckRhdGEpIHdoZXJlIHdvcmtzcGFjZSBjb250ZW50cyB3aWxsIGJlIHNhdmVkIGluIHRoZSByZXBvc2l0b3J5PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnN0b3JlbmV3dmVyc2lvbjwvZHQ+XG4gICAgICAgICAqICAgIDxkZD4ob3B0aW9uYWwpIGlmIDxjb2RlPnRydWU8L2NvZGU+LCBlbnN1cmVzIGVhY2ggZmlsZSBzdG9yZWQgaW4gcmVwb3NpdG9yeSByZXN1bHRzIGluIG5ldyB2ZXJzaW9uIGJlaW5nIGNyZWF0ZWQgaWYgbmVlZGVkPC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnN0b3JlcHVibGljPC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIHB1Ymxpc2hlcyBlYWNoIGZpbGUgc3RvcmVkIGluIHRoZSByZXBvc2l0b3J5PC9kZD5cbiAgICAgICAgICpcbiAgICAgICAgICogICAgPGR0PnN0b3Jlbm9wcm9qZWN0PC9kdD5cbiAgICAgICAgICogICAgPGRkPihvcHRpb25hbCkgaWYgPGNvZGU+dHJ1ZTwvY29kZT4sIG5vIHByb2plY3QgcGVyc2lzdGVuY2UgZm9sbG93aW5nIGpvYiBleGVjdXRpb248L2RkPlxuICAgICAgICAgKiA8L2RsPlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIGlvIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGpvYlNjaGVkdWxlOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7ICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9qb2Ivc2NoZWR1bGUnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIHF1ZXJpZXMgdGhlIGpvYiBzdGF0dXMuIFRoZSBzdGF0dXMgcHJvcGVydHkgd2lsbCBpbmRpY2F0ZSBvbmUgb2ZcbiAgICAgICAgICogdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAgICAgICAqXG4gICAgICAgICAqIFNjaGVkdWxlZCwgUXVldWVkLCBSdW5uaW5nLCBDb21wbGV0ZWQsIENhbmNlbGxpbmcsIENhbmNlbGxlZCwgSW50ZXJydXB0ZWQsXG4gICAgICAgICAqIEFib3J0ZWQsIEZhaWxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBqb2JRdWVyeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIGNhbGwgY29uZmlndXJhdGlvbi4gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICAgICAqIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+am9iPC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGpvYiBpZGVudGlmaWVyczwvZGQ+XG4gICAgICAgICAqXG4gICAgICAgICAqICAgIDxkdD5leHRlbmRlZDwvZHQ+XG4gICAgICAgICAqICAgIDxkZD5cbiAgICAgICAgICogICAgICAgKG9wdGlvbmFsKSBpZiB0cnVlLCBvbmx5IGpvYnMgaW4gYW4gZXh0ZW5kZWQtc3RhdGUgYXJlIGxpc3RlZCBpbiB0aGVcbiAgICAgICAgICogICAgICAgcmVzcG9uc2UgbWFya3VwXG4gICAgICAgICAqICAgIDwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgam9iUXVlcnk6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9qb2IvcXVlcnknLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGNhbmNlbHMgdGhlIHNwZWNpZmllZCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgam9icyBpbiBhbiBvcGVuLXN0YXRlIGNhbiBiZSBjYW5jZWxsZWQuIFRoZSBzZXQgb2Ygam9iIG9wZW4tc3RhdGVzIGFyZVxuICAgICAgICAgKiBzaG93biBoZXJlOlxuICAgICAgICAgKlxuICAgICAgICAgKiA8dWw+XG4gICAgICAgICAqICAgIDxsaT5TY2hlZHVsZWQgOiBqb2IgaXMgc2NoZWR1bGVkIGJ1dCBub3QgeWV0IHF1ZXVlZCBmb3IgcnVubmluZy48L2xpPlxuICAgICAgICAgKiAgICA8bGk+UXVldWVkIDogam9iIGlzIHF1ZXVlZCBmb3IgcnVubmluZy48L2xpPlxuICAgICAgICAgKiAgICA8bGk+UnVubmluZyA6IGpvYiBpcyBydW5uaW5nLjwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqIEBtZXRob2Qgam9iQ2FuY2VsXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgICA8ZHQ+am9iPC9kdD5cbiAgICAgICAgICogICAgPGRkPnNwZWNpZmllcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGpvYiBpZGVudGlmaWVyczwvZGQ+XG4gICAgICAgICAqIDwvZGw+XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW8gdHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgam9iQ2FuY2VsOiBmdW5jdGlvbihjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbygnL3Ivam9iL2xpc3QnLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjYWxsIGRlbGV0ZXMgdGhlIHNwZWNpZmllZCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgam9icyBpbiBvbmUgb2YgdGhlIGNvbXBsZXRlZC1zdGF0ZXMgY2FuIGJlIGRlbGV0ZWQuIFRoZSBzZXQgb2Ygam9iXG4gICAgICAgICAqIGNvbXBlbHRlZC1zdGF0ZXMgYXJlIHNob3duIGhlcmU6XG4gICAgICAgICAqXG4gICAgICAgICAqIDx1bD5cbiAgICAgICAgICogICAgPGxpPkNvbXBsZXRlZCA6IGpvYiBleGVjdXRpb24gaGFzIHJ1biB0byBzdWNjZXNzZnVsIGNvbXBsZXRpb24uPC9saT5cbiAgICAgICAgICogICAgPGxpPkludGVycnVwdGVkIDogam9iIGV4ZWN1dGlvbiBoYXMgYmVlbiBpbnRlcnJ1cHRlZC48L2xpPlxuICAgICAgICAgKiAgICA8bGk+Q2FuY2VsbGVkIDogam9iIGhhcyBiZWVuIGNhbmNlbGxlZC48L2xpPlxuICAgICAgICAgKiAgICA8bGk+QWJvcnRlZCA6IGpvYiBleGVjdXRpb24gaGFzIGJlZW4gYWJvcnRlZC48L2xpPlxuICAgICAgICAgKiAgICA8bGk+RmFpbGVkIDogam9iIGV4ZWN1dGlvbiBoYXMgcmVzdWx0ZWQgaW4gZmFpbHVyZS48L2xpPlxuICAgICAgICAgKiA8L3VsPlxuICAgICAgICAgKlxuICAgICAgICAgKiBKb2JzIGluIGFuIG9wZW4tc3RhdGUgbXVzdCBmaXJzdCBydW4gdG8gY29tcGxldGlvbiBvciBiZSBjYW5jZWxsZWQgYmVmb3JlXG4gICAgICAgICAqIHRoZXkgYXJlIGVsaWdpYmxlIGZvciBkZWxldGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogPGJsb2NrcXVvdGU+XG4gICAgICAgICAqICAgIEltcG9ydGFudCEgRGVsZXRpbmcgam9icyB3aWxsIG5vdCBkZWxldGUgdGhlIHByb2plY3RzIHRoYXQgcmVzdWx0ZWQgZnJvbVxuICAgICAgICAgKiAgICB0aG9zZSBqb2JzLlxuICAgICAgICAgKiA8L2Jsb2NrcXVvdGU+XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2Qgam9iRGVsZXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyB0aGUgY2FsbCBjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogICAgICAgIHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAgICogPGRsPlxuICAgICAgICAgKiAgPGR0PmpvYjwvZHQ+XG4gICAgICAgICAqICA8ZGQ+c3BlY2lmaWVzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2Ygam9iIGlkZW50aWZpZXJzPC9kZD5cbiAgICAgICAgICogPC9kbD5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBpbyB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICBqb2JEZWxldGU6IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlvKCcvci9qb2IvZGVsZXRlJywgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9IC8vIERlcGxveVJcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXByZWNhdGVkOyIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlIFxuICogZGV0YWlscy5cbiAqL1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vc2VsZmlzaCcpLkJhc2U7XG5cbmZ1bmN0aW9uIGRlYnVnKG1zZykgeyB9XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoe1xuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgdGhpcy5zY29wZSAgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbGlzdGVuZXIuICBNdWx0aXBsZSBjYW4gYmUgYWRkZWQgcGVyIG5hbWUuICBBbGlhc2VkIGFzIGBvbmAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEEgY2FsbGJhY2tcbiAgICogQHJldHVybiB7RW1pdHRlcn0gYHRoaXNgIGZvciBjaGFpbmluZyAgICAgIFxuICAgKi9cbiAgb246IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAobmFtZSBpbiB0aGlzLmV2ZW50cyA9PT0gZmFsc2UpIHsgdGhpcy5ldmVudHNbbmFtZV0gPSBbXTsgfSAgICAgICAgXG5cbiAgICB0aGlzLmV2ZW50c1tuYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIGRlYnVnKCdFbWl0dGVyLm9uKFwiJyArIG5hbWUgKyAnXCIpJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYWxsIG1hdGNoaW5nIGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9IGB0aGlzYCBmb3IgY2hhaW5pbmcgICBcbiAgICovXG4gIGVtaXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiB0aGlzLmV2ZW50cyA9PT0gZmFsc2UpIHsgcmV0dXJuIHRoaXM7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudHNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKCdGaXJlZCBldmVudDogXCInICsgbmFtZSArICdcIicpO1xuICAgICAgdGhpcy5ldmVudHNbbmFtZV1baV0uYXBwbHkodGhpcy5zY29wZSB8fCB0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTsgICAgICAgXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIG1hdGNoaW5nIGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9IGB0aGlzYCBmb3IgY2hhaW5pbmdcbiAgICovXG4gIG9mZkFsbDogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgZm9yICh2YXIgZSBpbiB0aGlzLmV2ZW50cykge1xuICAgICAgICBkZWxldGUgdGhpcy5ldmVudHNbZV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuZXZlbnRzID09PSBmYWxzZSkgeyByZXR1cm4gdGhpczsgfVxuICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzW25hbWVdOyAgICAgICAgXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBiYXNlZCBvbiBhbiBpbmRleC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGV2ZW50IFxuICAgKi9cbiAgb2ZmQXQ6IGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5ldmVudHNbbmFtZV0sXG4gICAgICAgIHJlc3QgID0gYXJyYXkuc2xpY2UoaW5kZXggKyAxKTtcblxuICAgIGFycmF5Lmxlbmd0aCA9IGluZGV4O1xuICAgIGFycmF5LnB1c2guYXBwbHkoYXJyYXksIHJlc3QpO1xuICAgIHRoaXMuZXZlbnRzW25hbWVdID0gYXJyYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBiYXNlZCBvbiB0aGUgaGFuZGxlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIGhhbmRsZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAqIEByZXR1cm4ge0VtaXR0ZXJ9IGB0aGlzYCBmb3IgY2hhaW5pbmdcbiAgICovXG4gIG9mZjogZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgIGlmIChuYW1lIGluIHRoaXMuZXZlbnRzID09PSBmYWxzZSkgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBldmVudHMgaGFuZGxlcnMgYnkgdGhpcyBuYW1lXG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZBbGwobmFtZSk7XG4gICAgfSBlbHNlIHsgLy8gcmVtb3ZlIGFsbCBldmVudHMgaGFuZGxlcnMgPT0gJ2hhbmRsZXInIGJ5IHRoaXMgbmFtZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50c1tuYW1lXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5ldmVudHNbbmFtZV1baV0gPT0gaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMub2ZmQXQobmFtZSwgaSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IFxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufSk7ICIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlXG4gKiBkZXRhaWxzLlxuICovXG52YXIgTGFuZyA9IHJlcXVpcmUoJy4vbGFuZycpLFxuICAgIFJUeXBlcyA9IHJlcXVpcmUoJy4vcnR5cGVzJyksXG4gICAgUiA9IFJUeXBlcy5yLFxuICAgIERlcGxveVIgPSBSVHlwZXMuZGVwbG95cjtcblxuZnVuY3Rpb24gZm9ybWF0RGF0ZXMoZGF0ZXMsIHR5cGUpIHtcbiAgICB2YXIgZm9ybWF0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3JtYXRzLnB1c2goZm9ybWF0RGF0ZShkYXRlc1tpXSwgdHlwZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXRzO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIHR5cGUpIHsgICAgXG4gICB2YXIgeWVhciAgID0gZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgIG1vbnRoICA9IChkYXRlLmdldE1vbnRoKCkgKyAxKSxcbiAgICAgICBkYXkgICAgPSBkYXRlLmdldERhdGUoKSwgICAgXG4gICAgICAgaG91ciAgID0gZGF0ZS5nZXRIb3VycygpLFxuICAgICAgIG1pbiAgICA9IGRhdGUuZ2V0TWludXRlcygpLFxuICAgICAgIHNlYyAgICA9IGRhdGUuZ2V0U2Vjb25kcygpLFxuICAgICAgIHpvbmUgICA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICBmb3JtYXQgPSAnJztcblxuICAgICAgIG1vbnRoICA9IChtb250aCA8IDEwID8gJzAnICsgbW9udGggOiBtb250aCk7XG4gICAgICAgaG91ciAgID0gKGhvdXIgPCAxMCA/ICcwJyArIGhvdXIgOiBob3VyKTtcbiAgICAgICBtaW4gICAgPSAobWluIDwgMTAgPyAnMCcgKyBtaW4gOiBtaW4pO1xuICAgICAgIHNlYyAgICA9IChzZWMgPCAxMCA/ICcwJyArIHNlYyA6IHNlYyk7ICAgICAgIFxuICAgICAgIGZvcm1hdCA9IHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheTtcblxuICAgIGZ1bmN0aW9uIGxlZnRaZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG5cbiAgICAgICAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArIG91dHB1dDtcbiAgICB9XG4gICBcbiAgICBpZiAodHlwZSA9PT0gRGVwbG95Ui5SUE9TSVhfREFURSB8fCB0eXBlID09PSBEZXBsb3lSLlJQT1NJWF9EQVRFX1ZFQ1RPUikge1xuICAgICAgICB2YXIgdGltZSAgPSBob3VyICsgJzonICsgbWluICsgJzonICsgc2VjLFxuICAgICAgICAgICAgYSA9IC16b25lLFxuICAgICAgICAgICAgYiA9IFwiK1wiO1xuXG4gICAgICAgIGlmIChhIDwgMCkge1xuICAgICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgICAgYiA9IFwiLVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZSA9IGIgKyBsZWZ0WmVyb0ZpbGwoKGEgLyA2MCksIDIpICsgJycgKyBsZWZ0WmVyb0ZpbGwoYSAlIDYwLCAyKTtcbiAgICAgICAgZm9ybWF0ICs9ICgnICcgKyB0aW1lICsgJyAnICsgem9uZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlRW1iZWRkZWREYXRhZnJhbWUob2JqLCByZGYpIHtcbiAgICB2YXIgZGZWYWx1ZSA9IG9iai52YWx1ZTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZGZWYWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGRmT2JqID0gZGZWYWx1ZVtpbmRleF07XG4gICAgICAgIGlmIChkZk9iai50eXBlID09PSBEZXBsb3lSLlJEQVRBRlJBTUUpIHtcbiAgICAgICAgICAgIHJkZiA9IGVuY29kZUVtYmVkZGVkRGF0YWZyYW1lKGRmT2JqLCByZGYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZm9ybWF0IGRhdGVzXG4gICAgICAgICAgICBpZiAoUlR5cGVzLmlzRGF0ZShkZk9iai50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmIChMYW5nLmlzQXJyYXkoZGZPYmoudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRmT2JqLnZhbHVlID0gZm9ybWF0RGF0ZXMoZGZPYmoudmFsdWUsIGRmT2JqLnR5cGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRmT2JqLnZhbHVlID0gZm9ybWF0RGF0ZShkZk9iai52YWx1ZSwgZGZPYmoudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZk9iai50eXBlID0gUlR5cGVzLmRlcGxveXJUb1IoZGZPYmoudHlwZSk7XG4gICAgICAgICAgICByZGYudmFsdWUucHVzaChkZk9iaik7ICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgIH1cbiAgICByZXR1cm4gcmRmO1xufTtcblxuZnVuY3Rpb24gZW5jb2RlRGF0YWZyYW1lKG9iaikge1xuICAgIHZhciByZGYgPSB7XG4gICAgICAgICAgICB0eXBlOiBSLkRBVEFGUkFNRSxcbiAgICAgICAgICAgIHZhbHVlOiBbXSxcbiAgICAgICAgICAgIG5hbWU6IG9iai5uYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGRmVmFsdWUgPSBvYmoudmFsdWU7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZGZWYWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGRmT2JqID0gZGZWYWx1ZVtpbmRleF07XG5cbiAgICAgICAgaWYgKGRmT2JqLnR5cGUgPT09IERlcGxveVIuUkRBVEFGUkFNRSkge1xuICAgICAgICAgICAgcmRmID0gZW5jb2RlRW1iZWRkZWREYXRhZnJhbWUoZGZPYmosIHJkZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3JtYXQgZGF0ZXNcbiAgICAgICAgICAgIGlmIChSVHlwZXMuaXNEYXRlKGRmT2JqLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKExhbmcuaXNBcnJheShkZk9iai52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGZPYmoudmFsdWUgPSBmb3JtYXREYXRlcyhkZk9iai52YWx1ZSwgZGZPYmoudHlwZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGZPYmoudmFsdWUgPSBmb3JtYXREYXRlKGRmT2JqLnZhbHVlLCBkZk9iai50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRmT2JqLnR5cGUgPSBSVHlwZXMuZGVwbG95clRvUihkZk9iai50eXBlKTtcbiAgICAgICAgICAgIHJkZi52YWx1ZS5wdXNoKGRmT2JqKTtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiByZGY7XG59O1xuXG5mdW5jdGlvbiBlbmNvZGVMaXN0KG9iaikge1xuICAgIHZhciBybGlzdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFIuTElTVCxcbiAgICAgICAgICAgIHZhbHVlOiBbXSxcbiAgICAgICAgICAgIG5hbWU6IG9iai5uYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGRmVmFsdWUgPSBvYmoudmFsdWUsXG4gICAgICAgIHI7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZGZWYWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGRmT2JqID0gZGZWYWx1ZVtpbmRleF07XG5cbiAgICAgICAgc3dpdGNoIChkZk9iai50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIERlcGxveVIuUkRBVEFGUkFNRTpcbiAgICAgICAgICAgICAgICByID0gZW5jb2RlRGF0YWZyYW1lKGRmT2JqKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJMSVNUOlxuICAgICAgICAgICAgICAgIHIgPSBlbmNvZGVMaXN0KGRmT2JqKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJOVU1FUklDX01BVFJJWDpcbiAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5SSU5URUdFUl9NQVRSSVg6XG4gICAgICAgICAgICBjYXNlIERlcGxveVIuUkJPT0xFQU5fTUFUUklYOlxuICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJTVFJJTkdfTUFUUklYOlxuICAgICAgICAgICAgICAgIHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGRmT2JqLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFIuTUFUUklYLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGZPYmoudmFsdWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIERlcGxveVIuUkRBVEU6XG4gICAgICAgICAgICBjYXNlIERlcGxveVIuUlBPU0lYX0RBVEU6XG4gICAgICAgICAgICAgICAgciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGZPYmoubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUi5EQVRFLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGRmT2JqLmZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZvcm1hdERhdGUoZGZPYmoudmFsdWUsIGRmT2JqLnR5cGUpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJGQUNUT1I6XG4gICAgICAgICAgICBjYXNlIERlcGxveVIuUk9SREVSRUQ6XG4gICAgICAgICAgICAgICAgciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGZPYmoubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUi5GQUNUT1IsXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyZWQ6IGRmT2JqLm9yZGVyZWQsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsczogZGZPYmoubGFiZWxzLFxuICAgICAgICAgICAgICAgICAgICBsZXZlbHM6IGRmT2JqLmxldmVscyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRmT2JqLnZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJTVFJJTkc6XG4gICAgICAgICAgICBjYXNlIERlcGxveVIuUkJPT0xFQU46XG4gICAgICAgICAgICBjYXNlIERlcGxveVIuUk5VTUVSSUM6XG4gICAgICAgICAgICBjYXNlIERlcGxveVIuUklOVEVHRVI6XG4gICAgICAgICAgICAgICAgciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGZPYmoubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUi5QUklNSVRJVkUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZk9iai52YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5STlVNRVJJQ19WRUNUT1I6XG4gICAgICAgICAgICBjYXNlIERlcGxveVIuUklOVEVHRVJfVkVDVE9SOlxuICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJCT09MRUFOX1ZFQ1RPUjpcbiAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5SU1RSSU5HX1ZFQ1RPUjpcbiAgICAgICAgICAgICAgICByID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkZk9iai5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBSLlZFQ1RPUixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRmT2JqLnZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJEQVRFX1ZFQ1RPUjpcbiAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5SUE9TSVhfREFURV9WRUNUT1I6XG4gICAgICAgICAgICAgICAgciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGZPYmoubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUi5WRUNUT1IsICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZvcm1hdERhdGVzKGRmT2JqLnZhbHVlLCBkZk9iai50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBkZk9iai5mb3JtYXRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gUkRhdGFUeXBlIGZvdW5kIGZvciBcIicgKyBkZk9iai50eXBlICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBybGlzdC52YWx1ZS5wdXNoKHIpO1xuICAgIH1cbiAgICByZXR1cm4gcmxpc3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgZ2l2ZW4gPGNvZGU+UmV2b2x1dGlvbi5SRGF0YTwvY29kZT4gdHlwZSBpbnRvIGEgSlNPTiBzdHJpbmdcbiAgICAgKiByZXByZXNlbnRpbmcgdGhlXG4gICAgICogZXhwZWN0ZWQgRGVwbG95UiBpbnB1dCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHBhcnNlSW5wdXRzXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJkYXRhIEFuIEFycmF5IG9mIFJEYXRhIE9iamVjdHMgdG8gYmUgZmxhdHRlbmVkLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZsYXR0ZW5kIFJEYXRhIEpTT04gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgRGVwbG95UlxuICAgICAqICAgICAgICAgICAgICAgICAgaW5wdXQgZm9ybWF0LlxuICAgICAqL1xuICAgIGVuY29kZTogZnVuY3Rpb24ocmRhdGEpIHtcbiAgICAgICAgdmFyIHIgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcmRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gcmRhdGFbaW5kZXhdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9iai50eXBlKSB7IC8vIC0tIERlcGxveVIgVHlwZSAtLSAvL1xuXG4gICAgICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJEQVRBRlJBTUU6XG4gICAgICAgICAgICAgICAgICAgIHJbb2JqLm5hbWVdID0gZW5jb2RlRGF0YWZyYW1lKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJMSVNUOlxuICAgICAgICAgICAgICAgICAgICByW29iai5uYW1lXSA9IGVuY29kZUxpc3Qob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIERlcGxveVIuUk5VTUVSSUNfTUFUUklYOlxuICAgICAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5SSU5URUdFUl9NQVRSSVg6XG4gICAgICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJCT09MRUFOX01BVFJJWDpcbiAgICAgICAgICAgICAgICBjYXNlIERlcGxveVIuUlNUUklOR19NQVRSSVg6XG4gICAgICAgICAgICAgICAgICAgIHJbb2JqLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUi5NQVRSSVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2JqLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJEQVRFOlxuICAgICAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5SUE9TSVhfREFURTpcbiAgICAgICAgICAgICAgICAgICAgcltvYmoubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSLkRBVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IG9iai5mb3JtYXQsICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0RGF0ZShvYmoudmFsdWUsIG9iai50eXBlKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5SRkFDVE9SOlxuICAgICAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5ST1JERVJFRDogICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJbb2JqLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUi5GQUNUT1IsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkOiBvYmoub3JkZXJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogb2JqLmxhYmVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsczogb2JqLmxldmVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvYmoudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIERlcGxveVIuUlNUUklORzpcbiAgICAgICAgICAgICAgICBjYXNlIERlcGxveVIuUkJPT0xFQU46XG4gICAgICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJOVU1FUklDOlxuICAgICAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5SSU5URUdFUjpcbiAgICAgICAgICAgICAgICAgICAgcltvYmoubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSLlBSSU1JVElWRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvYmoudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIERlcGxveVIuUk5VTUVSSUNfVkVDVE9SOlxuICAgICAgICAgICAgICAgIGNhc2UgRGVwbG95Ui5SSU5URUdFUl9WRUNUT1I6XG4gICAgICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJCT09MRUFOX1ZFQ1RPUjpcbiAgICAgICAgICAgICAgICBjYXNlIERlcGxveVIuUlNUUklOR19WRUNUT1I6XG4gICAgICAgICAgICAgICAgICAgIHJbb2JqLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUi5WRUNUT1IsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2JqLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBEZXBsb3lSLlJEQVRFX1ZFQ1RPUjpcbiAgICAgICAgICAgICAgICBjYXNlIERlcGxveVIuUlBPU0lYX0RBVEVfVkVDVE9SOlxuICAgICAgICAgICAgICAgICAgICByW29iai5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFIuVkVDVE9SLCAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZvcm1hdERhdGVzKG9iai52YWx1ZSwgb2JqLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBvYmouZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBSRGF0YVR5cGUgZm91bmQgZm9yIFwiJyArIG9iai50eXBlICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChKU09OLnN0cmluZ2lmeShyKSk7XG4gICAgfVxufTsiLCIgdmFyIG9wdGlvbmFsID0gcmVxdWlyZSgnLi9vcHRpb25hbCcpLFxuICAgICBXUyAgICAgICA9IG9wdGlvbmFsKCd3cycpLFxuICAgICBRdWV1ZSAgICA9IHJlcXVpcmUoJy4vcXVldWUnKSwgICAgIFxuICAgICBFbWl0dGVyICA9IHJlcXVpcmUoJy4vZW1pdHRlcicpLFxuICAgICBCYXNlICAgICA9IHJlcXVpcmUoJy4vc2VsZmlzaCcpLkJhc2UsXG4gICAgIG1lcmdlICAgID0gcmVxdWlyZSgnLi91dGlscycpLm1lcmdlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEV2ZW50U3RyZWFtYCB3aXRoIHRoZSBnaXZlbiBzZXQgb2YgYG9wdGlvbnNgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIEV2ZW50U3RyZWFtID0gQmFzZS5leHRlbmQoRW1pdHRlciwgeyAgIFxuXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoaG9zdCwgb3B0aW9ucykge1xuICAgIEVtaXR0ZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHt9KTtcblxuICAgIHRoaXMuaG9zdCAgICAgICAgPSBob3N0O1xuICAgIHRoaXMub3B0aW9ucyAgICAgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5sb2cgPSB0aGlzLm9wdGlvbnMubG9nIHx8IHRoaXMuTE9HLmVycm9yO1xuICAgIHRoaXMud3MgICAgICAgICAgPSBudWxsO1xuICAgIHRoaXMucSAgICAgICAgICAgPSBuZXcgUXVldWUoKTtcbiAgICB0aGlzLmNoYW5uZWwgICAgID0ge307ICAgICBcbiAgfSwgIFxuXG4gIExPRzogeyBcbiAgICBpbmZvOiAnaW5mbycsIFxuICAgIGRlYnVnOiAnZGVidWcnLCBcbiAgICBlcnJvcjogJ2Vycm9yJyBcbiAgfSxcbiAgXG4gIG9wZW46IGZ1bmN0aW9uKG9wdGlvbnMpIHsgICAgXG4gICAgdmFyIHNlbGYgICA9IHRoaXMsXG4gICAgICAgIHVyaSAgICA9ICh0aGlzLmhvc3QgfHwgJycpICsgJy9kZXBsb3lyL3IvZXZlbnQvc3RyZWFtPycsXG4gICAgICAgIHBhcmFtcyA9IFtdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBtZXJnZShvcHRpb25zLCB0aGlzLmNoYW5uZWwpOyAgICBcblxuICAgIHRoaXMuY29va2llcyA9ICF0aGlzLmNvb2tpZXMgPyBvcHRpb25zLmhlYWRlcnMuQ29va2llIDogdGhpcy5jb29raWVzO1xuXG4gICAgLy8gLS0gYXBwZW5kIG9wdGlvbiBwYXJhbWV0ZXJzIC0tXG4gICAgaWYgKG9wdGlvbnMucHJvamVjdCkge1xuICAgICAgcGFyYW1zLnB1c2goJ3Byb2plY3Q9JyArIG9wdGlvbnMucHJvamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmpvYikge1xuICAgICAgICBwYXJhbXMucHVzaCgnam9iPScgKyBvcHRpb25zLmpvYik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWFuYWdlbWVudCkge1xuICAgICAgcGFyYW1zLnB1c2goJ21hbmFnZW1lbnRFdmVudE9ubHk9dHJ1ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5odHRwb25seSkge1xuICAgICAgICBwYXJhbXMucHVzaCgnaHR0cEV2ZW50T25seT10cnVlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy5yZXZvb25seSkge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKCdyZXZvRXZlbnRPbmx5PXRydWUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHVyaSArPSBwYXJhbXMuam9pbignJicpLnN1YnN0cigwKTtcbiAgICB1cmkgPSB1cmkucmVwbGFjZSgvXmh0dHAvLCd3cycpO1xuXG4gICAgdGhpcy5xLnlpZWxkKHRydWUpO1xuICAgIHRoaXMucS5hZGQoZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5jb29raWVzID8geyAnQ29va2llJzogdGhpcy5jb29raWVzIH0gOiB7fTtcbiAgICAgIHRoaXMuZW1pdCgnZXM6Y29ubmVjdGluZycsIHsgdXJpOiB1cmksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG5cbiAgICAgIHZhciB3cyA9IG5ldyBXUyh1cmksICdodHRwJywgeyBoZWFkZXJzOiBoZWFkZXJzIH0pO1xuXG4gICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBzZWxmLmVtaXQoJ2VzOm9wZW4nLCBtZXNzYWdlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfbWVzc2FnZSA9ICcnO1xuICAgICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdHJ5IHsgICAgICAgICAgXG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YS5zcGxpdCgnIXwhJylbMV0pIHtcbiAgICAgICAgICAgIF9tZXNzYWdlID0gX21lc3NhZ2UgKyBtZXNzYWdlLmRhdGEuc3BsaXQoJyF8IScpWzFdO1xuICAgICAgICAgICAgbWVzc2FnZSA9IEpTT04ucGFyc2UoX21lc3NhZ2UpO1xuICAgICAgICAgICAgX21lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWVzc2FnZS5kZXBsb3lyLnJlc3BvbnNlLmV2ZW50LnR5cGU7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2VzOicgKyB0eXBlLnJlcGxhY2UoJ0V2ZW50JywgJycpLCBtZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9IFxuICAgICAgfTtcblxuICAgICAgd3Mub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgc2VsZi5lbWl0KCdlczplcnJvcicsIGVycik7IH07XG4gICAgICB3cy5vbmNsb3NlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgc2VsZi5lbWl0KCdlczpkaXNjb25uZWN0JywgbWVzc2FnZSk7IH07XG5cbiAgICAgIHRoaXMud3MgPSB3cztcbiAgICB9LCB0aGlzKTtcblxuICAgIGlmIChvcHRpb25zLmZvcmNlKSB7IHRoaXMuZmx1c2goKTsgfVxuXG4gICAgcmV0dXJuIHRoaXM7ICAgIFxuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy53cykgeyB0aGlzLndzLmNsb3NlKCk7IH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGVycm9yOiBmdW5jdGlvbihmbikge1xuICAgIHRoaXMub24oJ2VzOmVycm9yJywgZm4pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sICBcblxuICBhbGw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2hhbm5lbCA9IHsgcmV2b29ubHk6IHRydWUgfTsgIC8vIHJldm9FdmVudE9ubHk9dHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2Vzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jaGFubmVsID0geyBodHRwb25seTogdHJ1ZSB9OyAvL2h0dHBFdmVudE9ubHk9dHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCkge1xuICAgIHRoaXMuY2hhbm5lbCA9IHsgcHJvamVjdDogcHJvamVjdCB9OyAvLyBwcm9qZWN0PTEyMzQ1XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBqb2I6IGZ1bmN0aW9uKGpvYikge1xuICAgIHRoaXMuY2hhbm5lbCA9IHsgam9iOiBqb2IgfTsgLy9qb2I9MTIzNDVcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG1hbmFnZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2hhbm5lbCA9IHsgbWFuYWdlbWVudDogdHJ1ZSB9OyAvL21hbmFnZW1lbnRFdmVudE9ubHk9dHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZmx1c2g6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucS55aWVsZChmYWxzZSk7XG4gICAgdGhpcy5xLmZsdXNoKCk7XG4gIH0sXG5cbiAgc2hhcmU6IGZ1bmN0aW9uKGNvb2tpZXMpIHtcbiAgICB0aGlzLmNvb2tpZXMgPSBjb29raWVzO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U3RyZWFtO1xuIiwiLyohXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBieSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgdGVybXMgb2YgVmVyc2lvbiAyLjAgb2YgdGhlXG4gKiBBcGFjaGUgTGljZW5zZS4gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIFdJVEhPVVRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVFksIElOQ0xVRElORyBUSE9TRSBPRiBOT04tSU5GUklOR0VNRU5ULFxuICogTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBQbGVhc2UgcmVmZXIgdG8gdGhlXG4gKiBBcGFjaGUgTGljZW5zZSAyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCkgZm9yIG1vcmUgXG4gKiBkZXRhaWxzLlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIGEgRGVwbG95UiBwb3J0IG9mIHl1aS1sYW5nLmpzIGJ5IFlhaG9vIVxuICpcbiAqIFNvZnR3YXJlIExpY2Vuc2UgQWdyZWVtZW50IChCU0QgTGljZW5zZSlcbiAqIENvcHlyaWdodCAoYykgMjAxMywgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIG9mIHRoaXMgc29mdHdhcmUgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3IgXG4gKiB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBcbiAqIGFyZSBtZXQ6XG4gKlxuICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIFxuICogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgXG4gKiBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgXG4gKiB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCBcbiAqIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFlhaG9vISBJbmMuIG5vciB0aGUgbmFtZXMgb2YgWVVJJ3MgY29udHJpYnV0b3JzIG1heSBiZSBcbiAqIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgXG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24gb2YgWWFob28hIEluYy5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIFxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSAgXG4gKiBQT1MgU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLyoqXG4gKiBQcm92aWRlcyBjb3JlIGxhbmd1YWdlIHV0aWxpdGVzIGFuZCBleHRlbnNpb25zIHVzZWQgdGhyb3VnaG91dCBEZXBsb3lSLlxuICpcbiAqIEBjbGFzcyBMYW5nXG4gKiBAc3RhdGljXG4gKi9cbnZhciBMID0ge30sIFxuXHRUT1NUUklORyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsIFxuXHRUWVBFUyA9IHtcdFxuXHRcdCd1bmRlZmluZWQnIDogJ3VuZGVmaW5lZCcsXG5cdFx0J251bWJlcicgOiAnbnVtYmVyJyxcblx0XHQnYm9vbGVhbicgOiAnYm9vbGVhbicsXG5cdFx0J3N0cmluZycgOiAnc3RyaW5nJyxcblx0XHQnW29iamVjdCBGdW5jdGlvbl0nIDogJ2Z1bmN0aW9uJyxcblx0XHQnW29iamVjdCBSZWdFeHBdJyA6ICdyZWdleHAnLFxuXHRcdCdbb2JqZWN0IEFycmF5XScgOiAnYXJyYXknLFxuXHRcdCdbb2JqZWN0IERhdGVdJyA6ICdkYXRlJyxcblx0XHQnW29iamVjdCBFcnJvcl0nIDogJ2Vycm9yJ1xuXHR9LCB1bnNhZmVOYXRpdmVzID0gZmFsc2U7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaXRlbSBpcyBudWxsLlxuICogQG1ldGhvZCBpc051bGxcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBvIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbyBpcyBudWxsLlxuICovXG5MLmlzTnVsbCA9IGZ1bmN0aW9uKG8pIHtcblx0cmV0dXJuIG8gPT09IG51bGw7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGl0ZW0gaXMgdW5kZWZpbmVkLlxuICogQG1ldGhvZCBpc1VuZGVmaW5lZFxuICogQHN0YXRpY1xuICogQHBhcmFtIG8gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBvIGlzIHVuZGVmaW5lZC5cbiAqL1xuTC5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG8pIHtcblx0cmV0dXJuIHR5cGVvZiBvID09PSAndW5kZWZpbmVkJztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaXRlbSBpcyBvZiB0eXBlIG9iamVjdFxuICogb3IgZnVuY3Rpb24uIE5vdGUgdGhhdCBhcnJheXMgYXJlIGFsc28gb2JqZWN0cywgc29cbiAqIDxjb2RlPlkuTGFuZy5pc09iamVjdChbXSkgPT09IHRydWU8L2NvZGU+LlxuICogQG1ldGhvZCBpc09iamVjdFxuICogQHN0YXRpY1xuICogQHBhcmFtIG8gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHBhcmFtIGZhaWxmbiB7Ym9vbGVhbn0gZmFpbCBpZiB0aGUgaW5wdXQgaXMgYSBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbyBpcyBhbiBvYmplY3QuXG4gKiBAc2VlIGlzUGxhaW5PYmplY3RcbiAqL1xuTC5pc09iamVjdCA9IGZ1bmN0aW9uKG8sIGZhaWxmbikge1xuXHR2YXIgdCA9IHR5cGVvZiBvO1xuXHRyZXR1cm4gKG8gJiYgKHQgPT09ICdvYmplY3QnIHx8ICghZmFpbGZuICYmICh0ID09PSAnZnVuY3Rpb24nIHx8IEwuaXNGdW5jdGlvbihvKSkpKSkgfHwgZmFsc2U7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlZCBpdGVtIGlzIGFuIGFycmF5LlxuICpcbiAqIFJldHVybnMgYGZhbHNlYCBmb3IgYXJyYXktbGlrZSBjb2xsZWN0aW9ucyBzdWNoIGFzIHRoZSBmdW5jdGlvbiBgYXJndW1lbnRzYFxuICogY29sbGVjdGlvbiBvciBgSFRNTEVsZW1lbnRgIGNvbGxlY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgaXNBcnJheVxuICogQHBhcmFtIG8gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBvIGlzIGFuIGFycmF5LlxuICogQHN0YXRpY1xuICovXG5MLmlzQXJyYXkgPSAoIXVuc2FmZU5hdGl2ZXMgJiYgQXJyYXkuaXNBcnJheSkgfHxcbmZ1bmN0aW9uKG8pIHtcblx0cmV0dXJuIEwudHlwZShvKSA9PT0gJ2FycmF5Jztcbn07XG5cbkwuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb25BKG8pIHtcblx0cmV0dXJuICh0eXBlb2YobykgPT09IFwiZnVuY3Rpb25cIik7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGl0ZW0gaXMgYSBib29sZWFuLlxuICogQG1ldGhvZCBpc0Jvb2xlYW5cbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBvIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbyBpcyBhIGJvb2xlYW4uXG4gKi9cbkwuaXNCb29sZWFuID0gZnVuY3Rpb24obykge1xuXHRyZXR1cm4gdHlwZW9mIG8gPT09ICdib29sZWFuJztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgc3VwcGxpZWQgaXRlbSBpcyBhIGRhdGUgaW5zdGFuY2UuXG4gKiBAbWV0aG9kIGlzRGF0ZVxuICogQHN0YXRpY1xuICogQHBhcmFtIG8gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBvIGlzIGEgZGF0ZS5cbiAqL1xuTC5pc0RhdGUgPSBmdW5jdGlvbihvKSB7XG5cdHJldHVybiBMLnR5cGUobykgPT09ICdkYXRlJyAmJiBvLnRvU3RyaW5nKCkgIT09ICdJbnZhbGlkIERhdGUnICYmICFpc05hTihvKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaXRlbSBpcyBhIGxlZ2FsIG51bWJlci5cbiAqIEBtZXRob2QgaXNOdW1iZXJcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBvIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbyBpcyBhIG51bWJlci5cbiAqL1xuTC5pc051bWJlciA9IGZ1bmN0aW9uKG8pIHtcblx0cmV0dXJuIHR5cGVvZiBvID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShvKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgaXRlbSBpcyBhIHN0cmluZy5cbiAqIEBtZXRob2QgaXNTdHJpbmdcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBvIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbyBpcyBhIHN0cmluZy5cbiAqL1xuTC5pc1N0cmluZyA9IGZ1bmN0aW9uKG8pIHtcblx0cmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgdGhlIGl0ZW0gcGFzc2VkIGluLlxuICpcbiAqIEBtZXRob2QgdHlwZVxuICogQHBhcmFtIG8gdGhlIGl0ZW0gdG8gdGVzdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRldGVjdGVkIHR5cGUuXG4gKiBAc3RhdGljXG4gKi9cbkwudHlwZSA9IGZ1bmN0aW9uKG8pIHtcblx0cmV0dXJuIFRZUEVTWyB0eXBlb2Ygb10gfHwgVFlQRVNbVE9TVFJJTkcuY2FsbChvKV0gfHwgKCBvID8gJ29iamVjdCcgOiAnbnVsbCcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMOyIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlIFxuICogZGV0YWlscy5cbiAqL1xuIFxudmFyIExvZ2dlciA9IHt9LFxuICAgIGxvZ2dlck1hcCA9IHt9LFxuICAgIGdsb2JhbExvZ2dlcjtcblxuLyoqXG4gKiBVbml2ZXJzYWwgc3Rkb3V0fHN0ZGVyciBwcmludGVyXG4gKi9cbmZ1bmN0aW9uIGxvZyhtZXNzYWdlcywgY29udGV4dCkge1x0XG5cdGlmICghY29uc29sZSkgeyByZXR1cm47IH1cblxuXHRmdW5jdGlvbiBzZXAobGV2ZWwpIHtcblx0XHR2YXIgc2VwID0gJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PScgK1xuXHRcdCAgICAgICAgICAnPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuJyxcblx0XHQgICAgb2Zmc2V0ID0gMDtcblxuXHRcdGlmIChsZXZlbCA9PT0gTG9nZ2VyLkRFQlVHIHx8IGxldmVsID09PSBMb2dnZXIuRVJST1IpIG9mZnNldCA9IDg7XG5cdFx0ZWxzZSBpZiAobGV2ZWwgPT09IExvZ2dlci5JTkZPIHx8IGxldmVsID09PSBMb2dnZXIuV0FSTikgb2Zmc2V0ID0gODtcblx0XHRlbHNlIG9mZnNldCA9IDc7XG5cblx0XHRyZXR1cm4geyBzdGFydDogc2VwLnN1YnN0cmluZyhvZmZzZXQpLCBlbmQ6IHNlcCB9O1xuXHR9XG5cblx0dmFyIGhkbHIsXG5cdCAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZXMsIDApLFxuXHQgICAgbmFtZSA9IGNvbnRleHQubmFtZSxcblx0ICAgIGVycm9yID0gY29udGV4dC5sZXZlbCA9PT0gTG9nZ2VyLkVSUk9SLFxuICBcdCAgICBkZWxpbSA9IHNlcChjb250ZXh0LmxldmVsKTtcblxuICBcdGlmIChjb250ZXh0LmxldmVsID09PSBMb2dnZXIuV0FSTiAmJiBjb25zb2xlLndhcm4pIHtcbiAgXHRcdGhkbHIgPSAnd2Fybic7XG4gIFx0fSBlbHNlIGlmIChjb250ZXh0LmxldmVsID09PSBMb2dnZXIuRVJST1IgJiYgY29uc29sZS5lcnJvcikge1xuICBcdFx0aGRsciA9ICdlcnJvcic7XG4gIFx0fSBlbHNlIGlmIChjb250ZXh0LmxldmVsID09PSBMb2dnZXIuSU5GTyAmJiBjb25zb2xlLmluZm8pIHtcbiAgXHRcdGhkbHIgPSAnaW5mbyc7XG4gIFx0fSBlbHNlIHtcbiAgXHRcdGhkbHIgPSAnbG9nJztcbiAgXHR9XG5cbiAgXHQvLyAtLSBjdXN0b20gZm9ybWF0IGxvZ2dpbmcgc3RhdGVtZW50IGZvciBkZXBsb3lyIHJlcXVlc3QvcmVzcG9uc2UvZXJyb3IgLS1cbiAgXHRhcmdzLnVuc2hpZnQoJ1snICsgKGVycm9yID8gTG9nZ2VyLkVSUk9SLm5hbWUgOiBuYW1lKSArICddICcgKyBkZWxpbS5zdGFydCk7XG4gIFx0YXJncy5wdXNoKGRlbGltLmVuZCk7XG5cbiAgXHRjb25zb2xlW2hkbHJdKGFyZ3NbMF0sIFthcmdzWzFdICsgJyAtLS0+ICcgKyBhcmdzWzJdWydjYWxsJ11dKTtcblxuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJncy5sZW5ndGg7IGkrKykgeyBjb25zb2xlLmxvZyhhcmdzW2ldKTsgfSAgXG59XG5cbi8qKlxuICogTG9nZ2luZyBjYXRlZ29yeSBieSBpZC5cbiAqL1xuZnVuY3Rpb24gQ2F0ZWdvcnkoaWQsIGxldmVsLCBmbikge1xuXHR0aGlzLmlkID0gaWQ7XG5cdHRoaXMuY29udGV4dCA9IGxldmVsIHx8IExvZ2dlci5ERUJVRztcbn1cblxuQ2F0ZWdvcnkucHJvdG90eXBlID0ge1x0XG5cdGxvZzogZnVuY3Rpb24obGV2ZWwsIG1zZ0FyZ3MpIHtcblx0XHRpZiAobGV2ZWwudmFsdWUgPj0gdGhpcy5jb250ZXh0LnZhbHVlKSB7XHRcdFx0XG5cdFx0XHRsb2cobXNnQXJncywgeyBcblx0XHRcdFx0bGV2ZWw6IGxldmVsLFxuXHRcdFx0XHRuYW1lOiB0aGlzLmNvbnRleHQubmFtZSxcblx0XHRcdFx0dmFsdWU6IHRoaXMuY29udGV4dC52YWx1ZVxuXHRcdFx0fSk7XHRcdFxuXHRcdH1cblx0fSxcblxuXHRkZWJ1ZzogZnVuY3Rpb24gKCkge1x0XHRcblx0XHR0aGlzLmxvZyhMb2dnZXIuREVCVUcsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0ZXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmxvZyhMb2dnZXIuRVJST1IsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0aW5mbzogZnVuY3Rpb24gKCkge1x0XHRcblx0XHR0aGlzLmxvZyhMb2dnZXIuSU5GTywgYXJndW1lbnRzKTtcblx0fSxcblxuXHR3YXJuOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5sb2coTG9nZ2VyLldBUk4sIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0c2V0TGV2ZWw6IGZ1bmN0aW9uKGxldmVsKSB7XG5cdFx0aWYgKGxldmVsICYmICd2YWx1ZScgaW4gbGV2ZWwpIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IGxldmVsO1xuXHRcdH1cblx0fVxufTtcblxuTG9nZ2VyLkRFQlVHID0geyB2YWx1ZTogMSwgbmFtZTogJ0RFQlVHJyB9O1xuTG9nZ2VyLklORk8gID0geyB2YWx1ZTogMiwgbmFtZTogJ0lORk8nIH07XG5Mb2dnZXIuV0FSTiAgPSB7IHZhbHVlOiA0LCBuYW1lOiAnV0FSTicgfTtcbkxvZ2dlci5FUlJPUiA9IHsgdmFsdWU6IDgsIG5hbWU6ICdFUlJPUicgfTtcbkxvZ2dlci5PRkYgICA9IHsgdmFsdWU6IDk5LCBuYW1lOiAnT0ZGJyB9OyAgIFx0XHRcblxuTG9nZ2VyLnNldExldmVsID0gZnVuY3Rpb24obmV3TGV2ZWwpIHtcblx0Z2xvYmFsTG9nZ2VyLnNldExldmVsKG5ld0xldmVsKTtcbn07XG5cbkxvZ2dlci5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcblx0Z2xvYmFsTG9nZ2VyLmRlYnVnLmFwcGx5KGdsb2JhbExvZ2dlciwgYXJndW1lbnRzKTtcbn07XG5cbkxvZ2dlci5pbmZvID0gZnVuY3Rpb24gKCkge1xuXHRnbG9iYWxMb2dnZXIuaW5mby5hcHBseShnbG9iYWxMb2dnZXIsIGFyZ3VtZW50cyk7XG59O1xuXG5Mb2dnZXIud2FybiA9IGZ1bmN0aW9uICgpIHtcblx0Z2xvYmFsTG9nZ2VyLndhcm4uYXBwbHkoZ2xvYmFsTG9nZ2VyLCBhcmd1bWVudHMpO1xufTtcblxuTG9nZ2VyLmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRnbG9iYWxMb2dnZXIuZXJyb3IuYXBwbHkoZ2xvYmFsTG9nZ2VyLCBhcmd1bWVudHMpO1xufTtcblxuTG9nZ2VyLmdldCA9IGZ1bmN0aW9uIChpZCwgbGV2ZWwsIGZuKSB7XHRcblx0cmV0dXJuIChsb2dnZXJNYXBbaWRdIHx8IChmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJNYXBbaWRdID0gbmV3IENhdGVnb3J5KGlkLCBsZXZlbCwgZm4pO1xuXHRcdHJldHVybiBsb2dnZXJNYXBbaWRdO1xuXHR9KSgpKTtcbn07XG5cbi8vIC0tLSBzZXR1cCB0aGUgZ2xvYmFsIGxvZ2dlciAtLS1cbmdsb2JhbExvZ2dlciA9IExvZ2dlci5nZXQoJ2dsb2JhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyBcdD0gTG9nZ2VyO1xuIiwiLyohXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBieSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGxpY2Vuc2VkIHRvIHlvdSB1bmRlciB0aGUgdGVybXMgb2YgVmVyc2lvbiAyLjAgb2YgdGhlXG4gKiBBcGFjaGUgTGljZW5zZS4gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIFdJVEhPVVRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVFksIElOQ0xVRElORyBUSE9TRSBPRiBOT04tSU5GUklOR0VNRU5ULFxuICogTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBQbGVhc2UgcmVmZXIgdG8gdGhlXG4gKiBBcGFjaGUgTGljZW5zZSAyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMCkgZm9yIG1vcmUgXG4gKiBkZXRhaWxzLlxuICovXG4gXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKG1vZHVsZSk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59OyIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlIFxuICogZGV0YWlscy5cbiAqL1xuXG5mdW5jdGlvbiBRdWV1ZSgpIHtcbiAgdGhpcy5lbXB0eUNhbGxiYWNrID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgdGhpcy55aWVsZGVkID0gZmFsc2U7XG4gIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICB0aGlzLnJlc3BvbnNlQ2hhaW4gPSBbXTsgIFxufVxuXG5RdWV1ZS5wcm90b3R5cGUgPSB7XG5cbiAgYWRkOiBmdW5jdGlvbihmbiwgY3R4LCBkZWZlcikge1xuICAgIC8vIGN1cnJlbnRseSBub3Qgd2FpdGluZyBhbmQgdGhlcmUgaXMgbm8gZGVmZXIgZGVsYXkganVzdCBtYWtlIGNhbGxcbiAgICBpZiAoIXRoaXMueWllbGRlZCAmJiAhZGVmZXIpIHsgICAgICBcbiAgICAgIGZuLmFwcGx5KGN0eCB8fCB0aGlzLCBbdGhpcy5yZXNwb25zZV0pO1xuICAgIH0gZWxzZSB7IC8vIGFkZCB0byBxdWV1ZVxuICAgICAgdGhpcy5jYWxsYmFja3MucHVzaCh7IGZuOiBmbiwgY3R4OiBjdHggfSk7XG4gICAgfVxuICB9LFxuXG4gIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrcy5sZW5ndGg7XG4gIH0sXG5cbiAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tzLmxlbmd0aCA9PT0gMDtcbiAgfSxcblxuICBlbXB0eTogZnVuY3Rpb24oZm4sIGN0eCkge1xuICAgIHRoaXMuZW1wdHlDYWxsYmFjayA9IHsgZm46IGZuLCBjdHg6IGN0eCB9O1xuICB9LFxuXG4gIHlpZWxkOiBmdW5jdGlvbih5aWVsZCkge1xuICAgIHRoaXMueWllbGRlZCA9IHlpZWxkO1xuICB9LFxuXG4gIHRha2U6IGZ1bmN0aW9uKHJlc3BvbnNlLCBlcnJvciwgYXJncykgeyBcbiAgICB2YXIgY2I7XG5cbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgIHRoaXMucmVzcG9uc2VDaGFpbi5wdXNoKHJlc3BvbnNlKTtcbiAgICB9XG5cblxuICAgIGlmICghdGhpcy55aWVsZGVkICYmIHRoaXMuY2FsbGJhY2tzWzBdKSB7XG4gICAgICBjYiA9IHRoaXMuY2FsbGJhY2tzLnNoaWZ0KCk7XG4gICAgICBjYi5mbi5hcHBseShjYi5jdHggfHwgdGhpcywgW3RoaXMucmVzcG9uc2VDaGFpbiwgZXJyb3IsIGFyZ3NdKTtcblxuICAgICAgLy8gbm90aWZ5IHRoYXQgdGhlIHF1ZXVlIGlzIG5vdyBlbXB0eSAgIFxuICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzWzBdICYmIHRoaXMuZW1wdHlDYWxsYmFjaykge1xuICAgICAgICB0aGlzLmVtcHR5Q2FsbGJhY2suZm4uY2FsbCh0aGlzLmVtcHR5Q2FsbGJhY2suY3R4IHx8IHRoaXMpOyAgICAgICAgIFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXG4gIGZsdXNoOiBmdW5jdGlvbihyZXNwb25zZSwgZXJyb3IsIGFyZ3MpIHsgICAgICAgIFxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgdGhpcy5yZXNwb25zZUNoYWluLnB1c2gocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIC8vIHBvcCBhbmQgY2FsbCBuZXh0IGlubGluZVxuICAgIHdoaWxlICh0aGlzLmNhbGxiYWNrc1swXSkge1xuICAgICAgaWYgKHRoaXMueWllbGRlZCkgeyBicmVhazsgfVxuICAgICAgdmFyIGNiID0gdGhpcy5jYWxsYmFja3Muc2hpZnQoKTtcbiAgICAgIGNiLmZuLmFwcGx5KGNiLmN0eCB8fCB0aGlzLCBbdGhpcy5yZXNwb25zZUNoYWluLCBlcnJvciwgYXJnc10pO1xuXG4gICAgICAvLyBub3RpZnkgdGhhdCB0aGUgcXVldWUgaXMgbm93IGVtcHR5XG4gICAgICBpZiAodGhpcy5jYWxsYmFja3NbMF0gJiYgdGhpcy5lbXB0eUNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZW1wdHlDYWxsYmFjay5mbi5jYWxsKHRoaXMuZW1wdHlDYWxsYmFjay5jdHggfHwgdGhpcyk7ICAgICAgICAgXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlOyIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlIFxuICogZGV0YWlscy5cbiAqL1xuXG52YXIgQmFzZSAgID0gcmVxdWlyZSgnLi9zZWxmaXNoJykuQmFzZSxcbiAgICBSVHlwZXMgPSByZXF1aXJlKCcuL3J0eXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2UuZXh0ZW5kKFJUeXBlcywge1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7ICBcdFxuXHRcdHRoaXMubmFtZSAgPSBuYW1lO1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHR9LFxuXG5cdG51bWVyaWM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoe1xuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJOVU1FUklDLFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLCBcblx0XHRcdHZhbHVlOiB0aGlzLnZhbHVlLFxuXHRcdFx0dG9TdHJpbmc6IHRoaXMudG9TdHJpbmdcblx0XHR9KTtcblx0fSxcdFxuXG5cdGludGVnZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoeyBcblx0XHRcdHR5cGU6IHRoaXMuZGVwbG95ci5SSU5URUdFUixcblx0XHRcdG5hbWU6IHRoaXMubmFtZSwgXG5cdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSxcblx0XHRcdHRvU3RyaW5nOiB0aGlzLnRvU3RyaW5nXG5cdFx0fSk7IFxuXHR9LFxuXHRcblx0bG9naWNhbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmFzc2VydCh7IFxuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJCT09MRUFOLCBcblx0XHRcdG5hbWU6IHRoaXMubmFtZSwgXG5cdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSxcblx0XHRcdHRvU3RyaW5nOiB0aGlzLnRvU3RyaW5nXG5cdFx0fSk7IFxuXHR9LFxuXHRcblx0Y2hhcmFjdGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXNzZXJ0KHsgXG5cdFx0XHR0eXBlOiB0aGlzLmRlcGxveXIuUlNUUklORywgXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsIFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSxcblx0XG5cdGRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoeyBcblx0XHRcdHR5cGU6IHRoaXMuZGVwbG95ci5SREFURSxcblx0XHRcdG5hbWU6IHRoaXMubmFtZSwgXG5cdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSxcblx0XHRcdGZvcm1hdDogJ3l5eXktTU0tZGQnLFxuXHRcdFx0dG9TdHJpbmc6IHRoaXMudG9TdHJpbmdcblx0XHR9KTsgXG5cdH0sXG5cblx0cG9zaXhjdDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmFzc2VydCh7IFxuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJQT1NJWF9EQVRFLCBcblx0XHRcdG5hbWU6IHRoaXMubmFtZSwgXG5cdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSxcblx0XHRcdGZvcm1hdDogJ3l5eXktTU0tZGQgSEg6bW06c3MgWicsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSxcdFxuXHRcblx0bnVtZXJpY1ZlY3RvcjogZnVuY3Rpb24gKCkgeyBcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoeyBcblx0XHRcdHR5cGU6IHRoaXMuZGVwbG95ci5STlVNRVJJQ19WRUNUT1IsXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsIFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSxcblx0XG5cdGludGVnZXJWZWN0b3I6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoeyBcblx0XHRcdHR5cGU6IHRoaXMuZGVwbG95ci5SSU5URUdFUl9WRUNUT1IsIFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLCBcblx0XHRcdHZhbHVlOiB0aGlzLnZhbHVlLFxuXHRcdFx0dG9TdHJpbmc6IHRoaXMudG9TdHJpbmdcblx0XHR9KTsgXG5cdH0sXG5cdFxuXHRsb2dpY2FsVmVjdG9yOiBmdW5jdGlvbiAoKSB7IFxuXHRcdHJldHVybiB0aGlzLmFzc2VydCh7IFxuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJCT09MRUFOX1ZFQ1RPUiwgXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsIFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSxcblx0XG5cdGNoYXJhY3RlclZlY3RvcjogZnVuY3Rpb24gKCkgeyBcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoeyBcblx0XHRcdHR5cGU6IHRoaXMuZGVwbG95ci5SU1RSSU5HX1ZFQ1RPUiwgXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsIFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSwgIFxuXHRcblx0ZGF0ZVZlY3RvcjogZnVuY3Rpb24gKCkgeyBcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoeyBcblx0XHRcdHR5cGU6IHRoaXMuZGVwbG95ci5SREFURV9WRUNUT1IsIFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLCBcblx0XHRcdHZhbHVlOiB0aGlzLnZhbHVlLFxuXHRcdFx0Zm9ybWF0OiAneXl5eS1NTS1kZCcsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSxcdFxuXHRcblx0cG9zaXhjdFZlY3RvcjogZnVuY3Rpb24gKCkgeyBcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoeyBcblx0XHRcdHR5cGU6IHRoaXMuZGVwbG95ci5SUE9TSVhfREFURV9WRUNUT1IsIFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLCBcblx0XHRcdHZhbHVlOiB0aGlzLnZhbHVlLFxuXHRcdFx0Zm9ybWF0OiAneXl5eS1NTS1kZCBISDptbTpzcyBaJyxcblx0XHRcdHRvU3RyaW5nOiB0aGlzLnRvU3RyaW5nXG5cdFx0fSk7IFxuXHR9LFxuXHRcblx0bGlzdDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmFzc2VydCh7IFxuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJMSVNULCBcblx0XHRcdG5hbWU6IHRoaXMubmFtZSwgXG5cdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSxcblx0XHRcdHRvU3RyaW5nOiB0aGlzLnRvU3RyaW5nXG5cdFx0fSk7IFxuXHR9LFxuXHRcblx0ZGF0YWZyYW1lOiBmdW5jdGlvbiAoKSB7IFxuXHRcdHJldHVybiB0aGlzLmFzc2VydCh7IFxuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJEQVRBRlJBTUUsIFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLCBcblx0XHRcdHZhbHVlOiB0aGlzLnZhbHVlLFxuXHRcdFx0dG9TdHJpbmc6IHRoaXMudG9TdHJpbmdcblx0XHR9KTsgXG5cdH0sXG5cblx0ZmFjdG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoIHsgXG5cdFx0XHR0eXBlOiB0aGlzLmRlcGxveXIuUkZBQ1RPUiwgXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsIFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUsXG5cdFx0XHRvcmRlcmVkOiBmYWxzZSxcblx0XHRcdGxldmVsczogb3B0cy5sZXZlbHMsXG5cdFx0XHRsYWJlbHM6IG9wdHMubGFiZWxzLFxuXHRcdFx0dG9TdHJpbmc6IHRoaXMudG9TdHJpbmdcblx0XHR9KTsgXG5cdH0sXG5cblx0b3JkZXJlZDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0cmV0dXJuIHRoaXMuYXNzZXJ0KCB7IFxuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJPUkRFUkVELCBcblx0XHRcdG5hbWU6IHRoaXMubmFtZSwgXG5cdFx0XHR2YWx1ZTogdGhpcy52YWx1ZSxcblx0XHRcdG9yZGVyZWQ6IHRydWUsXG5cdFx0XHRsZXZlbHM6IG9wdHMubGV2ZWxzLFxuXHRcdFx0bGFiZWxzOiBvcHRzLmxhYmVscyxcblx0XHRcdHRvU3RyaW5nOiB0aGlzLnRvU3RyaW5nXG5cdFx0fSk7IFxuXHR9LFx0XHRcblxuXHRudW1lcmljTWF0cml4OiBmdW5jdGlvbiAoKSB7IFxuXHRcdHJldHVybiB0aGlzLmFzc2VydCh7IFxuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJOVU1FUklDX01BVFJJWCwgXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsIFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSxcblxuXHRpbnRlZ2VyTWF0cml4OiBmdW5jdGlvbiAoKSB7IFxuXHRcdHJldHVybiB0aGlzLmFzc2VydCh7IFxuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJJTlRFR0VSX01BVFJJWCwgXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsIFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSxcblxuXHRsb2dpY2FsTWF0cml4OiBmdW5jdGlvbiAoKSB7IFxuXHRcdHJldHVybiB0aGlzLmFzc2VydCh7IFxuXHRcdFx0dHlwZTogdGhpcy5kZXBsb3lyLlJCT09MRUFOX01BVFJJWCwgXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsIFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSxcblxuXHRjaGFyYWN0ZXJNYXRyaXg6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnQoeyBcblx0XHRcdHR5cGU6IHRoaXMuZGVwbG95ci5SU1RSSU5HX01BVFJJWCwgXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsIFxuXHRcdFx0dmFsdWU6IHRoaXMudmFsdWUsXG5cdFx0XHR0b1N0cmluZzogdGhpcy50b1N0cmluZ1xuXHRcdH0pOyBcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdHMgICA9IHRoaXMub3B0aW9ucyB8fCB7fSxcblx0XHQgICAgbGV2ZWxzID0gb3B0cy5sZXZlbHMgPyAnWyBsZXZlbHMgPSAnICsgb3B0cy5sZXZlbHMgKyAnXScgOiAnJyxcblx0XHQgICAgbGFiZWxzID0gb3B0cy5sYWJlbHMgPyAnWyBsYWJlbHMgPSAnICsgb3B0cy5sYWJlbHMgKyAnXScgOiAnJztcblxuXHRcdHJldHVybiAnWyBuYW1lID0gJyAgKyB0aGlzLm5hbWUgKyAnIF0gJyArXG5cdFx0ICAgICAgICdbIHZhbHVlID0gJyArIHRoaXMudmFsdWUgKyAnIF0gJyArXG5cdFx0ICAgICAgICdbIHR5cGUgPSAnICArIHRoaXMudHlwZSArICcgXSAnICtcblx0XHQgICAgICAgbGV2ZWxzICsgbGFiZWxzO1x0XHQgICAgICAgXG5cdH1cbn0pOyIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlIFxuICogZGV0YWlscy5cbiAqL1xuXG52YXIgQmFzZSAgID0gcmVxdWlyZSgnLi9zZWxmaXNoJykuQmFzZSxcbiAgICBSVHlwZXMgPSByZXF1aXJlKCcuL3J0eXBlcycpLFxuICAgIExhbmcgICA9IHJlcXVpcmUoJy4vbGFuZycpLFxuICAgIFJJbnB1dCA9IHJlcXVpcmUoJy4vcmlucHV0Jyk7IFxuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSwgbmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcblx0dmFyIHJpbnB1dDtcblxuXHRpZiAoTGFuZy5pc09iamVjdChuYW1lKSkge1xuXHRcdHJpbnB1dCA9IG5hbWU7XG5cdFx0aWYgKCFyaW5wdXQudHlwZSAhPT0gdHlwZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsQXJndW1lbnRFcnJvcjonICsgXG5cdFx0XHRcdCdFeHBlY3RpbmcgXCInICsgdHlwZSArICdcIiBidXQgZm91bmQgXCInICsgcmlucHV0LnR5cGUgKyAnXCInKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdCAgICByaW5wdXQgPSBSSW5wdXQubmV3KG5hbWUsIHZhbHVlLCBvcHRpb25zKVt0eXBlXSgpO1xuXHR9IFxuXG5cdHJldHVybiByaW5wdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoUlR5cGVzLCB7XHRcblx0bnVtZXJpYzogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5pbnB1dHMucHVzaChjcmVhdGUodGhpcy5kZXBsb3lyLlJOVU1FUklDLCBuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRcblx0aW50ZWdlcjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5pbnB1dHMucHVzaChjcmVhdGUodGhpcy5kZXBsb3lyLlJJTlRFR0VSLCBuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzOyBcblx0fSxcblx0XG5cdGxvZ2ljYWw6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuaW5wdXRzLnB1c2goY3JlYXRlKHRoaXMuZGVwbG95ci5SQk9PTEVBTiwgbmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpczsgXG5cdH0sXG5cdFxuXHRjaGFyYWN0ZXI6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuaW5wdXRzLnB1c2goY3JlYXRlKHRoaXMuZGVwbG95ci5SU1RSSU5HLCBuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzOyBcblx0fSxcblx0XG5cdGRhdGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuaW5wdXRzLnB1c2goY3JlYXRlKHRoaXMuZGVwbG95ci5SREFURSwgbmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpczsgXG5cdH0sXG5cblx0cG9zaXhjdDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5pbnB1dHMucHVzaChjcmVhdGUodGhpcy5kZXBsb3lyLlJQT1NJWF9EQVRFLCBuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzOyBcblx0fSxcdFxuXHRcblx0bnVtZXJpY1ZlY3RvcjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IFxuXHRcdHRoaXMuaW5wdXRzLnB1c2goY3JlYXRlKHRoaXMuZGVwbG95ci5STlVNRVJJQ19WRUNUT1IsIG5hbWUsIHZhbHVlKSk7XG5cdFx0cmV0dXJuIHRoaXM7IFxuXHR9LFxuXHRcblx0aW50ZWdlclZlY3RvcjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5pbnB1dHMucHVzaChjcmVhdGUodGhpcy5kZXBsb3lyLlJJTlRFR0VSX1ZFQ1RPUiwgbmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpczsgXG5cdH0sXG5cdFxuXHRsb2dpY2FsVmVjdG9yOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHsgXG5cdFx0dGhpcy5pbnB1dHMucHVzaChjcmVhdGUodGhpcy5kZXBsb3lyLlJCT09MRUFOX1ZFQ1RPUiwgbmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpczsgXG5cdH0sXG5cdFxuXHRjaGFyYWN0ZXJWZWN0b3I6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcblx0XHR0aGlzLmlucHV0cy5wdXNoKGNyZWF0ZSh0aGlzLmRlcGxveXIuUlNUUklOR19WRUNUT1IsIG5hbWUsIHZhbHVlKSk7XG5cdFx0cmV0dXJuIHRoaXM7IFxuXHR9LCAgXG5cdFxuXHRkYXRlVmVjdG9yOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHsgXG5cdFx0dGhpcy5pbnB1dHMucHVzaChjcmVhdGUodGhpcy5kZXBsb3lyLlJEQVRFX1ZFQ1RPUiwgbmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpczsgXG5cdH0sXHRcblx0XG5cdHBvc2l4Y3RWZWN0b3I6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcblx0XHR0aGlzLmlucHV0cy5wdXNoKGNyZWF0ZSh0aGlzLmRlcGxveXIuUlBPU0lYX0RBVEVfVkVDVE9SLCBuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzOyBcblx0fSxcblx0XG5cdGxpc3Q6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuaW5wdXRzLnB1c2goY3JlYXRlKHRoaXMuZGVwbG95ci5STElTVCwgbmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpczsgXG5cdH0sXG5cdFxuXHRkYXRhZnJhbWU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcblx0XHR0aGlzLmlucHV0cy5wdXNoKGNyZWF0ZSh0aGlzLmRlcGxveXIuUkRBVEFGUkFNRSwgbmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpczsgXG5cdH0sXHRcblxuXHRmYWN0b3I6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgbGV2ZWxzLCBsYWJlbHMpIHtcblx0XHR2YXIgb3B0cyA9IHsgbGV2ZWxzOiBsZXZlbHMsIGxhYmVsczogbGFiZWxzIH07XG5cdFx0dGhpcy5pbnB1dHMucHVzaChjcmVhdGUodGhpcy5kZXBsb3lyLlJGQUNUT1IsIG5hbWUsIHZhbHVlLCBvcHRzKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b3JkZXJlZDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBsZXZlbHMsIGxhYmVscykge1xuXHRcdHZhciBvcHRzID0geyBsZXZlbHM6IGxldmVscywgbGFiZWxzOiBsYWJlbHMgfTtcblx0XHR0aGlzLmlucHV0cy5wdXNoKGNyZWF0ZSh0aGlzLmRlcGxveXIuUk9SREVSRUQsIG5hbWUsIHZhbHVlLCBvcHRzKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXHRcdFxuXG5cdG51bWVyaWNNYXRyaXg6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkgeyBcblx0XHR0aGlzLmlucHV0cy5wdXNoKGNyZWF0ZSh0aGlzLmRlcGxveXIuUk5VTUVSSUNfTUFUUklYLCBuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzOyBcblx0fSxcblxuXHRpbnRlZ2VyTWF0cml4OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHsgXG5cdFx0dGhpcy5pbnB1dHMucHVzaChjcmVhdGUodGhpcy5kZXBsb3lyLlJJTlRFR0VSX01BVFJJWCwgbmFtZSwgdmFsdWUpKTtcblx0XHRyZXR1cm4gdGhpczsgXG5cdH0sXG5cblx0bG9naWNhbE1hdHJpeDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IFxuXHRcdHRoaXMuaW5wdXRzLnB1c2goY3JlYXRlKHRoaXMuZGVwbG95ci5SQk9PTEVBTl9NQVRSSVgsIG5hbWUsIHZhbHVlKSk7XG5cdFx0cmV0dXJuIHRoaXM7IFxuXHR9LFxuXG5cdGNoYXJhY3Rlck1hdHJpeDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5pbnB1dHMucHVzaChjcmVhdGUodGhpcy5kZXBsb3lyLlJTVFJJTkdfTUFUUklYLCBuYW1lLCB2YWx1ZSkpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTsiLCIvKiFcbiAqIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IGJ5IFJldm9sdXRpb24gQW5hbHl0aWNzIEluYy5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgbGljZW5zZWQgdG8geW91IHVuZGVyIHRoZSB0ZXJtcyBvZiBWZXJzaW9uIDIuMCBvZiB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlLiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVFxuICogQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5UWSwgSU5DTFVESU5HIFRIT1NFIE9GIE5PTi1JTkZSSU5HRU1FTlQsXG4gKiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFBsZWFzZSByZWZlciB0byB0aGVcbiAqIEFwYWNoZSBMaWNlbnNlIDIuMCAoaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wKSBmb3IgbW9yZSBcbiAqIGRldGFpbHMuXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL3NlbGZpc2gnKS5CYXNlLFxuICAgIExhbmcgPSByZXF1aXJlKCcuL2xhbmcnKSxcbiAgICBtYXAgID0ge307IC8vIGRlcGxveXItPlRvLT5SIGNhdGFsb2dcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlLmV4dGVuZCh7XG5cdHI6IHtcblx0XHRQUklNSVRJVkU6ICdwcmltaXRpdmUnLFxuXHRcdERBVEFGUkFNRTogJ2RhdGFmcmFtZScsXG5cdFx0TElTVDogJ2xpc3QnLFxuXHRcdE1BVFJJWDogJ21hdHJpeCcsXG5cdFx0REFURTogJ2RhdGUnLFxuXHRcdEZBQ1RPUjogJ2ZhY3RvcicsXG5cdFx0VkVDVE9SOiAndmVjdG9yJ1xuXHR9LFxuXG5cdGRlcGxveXI6IHtcblx0XHRSQk9PTEVBTjogJ2xvZ2ljYWwnLFxuXHRcdFJOVU1FUklDOiAnbnVtZXJpYycsXG5cdFx0UklOVEVHRVI6ICdpbnRlZ2VyJyxcblx0XHRSU1RSSU5HOiAnY2hhcmFjdGVyJyxcblx0XHRSREFURTogJ2RhdGUnLFxuXHRcdFJQT1NJWF9EQVRFOiAncG9zaXhjdCcsXG5cdFx0UkJPT0xFQU5fVkVDVE9SOiAnbG9naWNhbFZlY3RvcicsXG5cdFx0Uk5VTUVSSUNfVkVDVE9SOidudW1lcmljVmVjdG9yJyxcblx0XHRSSU5URUdFUl9WRUNUT1I6ICdpbnRlZ2VyVmVjdG9yJyxcdFxuXHRcdFJTVFJJTkdfVkVDVE9SOiAnY2hhcmFjdGVyVmVjdG9yJyxcblx0XHRSREFURV9WRUNUT1I6ICdkYXRlVmVjdG9yJyxcblx0XHRSUE9TSVhfREFURV9WRUNUT1I6ICdwb3NpeGN0VmVjdG9yJyxcblx0XHRSTElTVDogJ2xpc3QnLFxuXHRcdFJEQVRBRlJBTUU6ICdkYXRhZnJhbWUnLFxuXHRcdFJGQUNUT1I6ICdmYWN0b3InLFxuXHRcdFJPUkRFUkVEOiAnb3JkZXJlZCcsXHRcdFxuXHRcdFJCT09MRUFOX01BVFJJWDogJ2xvZ2ljYWxNYXRyaXgnLFxuXHRcdFJOVU1FUklDX01BVFJJWDogJ251bWVyaWNNYXRyaXgnLFxuXHRcdFJJTlRFR0VSX01BVFJJWDogJ2ludGVnZXJNYXRyaXgnLFx0XHRcblx0XHRSU1RSSU5HX01BVFJJWDogJ2NoYXJhY3Rlck1hdHJpeCdcblx0fSxcblxuXHRpc0RhdGU6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRyZXR1cm4gKHR5cGUgPT09IHRoaXMuZGVwbG95ci5SREFURSB8fCBcblx0XHQgICAgICAgIHR5cGUgPT09IHRoaXMuZGVwbG95ci5SUE9TSVhfREFURSB8fCBcblx0XHQgICAgICAgIHR5cGUgPT09IHRoaXMuZGVwbG95ci5SREFURV9WRUNUT1IgfHxcblx0XHQgICAgICAgIHR5cGUgPT09IHRoaXMuZGVwbG95ci5SUE9TSVhfREFURV9WRUNUT1IgfHxcblx0XHQgICAgICAgIHR5cGUgPT09IHRoaXMuci5EQVRFKTtcblx0fSxcblxuXHRkZXBsb3lyVG9SOiBmdW5jdGlvbih0eXBlKSB7XHRcblx0XHR2YXIgZGVwbG95ciA9IHRoaXMuZGVwbG95cixcblx0XHQgICAgciAgICAgICA9IHRoaXMucjtcblxuXHRcdGlmICghbWFwW3R5cGVdKSB7IC8vIGJ1aWxkIGNhdGFsb2cgb25seSBvbmNlXHRcblx0XHRcdG1hcFtkZXBsb3lyLlJCT09MRUFOXSAgICAgICAgICAgPSByLlBSSU1JVElWRTtcblx0XHRcdG1hcFtkZXBsb3lyLlJOVU1FUklDXSAgICAgICAgICAgPSByLlBSSU1JVElWRTtcblx0XHRcdG1hcFtkZXBsb3lyLlJJTlRFR0VSXSAgICAgICAgICAgPSByLlBSSU1JVElWRTtcblx0XHRcdG1hcFtkZXBsb3lyLlJTVFJJTkddICAgICAgICAgICAgPSByLlBSSU1JVElWRTtcblx0XHRcdG1hcFtkZXBsb3lyLlJEQVRFXSAgICAgICAgICAgICAgPSByLkRBVEU7XG5cdFx0XHRtYXBbZGVwbG95ci5SUE9TSVhfREFURV0gICAgICAgID0gci5EQVRFO1xuXHRcdFx0bWFwW2RlcGxveXIuUkJPT0xFQU5fVkVDVE9SXSAgICA9IHIuVkVDVE9SO1xuXHRcdFx0bWFwW2RlcGxveXIuUk5VTUVSSUNfVkVDVE9SXSAgICA9IHIuVkVDVE9SO1xuXHRcdFx0bWFwW2RlcGxveXIuUklOVEVHRVJfVkVDVE9SXSAgICA9IHIuVkVDVE9SO1xuXHRcdFx0bWFwW2RlcGxveXIuUlNUUklOR19WRUNUT1JdICAgICA9IHIuVkVDVE9SO1xuXHRcdFx0bWFwW2RlcGxveXIuUkRBVEVfVkVDVE9SXSAgICAgICA9IHIuVkVDVE9SO1xuXHRcdFx0bWFwW2RlcGxveXIuUlBPU0lYX0RBVEVfVkVDVE9SXSA9IHIuVkVDVE9SO1xuXHRcdFx0bWFwW2RlcGxveXIuUkxJU1RdICAgICAgICAgICAgICA9IHIuTElTVDtcblx0XHRcdG1hcFtkZXBsb3lyLlJEQVRBRlJBTUVdICAgICAgICAgPSByLkRBVEFGUkFNRTtcblx0XHRcdG1hcFtkZXBsb3lyLlJGQUNUT1JdICAgICAgICAgICAgPSByLkZBQ1RPUjtcblx0XHRcdG1hcFtkZXBsb3lyLlJPUkRFUkVEXSAgICAgICAgICAgPSByLkZBQ1RPUjtcblx0XHRcdG1hcFtkZXBsb3lyLlJCT09MRUFOX01BVFJJWF0gICAgPSByLk1BVFJJWDtcblx0XHRcdG1hcFtkZXBsb3lyLlJOVU1FUklDX01BVFJJWF0gICAgPSByLk1BVFJJWDtcblx0XHRcdG1hcFtkZXBsb3lyLlJJTlRFR0VSX01BVFJJWF0gICAgPSByLk1BVFJJWDtcblx0XHRcdG1hcFtkZXBsb3lyLlJTVFJJTkdfTUFUUklYXSAgICAgPSByLk1BVFJJWDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFwW3R5cGVdO1x0XHRcblx0fSxcblxuXHQvKipcblx0ICogQXNzZXJ0IHRoYXQgdGhlIGByaW5wdXRgIHZhbHVlIGlzIHRoZSBjb3JyZWN0IEphdmFTY3JpcHQgRGF0YSBUeXBlLlxuXHQgKi9cblx0YXNzZXJ0OiBmdW5jdGlvbiAocmlucHV0KSB7XG5cdFx0dmFyIGRlcGxveXIgPSB0aGlzLmRlcGxveXIsXG4gICAgXHRcdE5PT1AgICAgPSBudWxsLFxuXHRcdCAgICB2YWx1ZXMgID0gcmlucHV0LnZhbHVlLFxuXHRcdCAgICBmbjtcblxuXHRcdHZhbHVlcyA9ICFMYW5nLmlzQXJyYXkodmFsdWVzKSA/IFt2YWx1ZXNdIDogdmFsdWVzO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuXHRcdFx0c3dpdGNoIChyaW5wdXQudHlwZSkge1xuXHRcdFx0XHRjYXNlIGRlcGxveXIuUk5VTUVSSUMgOlxuXHRcdFx0XHRjYXNlIGRlcGxveXIuUk5VTUVSSUNfVkVDVE9SIDpcblx0XHRcdFx0Y2FzZSBkZXBsb3lyLlJOVU1FUklDX1ZFQ1RPUiA6XG5cdFx0XHRcdGZuID0gTGFuZy5pc051bWJlcjtcblx0XHRcdFx0Ly8gc3VwcG9ydCBzdHJpbmcgbnVtYmVyc1xuXHRcdFx0XHR2YXIgdmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdFx0XHQgICAgdmFsdWUgPSBpc05hTih2YWwpID8gdmFsdWUgOiB2YWw7IFxuXHRcdFx0ICAgIGJyZWFrO1xuXG5cdFx0XHQgICAgY2FzZSBkZXBsb3lyLlJJTlRFR0VSIDpcblx0XHRcdCAgICBjYXNlIGRlcGxveXIuUklOVEVHRVJfVkVDVE9SIDpcblx0XHRcdCAgICBmbiA9IExhbmcuaXNOdW1iZXI7XG5cdFx0XHQgICAgLy8gc3VwcG9ydCBzdHJpbmcgbnVtYmVyc1xuXHRcdFx0ICAgIHZhciB2YWwgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblx0XHRcdCAgICB2YWx1ZSA9IGlzTmFOKHZhbCkgPyB2YWx1ZSA6IHZhbDsgXG5cdFx0XHQgICAgYnJlYWs7XG5cblx0XHRcdCAgICBjYXNlIGRlcGxveXIuUkJPT0xFQU4gOlxuXHRcdFx0ICAgIGNhc2UgZGVwbG95ci5SQk9PTEVBTl9WRUNUT1IgOlxuXHRcdFx0ICAgIGZuID0gTGFuZy5pc0Jvb2xlYW47XG5cdFx0XHQgICAgYnJlYWs7XG5cdFx0XHQgICAgXG5cdFx0XHQgICAgY2FzZSBkZXBsb3lyLlJTVFJJTkcgOlxuXHRcdFx0ICAgIGNhc2UgZGVwbG95ci5SU1RSSU5HX1ZFQ1RPUiA6XHRcblx0XHRcdCAgICBmbiA9IExhbmcuaXNTdHJpbmc7XG5cdFx0XHQgICAgYnJlYWs7XG5cblx0XHRcdCAgICBjYXNlIGRlcGxveXIuUkRBVEUgOlxuXHRcdFx0ICAgIGNhc2UgZGVwbG95ci5SUE9TSVhfREFURSA6XG5cdFx0XHQgICAgY2FzZSBkZXBsb3lyLlJEQVRFX1ZFQ1RPUiA6XG5cdFx0XHQgICAgY2FzZSBkZXBsb3lyLlJQT1NJWF9EQVRFX1ZFQ1RPUiA6XG5cdFx0XHQgICAgZm4gPSBMYW5nLmlzRGF0ZTtcblx0XHRcdCAgICBicmVhaztcblxuXHRcdFx0ICAgIGNhc2UgZGVwbG95ci5SRkFDVE9SIDpcblx0XHRcdCAgICBjYXNlIGRlcGxveXIuUk9SREVSRUQgOlx0XHRcdCAgICBcblx0XHRcdCAgICBjYXNlIGRlcGxveXIuUkRBVEFGUkFNRSA6XG5cdFx0XHQgICAgY2FzZSBkZXBsb3lyLlJJTlRFR0VSX01BVFJJWCA6XG5cdFx0XHQgICAgY2FzZSBkZXBsb3lyLlJCT09MRUFOX01BVFJJWCA6XG5cdFx0XHQgICAgY2FzZSBkZXBsb3lyLlJTVFJJTkdfTUFUUklYIDpcdCAgICBcblx0XHRcdCAgICBmbiA9IE5PT1A7XG5cdFx0XHQgICAgYnJlYWtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGZuICYmICFmbih2YWx1ZSkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSSW5wdXRGb3JtYXRFcnJvcjogJyArICdcIicgKyB2YWx1ZSArIFxuXHRcdFx0XHRcdCdcIiBpcyBub3QgYSB2YWxpZCBcIicgKyByaW5wdXQudHlwZSArICdcIiB0eXBlLicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByaW5wdXQ7XG5cdH1cbn0pOyIsIi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL0dvemFsYS9zZWxmaXNoXG4gKi9cblxuLyogdmltOnNldCB0cz0yIHN3PTIgc3RzPTIgZXhwYW5kdGFiICovXG4vKmpzaGludCB1bmRlZjogdHJ1ZSBlczU6IHRydWUgbm9kZTogdHJ1ZSBkZXZlbDogdHJ1ZSBldmlsOiB0cnVlXG4gICAgICAgICBmb3JpbjogdHJ1ZSBsYXRlZGVmOiBmYWxzZSBzdXBlcm5ldzogdHJ1ZSAqL1xuLypnbG9iYWwgZGVmaW5lOiB0cnVlICovXG5cbiEodHlwZW9mIGRlZmluZSAhPT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24oJCl7ICQobnVsbCwgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHdpbmRvdyk7IH0gOiBkZWZpbmUpKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuQmFzZSA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYHRoaXNgIG9iamVjdCAoQW5hbG9nIG9mXG4gICAqIGBuZXcgT2JqZWN0KClgKS5cbiAgICogQGV4YW1wbGVzXG4gICAqXG4gICAqICAgIHZhciBEb2cgPSBCYXNlLmV4dGVuZCh7XG4gICAqICAgICAgYmFyazogZnVuY3Rpb24gYmFyaygpIHtcbiAgICogICAgICAgIHJldHVybiAnUnVmZiEgUnVmZiEnXG4gICAqICAgICAgfVxuICAgKiAgICB9KTtcbiAgICogICAgdmFyIGRvZyA9IERvZy5uZXcoKTtcbiAgICovXG4gICduZXcnOiB7IHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIG9iamVjdCA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgb2JqZWN0LmluaXRpYWxpemUuYXBwbHkob2JqZWN0LCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH19LFxuICAvKipcbiAgICogV2hlbiBuZXcgaW5zdGFuY2Ugb2YgdGhlIHRoaXMgcHJvdG90eXBlIGlzIGNyZWF0ZWQgaXQncyBgaW5pdGlhbGl6ZWBcbiAgICogbWV0aG9kIGlzIGNhbGxlZCB3aXRoIGFsbCB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgYG5ld2AuIFlvdSBjYW5cbiAgICogb3ZlcnJpZGUgYGluaXRpYWxpemVgIHRvIHNldCB1cCBhbiBpbnN0YW5jZS5cbiAgICovXG4gIGluaXRpYWxpemU6IHsgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gIH19LFxuICAvKipcbiAgICogTWVyZ2VzIGFsbCB0aGUgcHJvcGVydGllcyBvZiB0aGUgcGFzc2VkIG9iamVjdHMgaW50byBgdGhpc2AgaW5zdGFuY2UgKFRoaXNcbiAgICogbWV0aG9kIGNhbiBiZSB1c2VkIG9uIGluc3RhbmNlcyBvbmx5IGFzIHByb3RvdHlwZSBvYmplY3RzIGFyZSBmcm96ZW4pLlxuICAgKlxuICAgKiBJZiB0d28gb3IgbW9yZSBhcmd1bWVudCBvYmplY3RzIGhhdmUgb3duIHByb3BlcnRpZXMgd2l0aCB0aGUgc2FtZSBuYW1lLFxuICAgKiB0aGUgcHJvcGVydHkgaXMgb3ZlcnJpZGRlbiwgd2l0aCBwcmVjZWRlbmNlIGZyb20gcmlnaHQgdG8gbGVmdCwgaW1wbHlpbmcsXG4gICAqIHRoYXQgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IG9uIHRoZSBsZWZ0IGFyZSBvdmVycmlkZGVuIGJ5IGEgc2FtZSBuYW1lZFxuICAgKiBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IG9uIHRoZSByaWdodC5cbiAgICpcbiAgICogQGV4YW1wbGVzXG4gICAqXG4gICAqICAgIHZhciBQZXQgPSBEb2cuZXh0ZW5kKHtcbiAgICogICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICogICAgICAgIC8vIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSAtPiB3b3VsZCBoYXZlIHRocm93biAoZnJvemVuIHByb3RvdHlwZSlcbiAgICogICAgICAgIHRoaXMubWVyZ2Uob3B0aW9ucykgLy8gd2lsbCBvdmVycmlkZSBhbGwgcHJvcGVydGllcy5cbiAgICogICAgICB9LFxuICAgKiAgICAgIGNhbGw6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICogICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT09IG5hbWUgPyB0aGlzLmJhcmsoKSA6ICcnXG4gICAqICAgICAgfSxcbiAgICogICAgICBuYW1lOiBudWxsXG4gICAqICAgIH0pXG4gICAqICAgIHZhciBwZXQgPSBQZXQubmV3KHsgbmFtZTogJ0Jlbnp5JywgYnJlZWQ6ICdMYWJyYWRvcicgfSlcbiAgICogICAgcGV0LmNhbGwoJ0Jlbnp5JykgICAvLyAnUnVmZiEgUnVmZiEnXG4gICAqL1xuICBtZXJnZTogeyB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB7fTtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBkZXNjcmlwdG9yW25hbWVdID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm9wZXJ0aWVzLCBuYW1lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIGRlc2NyaXB0b3IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9fSxcbiAgLyoqXG4gICAqIFRha2VzIGFueSBudW1iZXIgb2YgYXJndW1lbnQgb2JqZWN0cyBhbmQgcmV0dXJucyBmcm96ZW4sIGNvbXBvc2l0ZSBvYmplY3RcbiAgICogdGhhdCBpbmhlcml0cyBmcm9tIGB0aGlzYCBvYmplY3QgYW5kIGNvbWJpbmVzIGFsbCBvZiB0aGUgb3duIHByb3BlcnRpZXMgb2ZcbiAgICogdGhlIGFyZ3VtZW50IG9iamVjdHMuIChPYmplY3RzIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gYXJlIGZyb3plbiBhc1xuICAgKiB0aGV5IGFyZSBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIHR5cGVzKS5cbiAgICpcbiAgICogSWYgdHdvIG9yIG1vcmUgYXJndW1lbnQgb2JqZWN0cyBoYXZlIG93biBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZSxcbiAgICogdGhlIHByb3BlcnR5IGlzIG92ZXJyaWRkZW4sIHdpdGggcHJlY2VkZW5jZSBmcm9tIHJpZ2h0IHRvIGxlZnQsIGltcGx5aW5nLFxuICAgKiB0aGF0IHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBvbiB0aGUgbGVmdCBhcmUgb3ZlcnJpZGRlbiBieSBhIHNhbWUgbmFtZWRcbiAgICogcHJvcGVydHkgb2YgdGhlIG9iamVjdCBvbiB0aGUgcmlnaHQuXG4gICAqIEBleGFtcGxlc1xuICAgKlxuICAgKiAgICAvLyAjIyBPYmplY3QgY29tcG9zaXRpb24gIyNcbiAgICpcbiAgICogICAgdmFyIEhFWCA9IEJhc2UuZXh0ZW5kKHtcbiAgICogICAgICBoZXg6IGZ1bmN0aW9uIGhleCgpIHtcbiAgICogICAgICAgIHJldHVybiAnIycgKyB0aGlzLmNvbG9yO1xuICAgKiAgICAgIH1cbiAgICogICAgfSlcbiAgICpcbiAgICogICAgdmFyIFJHQiA9IEJhc2UuZXh0ZW5kKHtcbiAgICogICAgICByZWQ6IGZ1bmN0aW9uIHJlZCgpIHtcbiAgICogICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLmNvbG9yLnN1YnN0cigwLCAyKSwgMTYpO1xuICAgKiAgICAgIH0sXG4gICAqICAgICAgZ3JlZW46IGZ1bmN0aW9uIGdyZWVuKCkge1xuICAgKiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuY29sb3Iuc3Vic3RyKDIsIDIpLCAxNik7XG4gICAqICAgICAgfSxcbiAgICogICAgICBibHVlOiBmdW5jdGlvbiBibHVlKCkge1xuICAgKiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuY29sb3Iuc3Vic3RyKDQsIDIpLCAxNik7XG4gICAqICAgICAgfVxuICAgKiAgICB9KVxuICAgKlxuICAgKiAgICB2YXIgQ01ZSyA9IEJhc2UuZXh0ZW5kKFJHQiwge1xuICAgKiAgICAgIGJsYWNrOiBmdW5jdGlvbiBibGFjaygpIHtcbiAgICogICAgICAgIHZhciBjb2xvciA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMucmVkKCksIHRoaXMuZ3JlZW4oKSksIHRoaXMuYmx1ZSgpKTtcbiAgICogICAgICAgIHJldHVybiAoMSAtIGNvbG9yIC8gMjU1KS50b0ZpeGVkKDQpO1xuICAgKiAgICAgIH0sXG4gICAqICAgICAgY3lhbjogZnVuY3Rpb24gY3lhbigpIHtcbiAgICogICAgICAgIHZhciBLID0gdGhpcy5ibGFjaygpO1xuICAgKiAgICAgICAgcmV0dXJuICgoKDEgLSB0aGlzLnJlZCgpIC8gMjU1KS50b0ZpeGVkKDQpIC0gSykgLyAoMSAtIEspKS50b0ZpeGVkKDQpO1xuICAgKiAgICAgIH0sXG4gICAqICAgICAgbWFnZW50YTogZnVuY3Rpb24gbWFnZW50YSgpIHtcbiAgICogICAgICAgIHZhciBLID0gdGhpcy5ibGFjaygpO1xuICAgKiAgICAgICAgcmV0dXJuICgoKDEgLSB0aGlzLmdyZWVuKCkgLyAyNTUpLnRvRml4ZWQoNCkgLSBLKSAvICgxIC0gSykpLnRvRml4ZWQoNCk7XG4gICAqICAgICAgfSxcbiAgICogICAgICB5ZWxsb3c6IGZ1bmN0aW9uIHllbGxvdygpIHtcbiAgICogICAgICAgIHZhciBLID0gdGhpcy5ibGFjaygpO1xuICAgKiAgICAgICAgcmV0dXJuICgoKDEgLSB0aGlzLmJsdWUoKSAvIDI1NSkudG9GaXhlZCg0KSAtIEspIC8gKDEgLSBLKSkudG9GaXhlZCg0KTtcbiAgICogICAgICB9XG4gICAqICAgIH0pXG4gICAqXG4gICAqICAgIHZhciBDb2xvciA9IEJhc2UuZXh0ZW5kKEhFWCwgUkdCLCBDTVlLLCB7XG4gICAqICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29sb3IoY29sb3IpIHtcbiAgICogICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICogICAgICB9XG4gICAqICAgIH0pO1xuICAgKlxuICAgKiAgICAvLyAjIyBQcm90b3R5cGFsIGluaGVyaXRhbmNlICMjXG4gICAqXG4gICAqICAgIHZhciBQaXhlbCA9IENvbG9yLmV4dGVuZCh7XG4gICAqICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gUGl4ZWwoeCwgeSwgaGV4KSB7XG4gICAqICAgICAgICBDb2xvci5pbml0aWFsaXplLmNhbGwodGhpcywgaGV4KTtcbiAgICogICAgICAgIHRoaXMueCA9IHg7XG4gICAqICAgICAgICB0aGlzLnkgPSB5O1xuICAgKiAgICAgIH0sXG4gICAqICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgKiAgICAgICAgcmV0dXJuIHRoaXMueCArICc6JyArIHRoaXMueSArICdAJyArIHRoaXMuaGV4KCk7XG4gICAqICAgICAgfVxuICAgKiAgICB9KTtcbiAgICpcbiAgICogICAgdmFyIHBpeGVsID0gUGl4ZWwubmV3KDExLCAyMywgJ0NDMzM5OScpXG4gICAqICAgIHBpeGVsLnRvU3RyaW5nKCk7IC8vIDExOjIzQCNDQzMzOTlcbiAgICpcbiAgICogICAgcGl4ZWwucmVkKCk7ICAgICAgLy8gMjA0XG4gICAqICAgIHBpeGVsLmdyZWVuKCk7ICAgIC8vIDUxXG4gICAqICAgIHBpeGVsLmJsdWUoKTsgICAgIC8vIDE1M1xuICAgKlxuICAgKiAgICBwaXhlbC5jeWFuKCk7ICAgICAvLyAwLjAwMDBcbiAgICogICAgcGl4ZWwubWFnZW50YSgpOyAgLy8gMC43NTAwXG4gICAqICAgIHBpeGVsLnllbGxvdygpOyAgIC8vIDAuMjUwMFxuICAgKlxuICAgKi9cbiAgIGV4dGVuZDogeyB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHRoaXMubWVyZ2UuYXBwbHkoT2JqZWN0LmNyZWF0ZSh0aGlzKSwgYXJndW1lbnRzKSk7XG4gIH19XG59KSk7XG5cbn0pOyIsIi8qIVxuICogQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgYnkgUmV2b2x1dGlvbiBBbmFseXRpY3MgSW5jLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBsaWNlbnNlZCB0byB5b3UgdW5kZXIgdGhlIHRlcm1zIG9mIFZlcnNpb24gMi4wIG9mIHRoZVxuICogQXBhY2hlIExpY2Vuc2UuIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRZLCBJTkNMVURJTkcgVEhPU0UgT0YgTk9OLUlORlJJTkdFTUVOVCxcbiAqIE1FUkNIQU5UQUJJTElUWSBPUiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gUGxlYXNlIHJlZmVyIHRvIHRoZVxuICogQXBhY2hlIExpY2Vuc2UgMi4wIChodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjApIGZvciBtb3JlXG4gKiBkZXRhaWxzLlxuICovXG5cbnZhciBMYW5nID0gcmVxdWlyZSgnLi9sYW5nJyk7XG5cbnZhciBnZXQgPSBleHBvcnRzLmdldCA9IGZ1bmN0aW9uKHMsIGtleSkge1xuICAgIGZ1bmN0aW9uIHRyYXZlcnNlKG9iaiwgZm4sIHBhcmVudCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIFtpLCBvYmpbaV0sIHBhcmVudF0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvYmpbaV0gaW5zdGFuY2VvZiBPYmplY3QgJiYgIShvYmpbaV0gaW5zdGFuY2VvZiBBcnJheSkpIHsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgdHJhdmVyc2Uob2JqW2ldLCBmbiwgaSk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBhY2MgPSB7fTtcbiAgICAgICAgdHJhdmVyc2Uob2JqLCBmdW5jdGlvbihrZXksIHZhbHVlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHByb3BlcnR5KSB7ICBcbiAgICAgICAgICAgICAgICBhY2MgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1wdHkob2JqKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7IGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHJldHVybiBvYmo7IH1cbiAgICAgICAgcmV0dXJuICFMYW5nLmlzT2JqZWN0KG9iaikgPyBvYmogOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBlbXB0eShnZXRQcm9wZXJ0eShzLCBrZXkpKTtcbn07XG5cbnZhciBpbkFycmF5ID0gZXhwb3J0cy5pbkFycmF5ID0gZnVuY3Rpb24oaGF5c3RhY2ssIG5lZWRsZSwga2V5KSB7XG4gICAgdmFyIGksIG1heCA9IGhheXN0YWNrLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaGF5c3RhY2tbaV1ba2V5XSA9PT0gbmVlZGxlKSB7IHJldHVybiBoYXlzdGFja1tpXTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhheXN0YWNrW2ldID09PSBuZWVkbGUpIHsgcmV0dXJuIGhheXN0YWNrW2ldOyB9XG4gICAgICAgIH0gICBcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24odG8sIGZyb20pIHsgICAgICAgIFxuICAgIGlmICghdG8gfHwgdHlwZW9mKHRvKSAhPT0gJ29iamVjdCcpIHsgdG8gPSB7fTsgfVxuICAgIGlmICghZnJvbSB8fCB0eXBlb2YoZnJvbSkgIT09ICdvYmplY3QnKSB7IGZyb20gPSB7fTsgfVxuXG4gICAgZm9yICh2YXIgayBpbiBmcm9tKSB7IHRvW2tdID0gZnJvbVtrXTsgfVxuXG4gICAgcmV0dXJuIHRvO1xufTtcblxuZXhwb3J0cy53b3Jrc3BhY2UgPSBmdW5jdGlvbihvYmosIG5hbWUpIHtcbiAgICB2YXIgd3MgPSBnZXQob2JqLCAnd29ya3NwYWNlJyk7XG4gICAgcmV0dXJuICh3cyA/IG5hbWUgPyBpbkFycmF5KHdzLm9iamVjdHMsIG5hbWUsICduYW1lJykgOiB3cy5vYmplY3RzIHx8IHdzLm9iamVjdDogbnVsbCk7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHNbJzAnXSwgMCksXG4gICAgICAgIGxlbiAgICA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICBjcmVhdGUgPSBmYWxzZSxcbiAgICAgICAgb3B0cyAgID0ge30sXG4gICAgICAgIGFwaTtcblxuICAgIGlmIChsZW4gPT09IDEgJiYgTGFuZy5pc09iamVjdChhcmdzWzBdKSkge1xuICAgICAgICBvcHRzID0gYXJnc1swXTtcbiAgICAgICAgYXBpICA9IG9wdHMucHJvamVjdCA/ICcvci9wcm9qZWN0L2V4ZWN1dGUvc2NyaXB0JyA6XG4gICAgICAgICAgICAnL3IvcmVwb3NpdG9yeS9zY3JpcHQvZXhlY3V0ZSc7XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDEgJiYgTGFuZy5pc1N0cmluZyhhcmdzWzBdKSkge1xuICAgICAgICBhcmdzID0gYXJnc1swXS5zcGxpdCgnXFwvJyk7XG4gICAgICAgIGFwaSAgPSAnL3IvcmVwb3NpdG9yeS9zY3JpcHQvZXhlY3V0ZSdcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgIGF1dGhvcjogYXJnc1sxXSxcbiAgICAgICAgICAgIGRpcmVjdG9yeTogYXJnc1syXSxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBhcmdzWzNdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gZXg6IC5zY3JpcHQoJy90ZXN0dXNlci9yb290L0RlcGxveVIgLSBIZWxsbyBXb3JsZC5SJywgcHJvamVjdClcbiAgICAgICAgdmFyIHByb2plY3QgPSBhcmdzWzFdO1xuICAgICAgICBhcGkgPSBwcm9qZWN0ID8gJy9yL3Byb2plY3QvZXhlY3V0ZS9zY3JpcHQnIDogJy9yL3JlcG9zaXRvcnkvc2NyaXB0L2V4ZWN1dGUnO1xuXG4gICAgICAgIGFyZ3MgPSBhcmdzWzBdLnNwbGl0KCdcXC8nKTtcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICAgIHByb2plY3Q6IHByb2plY3QsXG4gICAgICAgICAgICBhdXRob3I6IGFyZ3NbMV0sXG4gICAgICAgICAgICBkaXJlY3Rvcnk6IGFyZ3NbMl0sXG4gICAgICAgICAgICBmaWxlbmFtZTogYXJnc1szXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVuID4gMikge1xuICAgICAgICAvLyBleDogLnNjcmlwdCgnRGVwbG95UiAtIEhlbGxvIFdvcmxkLlInLCAndGVzdHVzZXInLCAncm9vdCcpXG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICBhdXRob3I6IGFyZ3NbMl0sXG4gICAgICAgICAgICBkaXJlY3Rvcnk6IGFyZ3NbMV0sXG4gICAgICAgICAgICBmaWxlbmFtZTogYXJnc1swXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGluZGljYXRlIGEgbmV3IHByb2plY3Qgc2hvdWxkIGJlIGNyZWF0ZWRcbiAgICBpZiAob3B0cy5wcm9qZWN0ICYmIExhbmcuaXNCb29sZWFuKG9wdHMucHJvamVjdCkpIHtcbiAgICAgIGRlbGV0ZSBvcHRzWydwcm9qZWN0J107XG4gICAgICBjcmVhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFwaTogYXBpLFxuICAgICAgICBvcHRzOiBvcHRzLFxuICAgICAgICBjcmVhdGU6IGNyZWF0ZVxuICAgIH07XG59OyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXInKTtcbnZhciByZWR1Y2UgPSByZXF1aXJlKCdyZWR1Y2UnKTtcblxuLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG52YXIgcm9vdCA9ICd1bmRlZmluZWQnID09IHR5cGVvZiB3aW5kb3dcbiAgPyB0aGlzXG4gIDogd2luZG93O1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcbiAqIHdlIGRvbid0IHdhbnQgdG8gc2VyaWFsaXplIHRoZXNlIDopXG4gKlxuICogVE9ETzogZnV0dXJlIHByb29mLCBtb3ZlIHRvIGNvbXBvZW50IGxhbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNIb3N0KG9iaikge1xuICB2YXIgc3RyID0ge30udG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIHN3aXRjaCAoc3RyKSB7XG4gICAgY2FzZSAnW29iamVjdCBGaWxlXSc6XG4gICAgY2FzZSAnW29iamVjdCBCbG9iXSc6XG4gICAgY2FzZSAnW29iamVjdCBGb3JtRGF0YV0nOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBYSFIuXG4gKi9cblxuZnVuY3Rpb24gZ2V0WEhSKCkge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdFxuICAgICYmICgnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2wgfHwgIXJvb3QuQWN0aXZlWE9iamVjdCkpIHtcbiAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjMuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgYWRkZWQgdG8gc3VwcG9ydCBJRS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHRyaW0gPSAnJy50cmltXG4gID8gZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH1cbiAgOiBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpOyB9O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG51bGwgIT0gb2JqW2tleV0pIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICAgICAgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxuIHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4gLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICB2YXIgb2JqID0ge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICB2YXIgcGFydHM7XG4gIHZhciBwYWlyO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwYXJ0cyA9IHBhaXIuc3BsaXQoJz0nKTtcbiAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFydHNbMV0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ2FwcGxpY2F0aW9uL3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybS1kYXRhJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzZXJpYWxpemF0aW9uIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24ob2JqKXtcbiAqICAgICAgIHJldHVybiAnZ2VuZXJhdGVkIHhtbCBoZXJlJztcbiAqICAgICB9O1xuICpcbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnN0cmluZ2lmeVxuIH07XG5cbiAvKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICB2YXIgaW5kZXg7XG4gIHZhciBsaW5lO1xuICB2YXIgZmllbGQ7XG4gIHZhciB2YWw7XG5cbiAgbGluZXMucG9wKCk7IC8vIHRyYWlsaW5nIENSTEZcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbWltZSB0eXBlIGZvciB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHlwZShzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJhbXMoc3RyKXtcbiAgcmV0dXJuIHJlZHVjZShzdHIuc3BsaXQoLyAqOyAqLyksIGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLylcbiAgICAgICwga2V5ID0gcGFydHMuc2hpZnQoKVxuICAgICAgLCB2YWwgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgaWYgKGtleSAmJiB2YWwpIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxuICpcbiAqICAtIHNldCBmbGFncyAoLm9rLCAuZXJyb3IsIGV0YylcbiAqICAtIHBhcnNlIGhlYWRlclxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICBBbGlhc2luZyBgc3VwZXJhZ2VudGAgYXMgYHJlcXVlc3RgIGlzIG5pY2U6XG4gKlxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcbiAqXG4gKiAgV2UgY2FuIHVzZSB0aGUgcHJvbWlzZS1saWtlIEFQSSwgb3IgcGFzcyBjYWxsYmFja3M6XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnLycpLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICogICAgICByZXF1ZXN0LmdldCgnLycsIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIFNlbmRpbmcgZGF0YSBjYW4gYmUgY2hhaW5lZDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAuc2VuZCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5wb3N0KClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBPciBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW5nbGUgY2FsbCBmb3Igc2ltcGxlIGNhc2VzOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIEBwYXJhbSB7WE1MSFRUUFJlcXVlc3R9IHhoclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5yZXEgPSByZXE7XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICB0aGlzLnRleHQgPSB0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgXG4gICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0IFxuICAgICA6IG51bGw7XG4gIHRoaXMuc2V0U3RhdHVzUHJvcGVydGllcyh0aGlzLnhoci5zdGF0dXMpO1xuICB0aGlzLmhlYWRlciA9IHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVyKHRoaXMueGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcbiAgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XG4gIC8vIGdldFJlc3BvbnNlSGVhZGVyIHN0aWxsIHdvcmtzLiBzbyB3ZSBnZXQgY29udGVudC10eXBlIGV2ZW4gaWYgZ2V0dGluZ1xuICAvLyBvdGhlciBoZWFkZXJzIGZhaWxzLlxuICB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gIHRoaXMuc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG4gIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICA/IHRoaXMucGFyc2VCb2R5KHRoaXMudGV4dClcbiAgICA6IG51bGw7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgLy8gY29udGVudC10eXBlXG4gIHZhciBjdCA9IHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSB8fCAnJztcbiAgdGhpcy50eXBlID0gdHlwZShjdCk7XG5cbiAgLy8gcGFyYW1zXG4gIHZhciBvYmogPSBwYXJhbXMoY3QpO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB0aGlzW2tleV0gPSBvYmpba2V5XTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGJvZHkgYHN0cmAuXG4gKlxuICogVXNlZCBmb3IgYXV0by1wYXJzaW5nIG9mIGJvZGllcy4gUGFyc2Vyc1xuICogYXJlIGRlZmluZWQgb24gdGhlIGBzdXBlcmFnZW50LnBhcnNlYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUucGFyc2VCb2R5ID0gZnVuY3Rpb24oc3RyKXtcbiAgdmFyIHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICByZXR1cm4gcGFyc2UgJiYgc3RyICYmIHN0ci5sZW5ndGhcbiAgICA/IHBhcnNlKHN0cilcbiAgICA6IG51bGw7XG59O1xuXG4vKipcbiAqIFNldCBmbGFncyBzdWNoIGFzIGAub2tgIGJhc2VkIG9uIGBzdGF0dXNgLlxuICpcbiAqIEZvciBleGFtcGxlIGEgMnh4IHJlc3BvbnNlIHdpbGwgZ2l2ZSB5b3UgYSBgLm9rYCBvZiBfX3RydWVfX1xuICogd2hlcmVhcyA1eHggd2lsbCBiZSBfX2ZhbHNlX18gYW5kIGAuZXJyb3JgIHdpbGwgYmUgX190cnVlX18uIFRoZVxuICogYC5jbGllbnRFcnJvcmAgYW5kIGAuc2VydmVyRXJyb3JgIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBiZSBtb3JlXG4gKiBzcGVjaWZpYywgYW5kIGAuc3RhdHVzVHlwZWAgaXMgdGhlIGNsYXNzIG9mIGVycm9yIHJhbmdpbmcgZnJvbSAxLi41XG4gKiBzb21ldGltZXMgdXNlZnVsIGZvciBtYXBwaW5nIHJlc3BvbmQgY29sb3JzIGV0Yy5cbiAqXG4gKiBcInN1Z2FyXCIgcHJvcGVydGllcyBhcmUgYWxzbyBkZWZpbmVkIGZvciBjb21tb24gY2FzZXMuIEN1cnJlbnRseSBwcm92aWRpbmc6XG4gKlxuICogICAtIC5ub0NvbnRlbnRcbiAqICAgLSAuYmFkUmVxdWVzdFxuICogICAtIC51bmF1dGhvcml6ZWRcbiAqICAgLSAubm90QWNjZXB0YWJsZVxuICogICAtIC5ub3RGb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3RhdHVzKXtcbiAgdmFyIHR5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xuXG4gIC8vIHN0YXR1cyAvIGNsYXNzXG4gIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlO1xuXG4gIC8vIGJhc2ljc1xuICB0aGlzLmluZm8gPSAxID09IHR5cGU7XG4gIHRoaXMub2sgPSAyID09IHR5cGU7XG4gIHRoaXMuY2xpZW50RXJyb3IgPSA0ID09IHR5cGU7XG4gIHRoaXMuc2VydmVyRXJyb3IgPSA1ID09IHR5cGU7XG4gIHRoaXMuZXJyb3IgPSAoNCA9PSB0eXBlIHx8IDUgPT0gdHlwZSlcbiAgICA/IHRoaXMudG9FcnJvcigpXG4gICAgOiBmYWxzZTtcblxuICAvLyBzdWdhclxuICB0aGlzLmFjY2VwdGVkID0gMjAyID09IHN0YXR1cztcbiAgdGhpcy5ub0NvbnRlbnQgPSAyMDQgPT0gc3RhdHVzIHx8IDEyMjMgPT0gc3RhdHVzO1xuICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xuICB0aGlzLnVuYXV0aG9yaXplZCA9IDQwMSA9PSBzdGF0dXM7XG4gIHRoaXMubm90QWNjZXB0YWJsZSA9IDQwNiA9PSBzdGF0dXM7XG4gIHRoaXMubm90Rm91bmQgPSA0MDQgPT0gc3RhdHVzO1xuICB0aGlzLmZvcmJpZGRlbiA9IDQwMyA9PSBzdGF0dXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBgRXJyb3JgIHJlcHJlc2VudGF0aXZlIG9mIHRoaXMgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybiB7RXJyb3J9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS50b0Vycm9yID0gZnVuY3Rpb24oKXtcbiAgdmFyIHJlcSA9IHRoaXMucmVxO1xuICB2YXIgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgdmFyIHVybCA9IHJlcS51cmw7XG5cbiAgdmFyIG1zZyA9ICdjYW5ub3QgJyArIG1ldGhvZCArICcgJyArIHVybCArICcgKCcgKyB0aGlzLnN0YXR1cyArICcpJztcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSBtZXRob2Q7XG4gIGVyci51cmwgPSB1cmw7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZWAuXG4gKi9cblxucmVxdWVzdC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RgIHdpdGggdGhlIGdpdmVuIGBtZXRob2RgIGFuZCBgdXJsYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTtcbiAgdGhpcy5faGVhZGVyID0ge307XG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpOyBcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlO1xuICAgIH1cblxuICAgIHNlbGYuY2FsbGJhY2soZXJyLCByZXMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBNaXhpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBTZXQgdGltZW91dCB0byBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbihtcyl7XG4gIHRoaXMuX3RpbWVvdXQgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuX3RpbWVvdXQgPSAwO1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmFib3J0ZWQpIHJldHVybjtcbiAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIuYWJvcnQoKTtcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5zZXQoJ1gtQVBJLUtleScsICdmb29iYXInKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCh7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1BUEktS2V5JzogJ2Zvb2JhcicgfSlcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgaGVhZGVyIGBmaWVsZGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3Mpe1xuICB2YXIgc3RyID0gYnRvYSh1c2VyICsgJzonICsgcGFzcyk7XG4gIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBzdHIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxuKlxuKiBFeGFtcGxlczpcbipcbiogICByZXF1ZXN0LmdldCgnL3Nob2VzJylcbiogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4qICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4qIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuKiBAYXBpIHB1YmxpY1xuKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICogcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkgdGhpcy5fZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgdGhpcy5fZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBRdWV1ZSB0aGUgZ2l2ZW4gYGZpbGVgIGFzIGFuIGF0dGFjaG1lbnQgdG8gdGhlIHNwZWNpZmllZCBgZmllbGRgLFxuICogd2l0aCBvcHRpb25hbCBgZmlsZW5hbWVgLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaChuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmaWVsZCwgZmlsZSwgZmlsZW5hbWUpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB0aGlzLl9mb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB0aGlzLl9mb3JtRGF0YS5hcHBlbmQoZmllbGQsIGZpbGUsIGZpbGVuYW1lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmQgYGRhdGFgLCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIHF1ZXJ5c3RyaW5nXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3NlYXJjaCcpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbXVsdGlwbGUgZGF0YSBcIndyaXRlc1wiXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3NlYXJjaCcpXG4gKiAgICAgICAgIC5zZW5kKHsgc2VhcmNoOiAncXVlcnknIH0pXG4gKiAgICAgICAgIC5zZW5kKHsgcmFuZ2U6ICcxLi41JyB9KVxuICogICAgICAgICAuc2VuZCh7IG9yZGVyOiAnZGVzYycgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAgKiAgICAgICAgLnNlbmQoJ25hbWU9dG9iaScpXG4gICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgb2JqID0gaXNPYmplY3QoZGF0YSk7XG4gIHZhciB0eXBlID0gdGhpcy5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuXG4gIC8vIG1lcmdlXG4gIGlmIChvYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIGlmICghdHlwZSkgdGhpcy50eXBlKCdmb3JtJyk7XG4gICAgdHlwZSA9IHRoaXMuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghb2JqKSByZXR1cm4gdGhpcztcbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgaWYgKDIgPT0gZm4ubGVuZ3RoKSByZXR1cm4gZm4oZXJyLCByZXMpO1xuICBpZiAoZXJyKSByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIGZuKHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJyk7XG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggdGltZW91dCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50aW1lb3V0RXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgb2YgJyArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4aHIgPSB0aGlzLnhociA9IGdldFhIUigpO1xuICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIC8vIHN0b3JlIGNhbGxiYWNrXG4gIHRoaXMuX2NhbGxiYWNrID0gZm4gfHwgbm9vcDtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBpZiAoMCA9PSB4aHIuc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi5hYm9ydGVkKSByZXR1cm4gc2VsZi50aW1lb3V0RXJyb3IoKTtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICAvLyBwcm9ncmVzc1xuICBpZiAoeGhyLnVwbG9hZCkge1xuICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGUpe1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuICAgICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICAgIH07XG4gIH1cblxuICAvLyB0aW1lb3V0XG4gIGlmICh0aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi5hYm9ydCgpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9XG5cbiAgLy8gcXVlcnlzdHJpbmdcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSByZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdChxdWVyeSk7XG4gICAgdGhpcy51cmwgKz0gfnRoaXMudXJsLmluZGV4T2YoJz8nKVxuICAgICAgPyAnJicgKyBxdWVyeVxuICAgICAgOiAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIC8vIGluaXRpYXRlIHJlcXVlc3RcbiAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCdHRVQnICE9IHRoaXMubWV0aG9kICYmICdIRUFEJyAhPSB0aGlzLm1ldGhvZCAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSAmJiAhaXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgdmFyIHNlcmlhbGl6ZSA9IHJlcXVlc3Quc2VyaWFsaXplW3RoaXMuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKV07XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAodmFyIGZpZWxkIGluIHRoaXMuaGVhZGVyKSB7XG4gICAgaWYgKG51bGwgPT0gdGhpcy5oZWFkZXJbZmllbGRdKSBjb250aW51ZTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihmaWVsZCwgdGhpcy5oZWFkZXJbZmllbGRdKTtcbiAgfVxuXG4gIC8vIHNlbmQgc3R1ZmZcbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XG4gIHhoci5zZW5kKGRhdGEpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0YC5cbiAqL1xuXG5yZXF1ZXN0LlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIElzc3VlIGEgcmVxdWVzdDpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICByZXF1ZXN0KCdHRVQnLCAnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJywgY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHVybCBvciBjYWxsYmFja1xuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcmVxdWVzdChtZXRob2QsIHVybCkge1xuICAvLyBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlcXVlc3QobWV0aG9kLCB1cmwpO1xufVxuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBkYXRhIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5nZXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IGRhdGEgb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmhlYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZGVsID0gZnVuY3Rpb24odXJsLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQQVRDSCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wb3N0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gZGF0YSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucHV0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQVVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcbiIsIlxuLyoqXG4gKiBSZWR1Y2UgYGFycmAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TWl4ZWR9IGluaXRpYWxcbiAqXG4gKiBUT0RPOiBjb21iYXRpYmxlIGVycm9yIGhhbmRsaW5nP1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBmbiwgaW5pdGlhbCl7ICBcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgY3VyciA9IGFyZ3VtZW50cy5sZW5ndGggPT0gM1xuICAgID8gaW5pdGlhbFxuICAgIDogYXJyW2lkeCsrXTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgY3VyciA9IGZuLmNhbGwobnVsbCwgY3VyciwgYXJyW2lkeF0sICsraWR4LCBhcnIpO1xuICB9XG4gIFxuICByZXR1cm4gY3Vycjtcbn07IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJkZXBsb3lyXCIsXG4gIFwidmVyc2lvblwiOiBcIjcuNC4xXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJTaW1wbGlmaWVkIEphdmFTY3JpcHQgY2xpZW50IGxpYnJhcnkgZm9yIG1ha2luZyByZXF1ZXN0cyB0byBEZXBsb3lSLlwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImRlcGxveXJcIixcbiAgICBcImRlcGxveXIuaW9cIixcbiAgICBcImFqYXhcIixcbiAgICBcIlJcIixcbiAgICBcImFwaVwiLFxuICAgIFwic2ltcGxlXCJcbiAgXSxcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkRlcGxveVIgLSBSZXZvbHV0aW9uIEFuYWx5dGljcyBJbmMuXCJcbiAgfSxcbiAgXCJjb250cmlidXRvcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIlNlYW4gV2VsbHNcIlxuICAgIH1cbiAgXSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vZGVwbG95ci9qcy1jbGllbnQtbGlicmFyeS5naXRcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cDovL2RlcGxveXIucmV2b2x1dGlvbmFuYWx5dGljcy5jb20vZG9jdW1lbnRzL2Rldi9jbGllbnQtanNkb2NcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInN0YXJ0XCI6IFwiZ3VscCBzdGFydFwiLFxuICAgIFwiYnVpbGRcIjogXCJndWxwXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl45LjAuM1wiLFxuICAgIFwiZ3VscFwiOiBcIl4zLjguMTFcIixcbiAgICBcImd1bHAtY29ubmVjdFwiOiBcIl4yLjIuMFwiLFxuICAgIFwiZ3VscC1oZWFkZXJcIjogXCJeMS4yLjJcIixcbiAgICBcImd1bHAtanNoaW50XCI6IFwiXjEuOS4yXCIsXG4gICAgXCJndWxwLWxpdmVyZWxvYWRcIjogXCJeMy44LjBcIixcbiAgICBcImd1bHAtcGx1bWJlclwiOiBcIl4wLjYuNlwiLFxuICAgIFwiZ3VscC11Z2xpZnlqc1wiOiBcIl4wLjYuMFwiLFxuICAgIFwiZ3VscC11dGlsXCI6IFwiXjMuMC40XCIsXG4gICAgXCJ0YXBlXCI6IFwiXjMuNS4wXCIsXG4gICAgXCJ2aW55bC1zb3VyY2Utc3RyZWFtXCI6IFwiXjEuMC4wXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZC5qc1wiOiBcIl4wLjYuMFwiLFxuICAgIFwic3VwZXJhZ2VudFwiOiBcIl4wLjIxLjBcIixcbiAgICBcIndzXCI6IFwiXjAuNC4zMlwiXG4gIH0sXG4gIFwibWFpblwiOiBcImRlcGxveXIuanNcIixcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PSAwLjEwLjBcIlxuICB9LFxuICBcImxpY2Vuc2VcIjogXCJBcGFjaGUgMi4wIExpY2Vuc2VcIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9kZXBsb3lyL2pzLWNsaWVudC1saWJyYXJ5L2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGlyZWN0b3JpZXNcIjoge1xuICAgIFwiZXhhbXBsZVwiOiBcImV4YW1wbGVzXCIsXG4gICAgXCJ0ZXN0XCI6IFwidGVzdFwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjNjOTU1ZTE4OThiZWRmYWY1NjJiMGI3NTE2NzRjNGViZjdkNjAyZjZcIixcbiAgXCJfaWRcIjogXCJkZXBsb3lyQDcuNC4xXCIsXG4gIFwiX3NoYXN1bVwiOiBcIjNjYzUzYzZjZWEyMzY2NTI1ZTIxODk4YmI2MDA1ZjQyZTk3OWI0ZTNcIixcbiAgXCJfZnJvbVwiOiBcImRlcGxveXJAPj03LjQuMSA8OC4wLjBcIixcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjEuNC4yOFwiLFxuICBcIl9ucG1Vc2VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJzd2VsbHNcIixcbiAgICBcImVtYWlsXCI6IFwic2Vhbi53ZWxscy5zY0BnbWFpbC5jb21cIlxuICB9LFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJzd2VsbHNcIixcbiAgICAgIFwiZW1haWxcIjogXCJzZWFuLndlbGxzLnNjQGdtYWlsLmNvbVwiXG4gICAgfVxuICBdLFxuICBcImRpc3RcIjoge1xuICAgIFwic2hhc3VtXCI6IFwiM2NjNTNjNmNlYTIzNjY1MjVlMjE4OThiYjYwMDVmNDJlOTc5YjRlM1wiLFxuICAgIFwidGFyYmFsbFwiOiBcImh0dHA6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvZGVwbG95ci8tL2RlcGxveXItNy40LjEudGd6XCJcbiAgfSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9kZXBsb3lyLy0vZGVwbG95ci03LjQuMS50Z3pcIixcbiAgXCJyZWFkbWVcIjogXCJFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhXCJcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZW51bScpOyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbihmdW5jdGlvbiAocm9vdCwgbW9kdWxlLCBnbG9iYWwsIGRlZmluZSkge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGFuIEl0ZW0gb2YgYW4gRW51bS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAgIFRoZSBFbnVtIGtleS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBFbnVtIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gRW51bUl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIEVudW1JdGVtLnByb3RvdHlwZSA9IHtcblxuICAgIC8qY29uc3RydWN0b3IgcmVmZXJlbmNlIHNvIHRoYXQsIHRoaXMuY29uc3RydWN0b3I9PT1FbnVtSXRlbS8vPT50cnVlICovXG4gICAgY29uc3RydWN0b3I6IEVudW1JdGVtLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBmbGFnZ2VkIEVudW1JdGVtIGhhcyB0aGUgcGFzc2luZyBvYmplY3QuXG4gICAgICogQHBhcmFtICB7RW51bUl0ZW0gfHwgU3RyaW5nIHx8IE51bWJlcn0gdmFsdWUgVGhlIG9iamVjdCB0byBjaGVjayB3aXRoLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBjaGVjayByZXN1bHQuXG4gICAgICovXG4gICAgaGFzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRW51bUl0ZW0gfHwgKHR5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlLmtleSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLnZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIHZhbHVlLnZhbHVlKSAhPT0gMDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5LmluZGV4T2YodmFsdWUpID49IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWUgJiB2YWx1ZSkgIT09IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgRW51bUl0ZW0gaXMgdGhlIHNhbWUgYXMgdGhlIHBhc3Npbmcgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0VudW1JdGVtIHx8IFN0cmluZyB8fCBOdW1iZXJ9IGtleSBUaGUgb2JqZWN0IHRvIGNoZWNrIHdpdGguXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBjaGVjayByZXN1bHQuXG4gICAgICovXG4gICAgaXM6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEVudW1JdGVtIHx8ICh0eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5LmtleSAhPT0gdW5kZWZpbmVkICYmIGtleS52YWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXkgPT09IGtleS5rZXk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZihrZXkpID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXkgPT09IGtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBrZXk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRW51bUl0ZW0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBFbnVtSXRlbS5cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBFbnVtSXRlbS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEpTT04gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRW51bUl0ZW0uXG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgdG8gY29tcGFyZSB3aXRoLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHZhbHVlIHRvIGNvbXBhcmUgd2l0aC5cbiAgICAgKi9cbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9XG5cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGFuIEVudW0gd2l0aCBlbnVtIGl0ZW1zLlxuICAgKiBAcGFyYW0ge0FycmF5IHx8IE9iamVjdH0gIG1hcCAgICAgVGhpcyBhcmUgdGhlIGVudW0gaXRlbXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nIHx8IE9iamVjdH0gb3B0aW9ucyBUaGlzIGFyZSBvcHRpb25zLiBbb3B0aW9uYWxdXG4gICAqL1xuICBmdW5jdGlvbiBFbnVtKG1hcCwgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IHsgbmFtZTogb3B0aW9ucyB9O1xuICAgIH1cblxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX29wdGlvbnMuc2VwYXJhdG9yID0gdGhpcy5fb3B0aW9ucy5zZXBhcmF0b3IgfHwgJyB8ICc7XG5cbiAgICB0aGlzLmVudW1zID0gW107XG5cbiAgICBpZiAobWFwLmxlbmd0aCkge1xuICAgICAgdmFyIGFycmF5ID0gbWFwO1xuICAgICAgbWFwID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwW2FycmF5W2ldXSA9IE1hdGgucG93KDIsIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIG1lbWJlciBpbiBtYXApIHtcbiAgICAgIGlmICgodGhpcy5fb3B0aW9ucy5uYW1lICYmIG1lbWJlciA9PT0gJ25hbWUnKSB8fCBtZW1iZXIgPT09ICdfb3B0aW9ucycgfHwgbWVtYmVyID09PSAnZ2V0JyB8fCBtZW1iZXIgPT09ICdnZXRLZXknIHx8IG1lbWJlciA9PT0gJ2dldFZhbHVlJyB8fCBtZW1iZXIgPT09ICdlbnVtcycgfHwgbWVtYmVyID09PSAnaXNGbGFnZ2FibGUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW51bSBrZXkgXCInICsgbWVtYmVyICsgJ1wiIGlzIGEgcmVzZXJ2ZWQgd29yZCEnKTtcbiAgICAgIH1cbiAgICAgIHRoaXNbbWVtYmVyXSA9IG5ldyBFbnVtSXRlbShtZW1iZXIsIG1hcFttZW1iZXJdKTtcbiAgICAgIHRoaXMuZW51bXMucHVzaCh0aGlzW21lbWJlcl0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLm5hbWUpIHtcbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuX29wdGlvbnMubmFtZTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBpc0ZsYWdnYWJsZSgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLmVudW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gc2VsZi5lbnVtc1tpXTtcblxuICAgICAgICBpZiAoISgoZS52YWx1ZSAhPT0gMCkgJiYgIShlLnZhbHVlICYgKGUudmFsdWUgLSAxKSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzRmxhZ2dhYmxlID0gaXNGbGFnZ2FibGUoKTtcbiAgICB0aGlzLmZyZWV6ZUVudW1zKCk7IC8vdGhpcyB3aWxsIG1ha2UgaW5zdGFuY2VzIG9mIEVudW0gbm9uLWV4dGVuc2libGVcbiAgfVxuXG4gIEVudW0ucHJvdG90eXBlID0ge1xuXG4gICAgLypjb25zdHJ1Y3RvciByZWZlcmVuY2Ugc28gdGhhdCwgdGhpcy5jb25zdHJ1Y3Rvcj09PUVudW0vLz0+dHJ1ZSAqL1xuICAgIGNvbnN0cnVjdG9yOiBFbnVtLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgRW51bUl0ZW0ga2V5LlxuICAgICAqIEBwYXJhbSAge0VudW1JdGVtIHx8IFN0cmluZyB8fCBOdW1iZXJ9IGtleSBUaGUgb2JqZWN0IHRvIGdldCB3aXRoLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZ2V0IHJlc3VsdC5cbiAgICAgKi9cbiAgICBnZXRLZXk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnVW5kZWZpbmVkJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgRW51bUl0ZW0gdmFsdWUuXG4gICAgICogQHBhcmFtICB7RW51bUl0ZW0gfHwgU3RyaW5nIHx8IE51bWJlcn0ga2V5IFRoZSBvYmplY3QgdG8gZ2V0IHdpdGguXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBnZXQgcmVzdWx0LlxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFwcHJvcHJpYXRlIEVudW1JdGVtLlxuICAgICAqIEBwYXJhbSAge0VudW1JdGVtIHx8IFN0cmluZyB8fCBOdW1iZXJ9IGtleSBUaGUgb2JqZWN0IHRvIGdldCB3aXRoLlxuICAgICAqIEByZXR1cm4ge0VudW1JdGVtfSAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZ2V0IHJlc3VsdC5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gbnVsbCB8fCBrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBFbnVtSXRlbSB8fCAodHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleS5rZXkgIT09IHVuZGVmaW5lZCAmJiBrZXkudmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSB0aGlzLmVudW1zLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPj0gMCkge1xuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzRmxhZ2dhYmxlIHx8ICh0aGlzLmlzRmxhZ2dhYmxlICYmIGtleS5rZXkuaW5kZXhPZih0aGlzLl9vcHRpb25zLnNlcGFyYXRvcikgPCAwKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldChrZXkua2V5KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGtleSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZih0aGlzLl9vcHRpb25zLnNlcGFyYXRvcikgPiAwKSB7XG4gICAgICAgICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KHRoaXMuX29wdGlvbnMuc2VwYXJhdG9yKTtcblxuICAgICAgICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzW3BhcnRdLnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgRW51bUl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgbSBpbiB0aGlzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkobSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW21dLnZhbHVlID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNGbGFnZ2FibGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBuIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KG4pKSB7XG4gICAgICAgICAgICAgIGlmICgoa2V5ICYgdGhpc1tuXS52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5fb3B0aW9ucy5zZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldChyZXN1bHQgfHwgbnVsbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlZmluZSBmcmVlemVFbnVtcygpIGFzIGEgcHJvcGVydHkgb2YgdGhlIHByb3RvdHlwZS5cbiAgICAgKiBtYWtlIGVudW1lcmFibGUgaXRlbXMgbm9uY29uZmlndXJhYmxlIGFuZCBkZWVwIGZyZWV6ZSB0aGUgcHJvcGVydGllcy4gVGhyb3cgRXJyb3Igb24gcHJvcGVydHkgc2V0dGVyLlxuICAgICAqL1xuICAgIGZyZWV6ZUVudW1zOiBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIGZyZWV6ZXIobykge1xuICAgICAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKTtcbiAgICAgICAgcHJvcHMuZm9yRWFjaCggZnVuY3Rpb24ocCl7XG4gICAgICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIHApLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG8sIHAsIHt3cml0YWJsZTpmYWxzZSwgY29uZmlndXJhYmxlOmZhbHNlfSk7XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQcm9wZXJ0eVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVlcEZyZWV6ZUVudW1zKG8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0JyB8fCBvID09PSBudWxsIHx8IE9iamVjdC5pc0Zyb3plbihvKSB8fCBPYmplY3QuaXNTZWFsZWQobykgKXtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBvLl9fZGVmaW5lR2V0dGVyX18oa2V5LCBnZXRQcm9wZXJ0eVZhbHVlLmJpbmQobnVsbCwgb1trZXldKSk7XG4gICAgICAgICAgICBvLl9fZGVmaW5lU2V0dGVyX18oa2V5LCBmdW5jdGlvbiB0aHJvd1Byb3BlcnR5U2V0RXJyb3IodmFsdWUpe3Rocm93IFR5cGVFcnJvcihcIkNhbm5vdCByZWRlZmluZSBwcm9wZXJ0eTsgRW51bSBUeXBlIGlzIG5vdCBleHRlbnNpYmxlLlwiKX0pO1xuICAgICAgICAgICAgZGVlcEZyZWV6ZUVudW1zKG9ba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmVlemVyKG8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlZXBGcmVlemVFbnVtcyh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgfTtcblxuXG4gIGlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEVudW07XG4gIH0gZWxzZSBpZiAoZGVmaW5lKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBFbnVtO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuRW51bSA9IEVudW07XG4gIH1cblxuICBpZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzICYmIGdsb2JhbCkge1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBFbnVtIFR5cGUgZ2xvYmFsbHkgaW4gbm9kZS5qcy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleSBHbG9iYWwgdmFyaWFibGUuIFtvcHRpb25hbF1cbiAgICAgKi9cbiAgICBFbnVtLnJlZ2lzdGVyID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICBrZXkgPSBrZXkgfHwgJ0VudW0nO1xuICAgICAgaWYgKCFnbG9iYWxba2V5XSkge1xuICAgICAgICBnbG9iYWxba2V5XSA9IEVudW07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG59KFxuICB0aGlzLFxuICB0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUgOiB1bmRlZmluZWQsXG4gIHR5cGVvZihnbG9iYWwpICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHVuZGVmaW5lZCxcbiAgdHlwZW9mKGRlZmluZSkgIT09ICd1bmRlZmluZWQnID8gZGVmaW5lIDogdW5kZWZpbmVkXG4pKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbTV2WkdWZmJXOWtkV3hsY3k5bGJuVnRMMnhwWWk5bGJuVnRMbXB6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UVVGQlFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJJaXdpWm1sc1pTSTZJbWRsYm1WeVlYUmxaQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJb1puVnVZM1JwYjI0Z0tISnZiM1FzSUcxdlpIVnNaU3dnWjJ4dlltRnNMQ0JrWldacGJtVXBJSHRjYmx4dUlDQmNJblZ6WlNCemRISnBZM1JjSWp0Y2JseHVJQ0F2S2lwY2JpQWdJQ29nVW1Wd2NtVnpaVzUwY3lCaGJpQkpkR1Z0SUc5bUlHRnVJRVZ1ZFcwdVhHNGdJQ0FxSUVCd1lYSmhiU0I3VTNSeWFXNW5mU0JyWlhrZ0lDQlVhR1VnUlc1MWJTQnJaWGt1WEc0Z0lDQXFJRUJ3WVhKaGJTQjdUblZ0WW1WeWZTQjJZV3gxWlNCVWFHVWdSVzUxYlNCMllXeDFaUzVjYmlBZ0lDb3ZYRzRnSUdaMWJtTjBhVzl1SUVWdWRXMUpkR1Z0S0d0bGVTd2dkbUZzZFdVcElIdGNiaUFnSUNCMGFHbHpMbXRsZVNBOUlHdGxlVHRjYmlBZ0lDQjBhR2x6TG5aaGJIVmxJRDBnZG1Gc2RXVTdYRzRnSUgxY2JseHVJQ0JGYm5WdFNYUmxiUzV3Y205MGIzUjVjR1VnUFNCN1hHNWNiaUFnSUNBdkttTnZibk4wY25WamRHOXlJSEpsWm1WeVpXNWpaU0J6YnlCMGFHRjBMQ0IwYUdsekxtTnZibk4wY25WamRHOXlQVDA5Ulc1MWJVbDBaVzB2THowK2RISjFaU0FxTDF4dUlDQWdJR052Ym5OMGNuVmpkRzl5T2lCRmJuVnRTWFJsYlN4Y2JseHVJQ0FnSUM4cUtseHVJQ0FnSUNBcUlFTm9aV05yY3lCcFppQjBhR1VnWm14aFoyZGxaQ0JGYm5WdFNYUmxiU0JvWVhNZ2RHaGxJSEJoYzNOcGJtY2diMkpxWldOMExseHVJQ0FnSUNBcUlFQndZWEpoYlNBZ2UwVnVkVzFKZEdWdElIeDhJRk4wY21sdVp5QjhmQ0JPZFcxaVpYSjlJSFpoYkhWbElGUm9aU0J2WW1wbFkzUWdkRzhnWTJobFkyc2dkMmwwYUM1Y2JpQWdJQ0FnS2lCQWNtVjBkWEp1SUh0Q2IyOXNaV0Z1ZlNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCVWFHVWdZMmhsWTJzZ2NtVnpkV3gwTGx4dUlDQWdJQ0FxTDF4dUlDQWdJR2hoY3pvZ1puVnVZM1JwYjI0b2RtRnNkV1VwSUh0Y2JpQWdJQ0FnSUdsbUlDaDJZV3gxWlNCcGJuTjBZVzVqWlc5bUlFVnVkVzFKZEdWdElIeDhJQ2gwZVhCbGIyWW9kbUZzZFdVcElEMDlQU0FuYjJKcVpXTjBKeUFtSmlCMllXeDFaUzVyWlhrZ0lUMDlJSFZ1WkdWbWFXNWxaQ0FtSmlCMllXeDFaUzUyWVd4MVpTQWhQVDBnZFc1a1pXWnBibVZrS1NrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z0tIUm9hWE11ZG1Gc2RXVWdKaUIyWVd4MVpTNTJZV3gxWlNrZ0lUMDlJREE3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0hSNWNHVnZaaWgyWVd4MVpTa2dQVDA5SUNkemRISnBibWNuS1NCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbXRsZVM1cGJtUmxlRTltS0haaGJIVmxLU0ErUFNBd08xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUNoMGFHbHpMblpoYkhWbElDWWdkbUZzZFdVcElDRTlQU0F3TzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2S2lwY2JpQWdJQ0FnS2lCRGFHVmphM01nYVdZZ2RHaGxJRVZ1ZFcxSmRHVnRJR2x6SUhSb1pTQnpZVzFsSUdGeklIUm9aU0J3WVhOemFXNW5JRzlpYW1WamRDNWNiaUFnSUNBZ0tpQkFjR0Z5WVcwZ0lIdEZiblZ0U1hSbGJTQjhmQ0JUZEhKcGJtY2dmSHdnVG5WdFltVnlmU0JyWlhrZ1ZHaGxJRzlpYW1WamRDQjBieUJqYUdWamF5QjNhWFJvTGx4dUlDQWdJQ0FxSUVCeVpYUjFjbTRnZTBKdmIyeGxZVzU5SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JVYUdVZ1kyaGxZMnNnY21WemRXeDBMbHh1SUNBZ0lDQXFMMXh1SUNBZ0lHbHpPaUJtZFc1amRHbHZiaWhyWlhrcElIdGNiaUFnSUNBZ0lHbG1JQ2hyWlhrZ2FXNXpkR0Z1WTJWdlppQkZiblZ0U1hSbGJTQjhmQ0FvZEhsd1pXOW1LR3RsZVNrZ1BUMDlJQ2R2WW1wbFkzUW5JQ1ltSUd0bGVTNXJaWGtnSVQwOUlIVnVaR1ZtYVc1bFpDQW1KaUJyWlhrdWRtRnNkV1VnSVQwOUlIVnVaR1ZtYVc1bFpDa3BJSHRjYmlBZ0lDQWdJQ0FnY21WMGRYSnVJSFJvYVhNdWEyVjVJRDA5UFNCclpYa3VhMlY1TzF4dUlDQWdJQ0FnZlNCbGJITmxJR2xtSUNoMGVYQmxiMllvYTJWNUtTQTlQVDBnSjNOMGNtbHVaeWNwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVhMlY1SUQwOVBTQnJaWGs3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1MllXeDFaU0E5UFQwZ2EyVjVPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZLaXBjYmlBZ0lDQWdLaUJTWlhSMWNtNXpJRk4wY21sdVp5QnlaWEJ5WlhObGJuUmhkR2x2YmlCdlppQjBhR2x6SUVWdWRXMUpkR1Z0TGx4dUlDQWdJQ0FxSUVCeVpYUjFjbTRnZTFOMGNtbHVaMzBnVTNSeWFXNW5JSEpsY0hKbGMyVnVkR0YwYVc5dUlHOW1JSFJvYVhNZ1JXNTFiVWwwWlcwdVhHNGdJQ0FnSUNvdlhHNGdJQ0FnZEc5VGRISnBibWM2SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVhMlY1TzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2S2lwY2JpQWdJQ0FnS2lCU1pYUjFjbTV6SUVwVFQwNGdiMkpxWldOMElISmxjSEpsYzJWdWRHRjBhVzl1SUc5bUlIUm9hWE1nUlc1MWJVbDBaVzB1WEc0Z0lDQWdJQ29nUUhKbGRIVnliaUI3VTNSeWFXNW5mU0JLVTA5T0lHOWlhbVZqZENCeVpYQnlaWE5sYm5SaGRHbHZiaUJ2WmlCMGFHbHpJRVZ1ZFcxSmRHVnRMbHh1SUNBZ0lDQXFMMXh1SUNBZ0lIUnZTbE5QVGpvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTVyWlhrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4cUtseHVJQ0FnSUNBcUlGSmxkSFZ5Ym5NZ2RHaGxJSFpoYkhWbElIUnZJR052YlhCaGNtVWdkMmwwYUM1Y2JpQWdJQ0FnS2lCQWNtVjBkWEp1SUh0VGRISnBibWQ5SUZSb1pTQjJZV3gxWlNCMGJ5QmpiMjF3WVhKbElIZHBkR2d1WEc0Z0lDQWdJQ292WEc0Z0lDQWdkbUZzZFdWUFpqb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1clpYazdYRzRnSUNBZ2ZWeHVYRzRnSUgwN1hHNWNibHh1SUNBdktpcGNiaUFnSUNvZ1VtVndjbVZ6Wlc1MGN5QmhiaUJGYm5WdElIZHBkR2dnWlc1MWJTQnBkR1Z0Y3k1Y2JpQWdJQ29nUUhCaGNtRnRJSHRCY25KaGVTQjhmQ0JQWW1wbFkzUjlJQ0J0WVhBZ0lDQWdJRlJvYVhNZ1lYSmxJSFJvWlNCbGJuVnRJR2wwWlcxekxseHVJQ0FnS2lCQWNHRnlZVzBnZTFOMGNtbHVaeUI4ZkNCUFltcGxZM1I5SUc5d2RHbHZibk1nVkdocGN5QmhjbVVnYjNCMGFXOXVjeTRnVzI5d2RHbHZibUZzWFZ4dUlDQWdLaTljYmlBZ1puVnVZM1JwYjI0Z1JXNTFiU2h0WVhBc0lHOXdkR2x2Ym5NcElIdGNibHh1SUNBZ0lHbG1JQ2h2Y0hScGIyNXpJQ1ltSUhSNWNHVnZaaWh2Y0hScGIyNXpLU0E5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNBZ0lHOXdkR2x2Ym5NZ1BTQjdJRzVoYldVNklHOXdkR2x2Ym5NZ2ZUdGNiaUFnSUNCOVhHNWNiaUFnSUNCMGFHbHpMbDl2Y0hScGIyNXpJRDBnYjNCMGFXOXVjeUI4ZkNCN2ZUdGNiaUFnSUNCMGFHbHpMbDl2Y0hScGIyNXpMbk5sY0dGeVlYUnZjaUE5SUhSb2FYTXVYMjl3ZEdsdmJuTXVjMlZ3WVhKaGRHOXlJSHg4SUNjZ2ZDQW5PMXh1WEc0Z0lDQWdkR2hwY3k1bGJuVnRjeUE5SUZ0ZE8xeHVYRzRnSUNBZ2FXWWdLRzFoY0M1c1pXNW5kR2dwSUh0Y2JpQWdJQ0FnSUhaaGNpQmhjbkpoZVNBOUlHMWhjRHRjYmlBZ0lDQWdJRzFoY0NBOUlIdDlPMXh1WEc0Z0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUdGeWNtRjVMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNBZ0lHMWhjRnRoY25KaGVWdHBYVjBnUFNCTllYUm9MbkJ2ZHlneUxDQnBLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQjlYRzVjYmlBZ0lDQm1iM0lnS0haaGNpQnRaVzFpWlhJZ2FXNGdiV0Z3S1NCN1hHNGdJQ0FnSUNCcFppQW9LSFJvYVhNdVgyOXdkR2x2Ym5NdWJtRnRaU0FtSmlCdFpXMWlaWElnUFQwOUlDZHVZVzFsSnlrZ2ZId2diV1Z0WW1WeUlEMDlQU0FuWDI5d2RHbHZibk1uSUh4OElHMWxiV0psY2lBOVBUMGdKMmRsZENjZ2ZId2diV1Z0WW1WeUlEMDlQU0FuWjJWMFMyVjVKeUI4ZkNCdFpXMWlaWElnUFQwOUlDZG5aWFJXWVd4MVpTY2dmSHdnYldWdFltVnlJRDA5UFNBblpXNTFiWE1uSUh4OElHMWxiV0psY2lBOVBUMGdKMmx6Um14aFoyZGhZbXhsSnlrZ2UxeHVJQ0FnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owVnVkVzBnYTJWNUlGd2lKeUFySUcxbGJXSmxjaUFySUNkY0lpQnBjeUJoSUhKbGMyVnlkbVZrSUhkdmNtUWhKeWs3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdJQ0IwYUdselcyMWxiV0psY2wwZ1BTQnVaWGNnUlc1MWJVbDBaVzBvYldWdFltVnlMQ0J0WVhCYmJXVnRZbVZ5WFNrN1hHNGdJQ0FnSUNCMGFHbHpMbVZ1ZFcxekxuQjFjMmdvZEdocGMxdHRaVzFpWlhKZEtUdGNiaUFnSUNCOVhHNWNiaUFnSUNCcFppQW9kR2hwY3k1ZmIzQjBhVzl1Y3k1dVlXMWxLU0I3WEc0Z0lDQWdJQ0IwYUdsekxtNWhiV1VnUFNCMGFHbHpMbDl2Y0hScGIyNXpMbTVoYldVN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnZG1GeUlITmxiR1lnUFNCMGFHbHpPMXh1WEc0Z0lDQWdablZ1WTNScGIyNGdhWE5HYkdGbloyRmliR1VvS1NCN1hHNGdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNQ3dnYkdWdUlEMGdjMlZzWmk1bGJuVnRjeTVzWlc1bmRHZzdJR2tnUENCc1pXNDdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnWlNBOUlITmxiR1l1Wlc1MWJYTmJhVjA3WEc1Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0VvS0dVdWRtRnNkV1VnSVQwOUlEQXBJQ1ltSUNFb1pTNTJZV3gxWlNBbUlDaGxMblpoYkhWbElDMGdNU2twS1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSeWRXVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2RHaHBjeTVwYzBac1lXZG5ZV0pzWlNBOUlHbHpSbXhoWjJkaFlteGxLQ2s3WEc0Z0lDQWdkR2hwY3k1bWNtVmxlbVZGYm5WdGN5Z3BPeUF2TDNSb2FYTWdkMmxzYkNCdFlXdGxJR2x1YzNSaGJtTmxjeUJ2WmlCRmJuVnRJRzV2YmkxbGVIUmxibk5wWW14bFhHNGdJSDFjYmx4dUlDQkZiblZ0TG5CeWIzUnZkSGx3WlNBOUlIdGNibHh1SUNBZ0lDOHFZMjl1YzNSeWRXTjBiM0lnY21WbVpYSmxibU5sSUhOdklIUm9ZWFFzSUhSb2FYTXVZMjl1YzNSeWRXTjBiM0k5UFQxRmJuVnRMeTg5UG5SeWRXVWdLaTljYmlBZ0lDQmpiMjV6ZEhKMVkzUnZjam9nUlc1MWJTeGNibHh1SUNBZ0lDOHFLbHh1SUNBZ0lDQXFJRkpsZEhWeWJuTWdkR2hsSUdGd2NISnZjSEpwWVhSbElFVnVkVzFKZEdWdElHdGxlUzVjYmlBZ0lDQWdLaUJBY0dGeVlXMGdJSHRGYm5WdFNYUmxiU0I4ZkNCVGRISnBibWNnZkh3Z1RuVnRZbVZ5ZlNCclpYa2dWR2hsSUc5aWFtVmpkQ0IwYnlCblpYUWdkMmwwYUM1Y2JpQWdJQ0FnS2lCQWNtVjBkWEp1SUh0VGRISnBibWQ5SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnVkdobElHZGxkQ0J5WlhOMWJIUXVYRzRnSUNBZ0lDb3ZYRzRnSUNBZ1oyVjBTMlY1T2lCbWRXNWpkR2x2YmloMllXeDFaU2tnZTF4dUlDQWdJQ0FnZG1GeUlHbDBaVzBnUFNCMGFHbHpMbWRsZENoMllXeDFaU2s3WEc0Z0lDQWdJQ0JwWmlBb2FYUmxiU2tnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnYVhSbGJTNXJaWGs3WEc0Z0lDQWdJQ0I5SUdWc2MyVWdlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdKMVZ1WkdWbWFXNWxaQ2M3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzhxS2x4dUlDQWdJQ0FxSUZKbGRIVnlibk1nZEdobElHRndjSEp2Y0hKcFlYUmxJRVZ1ZFcxSmRHVnRJSFpoYkhWbExseHVJQ0FnSUNBcUlFQndZWEpoYlNBZ2UwVnVkVzFKZEdWdElIeDhJRk4wY21sdVp5QjhmQ0JPZFcxaVpYSjlJR3RsZVNCVWFHVWdiMkpxWldOMElIUnZJR2RsZENCM2FYUm9MbHh1SUNBZ0lDQXFJRUJ5WlhSMWNtNGdlMDUxYldKbGNuMGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQlVhR1VnWjJWMElISmxjM1ZzZEM1Y2JpQWdJQ0FnS2k5Y2JpQWdJQ0JuWlhSV1lXeDFaVG9nWm5WdVkzUnBiMjRvYTJWNUtTQjdYRzRnSUNBZ0lDQjJZWElnYVhSbGJTQTlJSFJvYVhNdVoyVjBLR3RsZVNrN1hHNGdJQ0FnSUNCcFppQW9hWFJsYlNrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2FYUmxiUzUyWVd4MVpUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCdWRXeHNPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZLaXBjYmlBZ0lDQWdLaUJTWlhSMWNtNXpJSFJvWlNCaGNIQnliM0J5YVdGMFpTQkZiblZ0U1hSbGJTNWNiaUFnSUNBZ0tpQkFjR0Z5WVcwZ0lIdEZiblZ0U1hSbGJTQjhmQ0JUZEhKcGJtY2dmSHdnVG5WdFltVnlmU0JyWlhrZ1ZHaGxJRzlpYW1WamRDQjBieUJuWlhRZ2QybDBhQzVjYmlBZ0lDQWdLaUJBY21WMGRYSnVJSHRGYm5WdFNYUmxiWDBnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdWR2hsSUdkbGRDQnlaWE4xYkhRdVhHNGdJQ0FnSUNvdlhHNGdJQ0FnWjJWME9pQm1kVzVqZEdsdmJpaHJaWGtwSUh0Y2JpQWdJQ0FnSUdsbUlDaHJaWGtnUFQwOUlHNTFiR3dnZkh3Z2EyVjVJRDA5UFNCMWJtUmxabWx1WldRcElISmxkSFZ5YmlCdWRXeHNPMXh1WEc0Z0lDQWdJQ0JwWmlBb2EyVjVJR2x1YzNSaGJtTmxiMllnUlc1MWJVbDBaVzBnZkh3Z0tIUjVjR1Z2WmloclpYa3BJRDA5UFNBbmIySnFaV04wSnlBbUppQnJaWGt1YTJWNUlDRTlQU0IxYm1SbFptbHVaV1FnSmlZZ2EyVjVMblpoYkhWbElDRTlQU0IxYm1SbFptbHVaV1FwS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJtYjNWdVpFbHVaR1Y0SUQwZ2RHaHBjeTVsYm5WdGN5NXBibVJsZUU5bUtHdGxlU2s3WEc0Z0lDQWdJQ0FnSUdsbUlDaG1iM1Z1WkVsdVpHVjRJRDQ5SURBcElIdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdhMlY1TzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lHbG1JQ2doZEdocGN5NXBjMFpzWVdkbllXSnNaU0I4ZkNBb2RHaHBjeTVwYzBac1lXZG5ZV0pzWlNBbUppQnJaWGt1YTJWNUxtbHVaR1Y0VDJZb2RHaHBjeTVmYjNCMGFXOXVjeTV6WlhCaGNtRjBiM0lwSUR3Z01Da3BJSHRjYmlBZ0lDQWdJQ0FnSUNCeVpYUjFjbTRnYm5Wc2JEdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1blpYUW9hMlY1TG10bGVTazdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2FXWWdLSFI1Y0dWdlppaHJaWGtwSUQwOVBTQW5jM1J5YVc1bkp5a2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2EyVjVMbWx1WkdWNFQyWW9kR2hwY3k1ZmIzQjBhVzl1Y3k1elpYQmhjbUYwYjNJcElENGdNQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lIWmhjaUJ3WVhKMGN5QTlJR3RsZVM1emNHeHBkQ2gwYUdsekxsOXZjSFJwYjI1ekxuTmxjR0Z5WVhSdmNpazdYRzVjYmlBZ0lDQWdJQ0FnSUNCMllYSWdkbUZzZFdVZ1BTQXdPMXh1SUNBZ0lDQWdJQ0FnSUdadmNpaDJZWElnYVNBOUlEQTdJR2tnUENCd1lYSjBjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQWdJQ0FnZG1GeUlIQmhjblFnUFNCd1lYSjBjMXRwWFR0Y2JseHVJQ0FnSUNBZ0lDQWdJQ0FnZG1Gc2RXVWdmRDBnZEdocGMxdHdZWEowWFM1MllXeDFaVHRjYmlBZ0lDQWdJQ0FnSUNCOVhHNWNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdibVYzSUVWdWRXMUpkR1Z0S0d0bGVTd2dkbUZzZFdVcE8xeHVJQ0FnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6VzJ0bGVWMDdYRzRnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJRzBnYVc0Z2RHaHBjeWtnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2gwYUdsekxtaGhjMDkzYmxCeWIzQmxjblI1S0cwcEtTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9kR2hwYzF0dFhTNTJZV3gxWlNBOVBUMGdhMlY1S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdselcyMWRPMXh1SUNBZ0lDQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lIWmhjaUJ5WlhOMWJIUWdQU0J1ZFd4c08xeHVYRzRnSUNBZ0lDQWdJR2xtSUNoMGFHbHpMbWx6Um14aFoyZGhZbXhsS1NCN1hHNGdJQ0FnSUNBZ0lDQWdabTl5SUNoMllYSWdiaUJwYmlCMGFHbHpLU0I3WEc0Z0lDQWdJQ0FnSUNBZ0lDQnBaaUFvZEdocGN5NW9ZWE5QZDI1UWNtOXdaWEowZVNodUtTa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnBaaUFvS0d0bGVTQW1JSFJvYVhOYmJsMHVkbUZzZFdVcElDRTlQU0F3S1NCN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2FXWWdLSEpsYzNWc2RDa2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WemRXeDBJQ3M5SUhSb2FYTXVYMjl3ZEdsdmJuTXVjMlZ3WVhKaGRHOXlPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J5WlhOMWJIUWdQU0FuSnp0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2NtVnpkV3gwSUNzOUlHNDdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NW5aWFFvY21WemRXeDBJSHg4SUc1MWJHd3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZLaXBjYmlBZ0lDQWdLaUJFWldacGJtVWdabkpsWlhwbFJXNTFiWE1vS1NCaGN5QmhJSEJ5YjNCbGNuUjVJRzltSUhSb1pTQndjbTkwYjNSNWNHVXVYRzRnSUNBZ0lDb2diV0ZyWlNCbGJuVnRaWEpoWW14bElHbDBaVzF6SUc1dmJtTnZibVpwWjNWeVlXSnNaU0JoYm1RZ1pHVmxjQ0JtY21WbGVtVWdkR2hsSUhCeWIzQmxjblJwWlhNdUlGUm9jbTkzSUVWeWNtOXlJRzl1SUhCeWIzQmxjblI1SUhObGRIUmxjaTVjYmlBZ0lDQWdLaTljYmlBZ0lDQm1jbVZsZW1WRmJuVnRjem9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCbWRXNWpkR2x2YmlCbWNtVmxlbVZ5S0c4cElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUhCeWIzQnpJRDBnVDJKcVpXTjBMbWRsZEU5M2JsQnliM0JsY25SNVRtRnRaWE1vYnlrN1hHNGdJQ0FnSUNBZ0lIQnliM0J6TG1admNrVmhZMmdvSUdaMWJtTjBhVzl1S0hBcGUxeHVJQ0FnSUNBZ0lDQWdJR2xtSUNnaFQySnFaV04wTG1kbGRFOTNibEJ5YjNCbGNuUjVSR1Z6WTNKcGNIUnZjaWh2TENCd0tTNWpiMjVtYVdkMWNtRmliR1VwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNBZ0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUNBZ0lDQlBZbXBsWTNRdVpHVm1hVzVsVUhKdmNHVnlkR2xsY3lodkxDQndMQ0I3ZDNKcGRHRmliR1U2Wm1Gc2MyVXNJR052Ym1acFozVnlZV0pzWlRwbVlXeHpaWDBwTzF4dUlDQWdJQ0FnSUNCOUtWeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2J6dGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdablZ1WTNScGIyNGdaMlYwVUhKdmNHVnlkSGxXWVd4MVpTaDJZV3gxWlNrZ2UxeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2RtRnNkV1U3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUdaMWJtTjBhVzl1SUdSbFpYQkdjbVZsZW1WRmJuVnRjeWh2S1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwZVhCbGIyWWdieUFoUFQwZ0oyOWlhbVZqZENjZ2ZId2dieUE5UFQwZ2JuVnNiQ0I4ZkNCUFltcGxZM1F1YVhOR2NtOTZaVzRvYnlrZ2ZId2dUMkpxWldOMExtbHpVMlZoYkdWa0tHOHBJQ2w3WEc0Z0lDQWdJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lHWnZjaUFvZG1GeUlHdGxlU0JwYmlCdktTQjdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHOHVhR0Z6VDNkdVVISnZjR1Z5ZEhrb2EyVjVLU2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdieTVmWDJSbFptbHVaVWRsZEhSbGNsOWZLR3RsZVN3Z1oyVjBVSEp2Y0dWeWRIbFdZV3gxWlM1aWFXNWtLRzUxYkd3c0lHOWJhMlY1WFNrcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnYnk1ZlgyUmxabWx1WlZObGRIUmxjbDlmS0d0bGVTd2dablZ1WTNScGIyNGdkR2h5YjNkUWNtOXdaWEowZVZObGRFVnljbTl5S0haaGJIVmxLWHQwYUhKdmR5QlVlWEJsUlhKeWIzSW9YQ0pEWVc1dWIzUWdjbVZrWldacGJtVWdjSEp2Y0dWeWRIazdJRVZ1ZFcwZ1ZIbHdaU0JwY3lCdWIzUWdaWGgwWlc1emFXSnNaUzVjSWlsOUtUdGNiaUFnSUNBZ0lDQWdJQ0FnSUdSbFpYQkdjbVZsZW1WRmJuVnRjeWh2VzJ0bGVWMHBPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ0lDQnBaaUFvVDJKcVpXTjBMbVp5WldWNlpTa2dlMXh1SUNBZ0lDQWdJQ0FnSUU5aWFtVmpkQzVtY21WbGVtVW9ieWs3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ1puSmxaWHBsY2lodktUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0JrWldWd1JuSmxaWHBsUlc1MWJYTW9kR2hwY3lrN1hHNWNiaUFnSUNBZ0lISmxkSFZ5YmlCMGFHbHpPMXh1SUNBZ0lIMHNYRzRnSUgwN1hHNWNibHh1SUNCcFppQW9iVzlrZFd4bElDWW1JRzF2WkhWc1pTNWxlSEJ2Y25SektTQjdYRzRnSUNBZ2JXOWtkV3hsTG1WNGNHOXlkSE1nUFNCRmJuVnRPMXh1SUNCOUlHVnNjMlVnYVdZZ0tHUmxabWx1WlNrZ2UxeHVJQ0FnSUdSbFptbHVaU2htZFc1amRHbHZiaUFvS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnUlc1MWJUdGNiaUFnSUNCOUtUdGNiaUFnZlNCbGJITmxJSHRjYmlBZ0lDQnliMjkwTGtWdWRXMGdQU0JGYm5WdE8xeHVJQ0I5WEc1Y2JpQWdhV1lnS0cxdlpIVnNaU0FtSmlCdGIyUjFiR1V1Wlhod2IzSjBjeUFtSmlCbmJHOWlZV3dwSUh0Y2JseHVJQ0FnSUM4cUtseHVJQ0FnSUNBcUlGSmxaMmx6ZEdWeWN5QjBhR1VnUlc1MWJTQlVlWEJsSUdkc2IySmhiR3g1SUdsdUlHNXZaR1V1YW5NdVhHNGdJQ0FnSUNvZ1FIQmhjbUZ0SUNCN1UzUnlhVzVuZlNCclpYa2dSMnh2WW1Gc0lIWmhjbWxoWW14bExpQmJiM0IwYVc5dVlXeGRYRzRnSUNBZ0lDb3ZYRzRnSUNBZ1JXNTFiUzV5WldkcGMzUmxjaUE5SUdaMWJtTjBhVzl1S0d0bGVTa2dlMXh1SUNBZ0lDQWdhMlY1SUQwZ2EyVjVJSHg4SUNkRmJuVnRKenRjYmlBZ0lDQWdJR2xtSUNnaFoyeHZZbUZzVzJ0bGVWMHBJSHRjYmlBZ0lDQWdJQ0FnWjJ4dlltRnNXMnRsZVYwZ1BTQkZiblZ0TzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDA3WEc0Z0lIMWNibHh1ZlNoY2JpQWdkR2hwY3l4Y2JpQWdkSGx3Wlc5bUtHMXZaSFZzWlNrZ0lUMDlJQ2QxYm1SbFptbHVaV1FuSUQ4Z2JXOWtkV3hsSURvZ2RXNWtaV1pwYm1Wa0xGeHVJQ0IwZVhCbGIyWW9aMnh2WW1Gc0tTQWhQVDBnSjNWdVpHVm1hVzVsWkNjZ1B5Qm5iRzlpWVd3Z09pQjFibVJsWm1sdVpXUXNYRzRnSUhSNWNHVnZaaWhrWldacGJtVXBJQ0U5UFNBbmRXNWtaV1pwYm1Wa0p5QS9JR1JsWm1sdVpTQTZJSFZ1WkdWbWFXNWxaRnh1S1NrN1hHNGlYWDA9IiwiLyohXHJcbiAqIEBuYW1lIEphdmFTY3JpcHQvTm9kZUpTIE1lcmdlIHYxLjIuMFxyXG4gKiBAYXV0aG9yIHllaWtvc1xyXG4gKiBAcmVwb3NpdG9yeSBodHRwczovL2dpdGh1Yi5jb20veWVpa29zL2pzLm1lcmdlXHJcblxyXG4gKiBDb3B5cmlnaHQgMjAxNCB5ZWlrb3MgLSBNSVQgbGljZW5zZVxyXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL3llaWtvcy9qcy5tZXJnZS9tYXN0ZXIvTElDRU5TRVxyXG4gKi9cclxuXHJcbjsoZnVuY3Rpb24oaXNOb2RlKSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIE1lcmdlIG9uZSBvciBtb3JlIG9iamVjdHMgXHJcblx0ICogQHBhcmFtIGJvb2w/IGNsb25lXHJcblx0ICogQHBhcmFtIG1peGVkLC4uLiBhcmd1bWVudHNcclxuXHQgKiBAcmV0dXJuIG9iamVjdFxyXG5cdCAqL1xyXG5cclxuXHR2YXIgUHVibGljID0gZnVuY3Rpb24oY2xvbmUpIHtcclxuXHJcblx0XHRyZXR1cm4gbWVyZ2UoY2xvbmUgPT09IHRydWUsIGZhbHNlLCBhcmd1bWVudHMpO1xyXG5cclxuXHR9LCBwdWJsaWNOYW1lID0gJ21lcmdlJztcclxuXHJcblx0LyoqXHJcblx0ICogTWVyZ2UgdHdvIG9yIG1vcmUgb2JqZWN0cyByZWN1cnNpdmVseSBcclxuXHQgKiBAcGFyYW0gYm9vbD8gY2xvbmVcclxuXHQgKiBAcGFyYW0gbWl4ZWQsLi4uIGFyZ3VtZW50c1xyXG5cdCAqIEByZXR1cm4gb2JqZWN0XHJcblx0ICovXHJcblxyXG5cdFB1YmxpYy5yZWN1cnNpdmUgPSBmdW5jdGlvbihjbG9uZSkge1xyXG5cclxuXHRcdHJldHVybiBtZXJnZShjbG9uZSA9PT0gdHJ1ZSwgdHJ1ZSwgYXJndW1lbnRzKTtcclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2xvbmUgdGhlIGlucHV0IHJlbW92aW5nIGFueSByZWZlcmVuY2VcclxuXHQgKiBAcGFyYW0gbWl4ZWQgaW5wdXRcclxuXHQgKiBAcmV0dXJuIG1peGVkXHJcblx0ICovXHJcblxyXG5cdFB1YmxpYy5jbG9uZSA9IGZ1bmN0aW9uKGlucHV0KSB7XHJcblxyXG5cdFx0dmFyIG91dHB1dCA9IGlucHV0LFxyXG5cdFx0XHR0eXBlID0gdHlwZU9mKGlucHV0KSxcclxuXHRcdFx0aW5kZXgsIHNpemU7XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdhcnJheScpIHtcclxuXHJcblx0XHRcdG91dHB1dCA9IFtdO1xyXG5cdFx0XHRzaXplID0gaW5wdXQubGVuZ3RoO1xyXG5cclxuXHRcdFx0Zm9yIChpbmRleD0wO2luZGV4PHNpemU7KytpbmRleClcclxuXHJcblx0XHRcdFx0b3V0cHV0W2luZGV4XSA9IFB1YmxpYy5jbG9uZShpbnB1dFtpbmRleF0pO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcclxuXHJcblx0XHRcdG91dHB1dCA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yIChpbmRleCBpbiBpbnB1dClcclxuXHJcblx0XHRcdFx0b3V0cHV0W2luZGV4XSA9IFB1YmxpYy5jbG9uZShpbnB1dFtpbmRleF0pO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBNZXJnZSB0d28gb2JqZWN0cyByZWN1cnNpdmVseVxyXG5cdCAqIEBwYXJhbSBtaXhlZCBpbnB1dFxyXG5cdCAqIEBwYXJhbSBtaXhlZCBleHRlbmRcclxuXHQgKiBAcmV0dXJuIG1peGVkXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIG1lcmdlX3JlY3Vyc2l2ZShiYXNlLCBleHRlbmQpIHtcclxuXHJcblx0XHRpZiAodHlwZU9mKGJhc2UpICE9PSAnb2JqZWN0JylcclxuXHJcblx0XHRcdHJldHVybiBleHRlbmQ7XHJcblxyXG5cdFx0Zm9yICh2YXIga2V5IGluIGV4dGVuZCkge1xyXG5cclxuXHRcdFx0aWYgKHR5cGVPZihiYXNlW2tleV0pID09PSAnb2JqZWN0JyAmJiB0eXBlT2YoZXh0ZW5kW2tleV0pID09PSAnb2JqZWN0Jykge1xyXG5cclxuXHRcdFx0XHRiYXNlW2tleV0gPSBtZXJnZV9yZWN1cnNpdmUoYmFzZVtrZXldLCBleHRlbmRba2V5XSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRiYXNlW2tleV0gPSBleHRlbmRba2V5XTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJhc2U7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWVyZ2UgdHdvIG9yIG1vcmUgb2JqZWN0c1xyXG5cdCAqIEBwYXJhbSBib29sIGNsb25lXHJcblx0ICogQHBhcmFtIGJvb2wgcmVjdXJzaXZlXHJcblx0ICogQHBhcmFtIGFycmF5IGFyZ3ZcclxuXHQgKiBAcmV0dXJuIG9iamVjdFxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBtZXJnZShjbG9uZSwgcmVjdXJzaXZlLCBhcmd2KSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IGFyZ3ZbMF0sXHJcblx0XHRcdHNpemUgPSBhcmd2Lmxlbmd0aDtcclxuXHJcblx0XHRpZiAoY2xvbmUgfHwgdHlwZU9mKHJlc3VsdCkgIT09ICdvYmplY3QnKVxyXG5cclxuXHRcdFx0cmVzdWx0ID0ge307XHJcblxyXG5cdFx0Zm9yICh2YXIgaW5kZXg9MDtpbmRleDxzaXplOysraW5kZXgpIHtcclxuXHJcblx0XHRcdHZhciBpdGVtID0gYXJndltpbmRleF0sXHJcblxyXG5cdFx0XHRcdHR5cGUgPSB0eXBlT2YoaXRlbSk7XHJcblxyXG5cdFx0XHRpZiAodHlwZSAhPT0gJ29iamVjdCcpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGl0ZW0pIHtcclxuXHJcblx0XHRcdFx0dmFyIHNpdGVtID0gY2xvbmUgPyBQdWJsaWMuY2xvbmUoaXRlbVtrZXldKSA6IGl0ZW1ba2V5XTtcclxuXHJcblx0XHRcdFx0aWYgKHJlY3Vyc2l2ZSkge1xyXG5cclxuXHRcdFx0XHRcdHJlc3VsdFtrZXldID0gbWVyZ2VfcmVjdXJzaXZlKHJlc3VsdFtrZXldLCBzaXRlbSk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0W2tleV0gPSBzaXRlbTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0eXBlIG9mIHZhcmlhYmxlXHJcblx0ICogQHBhcmFtIG1peGVkIGlucHV0XHJcblx0ICogQHJldHVybiBzdHJpbmdcclxuXHQgKlxyXG5cdCAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vdHlwZW9mdmFyXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIHR5cGVPZihpbnB1dCkge1xyXG5cclxuXHRcdHJldHVybiAoe30pLnRvU3RyaW5nLmNhbGwoaW5wdXQpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmIChpc05vZGUpIHtcclxuXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFB1YmxpYztcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR3aW5kb3dbcHVibGljTmFtZV0gPSBQdWJsaWM7XHJcblxyXG5cdH1cclxuXHJcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKTsiLCIvKiB2aW06c2V0IHRzPTIgc3c9MiBzdHM9MiBleHBhbmR0YWIgKi9cclxuLypqc2hpbnQgdW5kZWY6IHRydWUgZXM1OiB0cnVlIG5vZGU6IHRydWUgZGV2ZWw6IHRydWUgZXZpbDogdHJ1ZVxyXG4gICAgICAgICBmb3JpbjogdHJ1ZSBsYXRlZGVmOiBmYWxzZSBzdXBlcm5ldzogdHJ1ZSAqL1xyXG4vKmdsb2JhbCBkZWZpbmU6IHRydWUgKi9cclxuXHJcbiEodHlwZW9mIGRlZmluZSAhPT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24oXywgJCl7ICQobnVsbCwgdHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHdpbmRvdyk7IH0gOiBkZWZpbmUpKCdzZWxmaXNoJywgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5leHBvcnRzLkJhc2UgPSBPYmplY3QuZnJlZXplKE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBgdGhpc2Agb2JqZWN0IChBbmFsb2cgb2ZcclxuICAgKiBgbmV3IE9iamVjdCgpYCkuXHJcbiAgICogQGV4YW1wbGVzXHJcbiAgICpcclxuICAgKiAgICB2YXIgRG9nID0gQmFzZS5leHRlbmQoe1xyXG4gICAqICAgICAgYmFyazogZnVuY3Rpb24gYmFyaygpIHtcclxuICAgKiAgICAgICAgcmV0dXJuICdSdWZmISBSdWZmISdcclxuICAgKiAgICAgIH1cclxuICAgKiAgICB9KTtcclxuICAgKiAgICB2YXIgZG9nID0gRG9nLm5ldygpO1xyXG4gICAqL1xyXG4gICduZXcnOiB7IHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XHJcbiAgICB2YXIgb2JqZWN0ID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcclxuICAgIG9iamVjdC5pbml0aWFsaXplLmFwcGx5KG9iamVjdCwgYXJndW1lbnRzKTtcclxuICAgIHJldHVybiBvYmplY3Q7XHJcbiAgfX0sXHJcbiAgLyoqXHJcbiAgICogV2hlbiBuZXcgaW5zdGFuY2Ugb2YgdGhlIHRoaXMgcHJvdG90eXBlIGlzIGNyZWF0ZWQgaXQncyBgaW5pdGlhbGl6ZWBcclxuICAgKiBtZXRob2QgaXMgY2FsbGVkIHdpdGggYWxsIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBgbmV3YC4gWW91IGNhblxyXG4gICAqIG92ZXJyaWRlIGBpbml0aWFsaXplYCB0byBzZXQgdXAgYW4gaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgaW5pdGlhbGl6ZTogeyB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcclxuICB9fSxcclxuICAvKipcclxuICAgKiBNZXJnZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBwYXNzZWQgb2JqZWN0cyBpbnRvIGB0aGlzYCBpbnN0YW5jZSAoVGhpc1xyXG4gICAqIG1ldGhvZCBjYW4gYmUgdXNlZCBvbiBpbnN0YW5jZXMgb25seSBhcyBwcm90b3R5cGUgb2JqZWN0cyBhcmUgZnJvemVuKS5cclxuICAgKlxyXG4gICAqIElmIHR3byBvciBtb3JlIGFyZ3VtZW50IG9iamVjdHMgaGF2ZSBvd24gcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIG5hbWUsXHJcbiAgICogdGhlIHByb3BlcnR5IGlzIG92ZXJyaWRkZW4sIHdpdGggcHJlY2VkZW5jZSBmcm9tIHJpZ2h0IHRvIGxlZnQsIGltcGx5aW5nLFxyXG4gICAqIHRoYXQgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IG9uIHRoZSBsZWZ0IGFyZSBvdmVycmlkZGVuIGJ5IGEgc2FtZSBuYW1lZFxyXG4gICAqIHByb3BlcnR5IG9mIHRoZSBvYmplY3Qgb24gdGhlIHJpZ2h0LlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVzXHJcbiAgICpcclxuICAgKiAgICB2YXIgUGV0ID0gRG9nLmV4dGVuZCh7XHJcbiAgICogICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG9wdGlvbnMpIHtcclxuICAgKiAgICAgICAgLy8gdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIC0+IHdvdWxkIGhhdmUgdGhyb3duIChmcm96ZW4gcHJvdG90eXBlKVxyXG4gICAqICAgICAgICB0aGlzLm1lcmdlKG9wdGlvbnMpIC8vIHdpbGwgb3ZlcnJpZGUgYWxsIHByb3BlcnRpZXMuXHJcbiAgICogICAgICB9LFxyXG4gICAqICAgICAgY2FsbDogZnVuY3Rpb24obmFtZSkge1xyXG4gICAqICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBuYW1lID8gdGhpcy5iYXJrKCkgOiAnJ1xyXG4gICAqICAgICAgfSxcclxuICAgKiAgICAgIG5hbWU6IG51bGxcclxuICAgKiAgICB9KVxyXG4gICAqICAgIHZhciBwZXQgPSBQZXQubmV3KHsgbmFtZTogJ0Jlbnp5JywgYnJlZWQ6ICdMYWJyYWRvcicgfSlcclxuICAgKiAgICBwZXQuY2FsbCgnQmVuenknKSAgIC8vICdSdWZmISBSdWZmISdcclxuICAgKi9cclxuICBtZXJnZTogeyB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UoKSB7XHJcbiAgICB2YXIgZGVzY3JpcHRvciA9IHt9O1xyXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIGRlc2NyaXB0b3JbbmFtZV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3BlcnRpZXMsIG5hbWUpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgZGVzY3JpcHRvcik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9fSxcclxuICAvKipcclxuICAgKiBUYWtlcyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50IG9iamVjdHMgYW5kIHJldHVybnMgZnJvemVuLCBjb21wb3NpdGUgb2JqZWN0XHJcbiAgICogdGhhdCBpbmhlcml0cyBmcm9tIGB0aGlzYCBvYmplY3QgYW5kIGNvbWJpbmVzIGFsbCBvZiB0aGUgb3duIHByb3BlcnRpZXMgb2ZcclxuICAgKiB0aGUgYXJndW1lbnQgb2JqZWN0cy4gKE9iamVjdHMgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBhcmUgZnJvemVuIGFzXHJcbiAgICogdGhleSBhcmUgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyB0eXBlcykuXHJcbiAgICpcclxuICAgKiBJZiB0d28gb3IgbW9yZSBhcmd1bWVudCBvYmplY3RzIGhhdmUgb3duIHByb3BlcnRpZXMgd2l0aCB0aGUgc2FtZSBuYW1lLFxyXG4gICAqIHRoZSBwcm9wZXJ0eSBpcyBvdmVycmlkZGVuLCB3aXRoIHByZWNlZGVuY2UgZnJvbSByaWdodCB0byBsZWZ0LCBpbXBseWluZyxcclxuICAgKiB0aGF0IHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBvbiB0aGUgbGVmdCBhcmUgb3ZlcnJpZGRlbiBieSBhIHNhbWUgbmFtZWRcclxuICAgKiBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IG9uIHRoZSByaWdodC5cclxuICAgKiBAZXhhbXBsZXNcclxuICAgKlxyXG4gICAqICAgIC8vICMjIE9iamVjdCBjb21wb3NpdGlvbiAjI1xyXG4gICAqXHJcbiAgICogICAgdmFyIEhFWCA9IEJhc2UuZXh0ZW5kKHtcclxuICAgKiAgICAgIGhleDogZnVuY3Rpb24gaGV4KCkge1xyXG4gICAqICAgICAgICByZXR1cm4gJyMnICsgdGhpcy5jb2xvcjtcclxuICAgKiAgICAgIH1cclxuICAgKiAgICB9KVxyXG4gICAqXHJcbiAgICogICAgdmFyIFJHQiA9IEJhc2UuZXh0ZW5kKHtcclxuICAgKiAgICAgIHJlZDogZnVuY3Rpb24gcmVkKCkge1xyXG4gICAqICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5jb2xvci5zdWJzdHIoMCwgMiksIDE2KTtcclxuICAgKiAgICAgIH0sXHJcbiAgICogICAgICBncmVlbjogZnVuY3Rpb24gZ3JlZW4oKSB7XHJcbiAgICogICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLmNvbG9yLnN1YnN0cigyLCAyKSwgMTYpO1xyXG4gICAqICAgICAgfSxcclxuICAgKiAgICAgIGJsdWU6IGZ1bmN0aW9uIGJsdWUoKSB7XHJcbiAgICogICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLmNvbG9yLnN1YnN0cig0LCAyKSwgMTYpO1xyXG4gICAqICAgICAgfVxyXG4gICAqICAgIH0pXHJcbiAgICpcclxuICAgKiAgICB2YXIgQ01ZSyA9IEJhc2UuZXh0ZW5kKFJHQiwge1xyXG4gICAqICAgICAgYmxhY2s6IGZ1bmN0aW9uIGJsYWNrKCkge1xyXG4gICAqICAgICAgICB2YXIgY29sb3IgPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLnJlZCgpLCB0aGlzLmdyZWVuKCkpLCB0aGlzLmJsdWUoKSk7XHJcbiAgICogICAgICAgIHJldHVybiAoMSAtIGNvbG9yIC8gMjU1KS50b0ZpeGVkKDQpO1xyXG4gICAqICAgICAgfSxcclxuICAgKiAgICAgIGN5YW46IGZ1bmN0aW9uIGN5YW4oKSB7XHJcbiAgICogICAgICAgIHZhciBLID0gdGhpcy5ibGFjaygpO1xyXG4gICAqICAgICAgICByZXR1cm4gKCgoMSAtIHRoaXMucmVkKCkgLyAyNTUpLnRvRml4ZWQoNCkgLSBLKSAvICgxIC0gSykpLnRvRml4ZWQoNCk7XHJcbiAgICogICAgICB9LFxyXG4gICAqICAgICAgbWFnZW50YTogZnVuY3Rpb24gbWFnZW50YSgpIHtcclxuICAgKiAgICAgICAgdmFyIEsgPSB0aGlzLmJsYWNrKCk7XHJcbiAgICogICAgICAgIHJldHVybiAoKCgxIC0gdGhpcy5ncmVlbigpIC8gMjU1KS50b0ZpeGVkKDQpIC0gSykgLyAoMSAtIEspKS50b0ZpeGVkKDQpO1xyXG4gICAqICAgICAgfSxcclxuICAgKiAgICAgIHllbGxvdzogZnVuY3Rpb24geWVsbG93KCkge1xyXG4gICAqICAgICAgICB2YXIgSyA9IHRoaXMuYmxhY2soKTtcclxuICAgKiAgICAgICAgcmV0dXJuICgoKDEgLSB0aGlzLmJsdWUoKSAvIDI1NSkudG9GaXhlZCg0KSAtIEspIC8gKDEgLSBLKSkudG9GaXhlZCg0KTtcclxuICAgKiAgICAgIH1cclxuICAgKiAgICB9KVxyXG4gICAqXHJcbiAgICogICAgdmFyIENvbG9yID0gQmFzZS5leHRlbmQoSEVYLCBSR0IsIENNWUssIHtcclxuICAgKiAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbG9yKGNvbG9yKSB7XHJcbiAgICogICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgKiAgICAgIH1cclxuICAgKiAgICB9KTtcclxuICAgKlxyXG4gICAqICAgIC8vICMjIFByb3RvdHlwYWwgaW5oZXJpdGFuY2UgIyNcclxuICAgKlxyXG4gICAqICAgIHZhciBQaXhlbCA9IENvbG9yLmV4dGVuZCh7XHJcbiAgICogICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBQaXhlbCh4LCB5LCBoZXgpIHtcclxuICAgKiAgICAgICAgQ29sb3IuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGhleCk7XHJcbiAgICogICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICogICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICogICAgICB9LFxyXG4gICAqICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG4gICAqICAgICAgICByZXR1cm4gdGhpcy54ICsgJzonICsgdGhpcy55ICsgJ0AnICsgdGhpcy5oZXgoKTtcclxuICAgKiAgICAgIH1cclxuICAgKiAgICB9KTtcclxuICAgKlxyXG4gICAqICAgIHZhciBwaXhlbCA9IFBpeGVsLm5ldygxMSwgMjMsICdDQzMzOTknKVxyXG4gICAqICAgIHBpeGVsLnRvU3RyaW5nKCk7IC8vIDExOjIzQCNDQzMzOTlcclxuICAgKlxyXG4gICAqICAgIHBpeGVsLnJlZCgpOyAgICAgIC8vIDIwNFxyXG4gICAqICAgIHBpeGVsLmdyZWVuKCk7ICAgIC8vIDUxXHJcbiAgICogICAgcGl4ZWwuYmx1ZSgpOyAgICAgLy8gMTUzXHJcbiAgICpcclxuICAgKiAgICBwaXhlbC5jeWFuKCk7ICAgICAvLyAwLjAwMDBcclxuICAgKiAgICBwaXhlbC5tYWdlbnRhKCk7ICAvLyAwLjc1MDBcclxuICAgKiAgICBwaXhlbC55ZWxsb3coKTsgICAvLyAwLjI1MDBcclxuICAgKlxyXG4gICAqL1xyXG4gICBleHRlbmQ6IHsgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcclxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHRoaXMubWVyZ2UuYXBwbHkoT2JqZWN0LmNyZWF0ZSh0aGlzKSwgYXJndW1lbnRzKSk7XHJcbiAgfX1cclxufSkpO1xyXG5cclxufSk7XHJcbiJdfQ==
